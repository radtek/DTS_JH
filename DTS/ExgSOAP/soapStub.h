/* soapStub.h
   Generated by gSOAP 2.8.51 for MESService.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_tempuri	"http://tempuri.org/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20851
# error "GSOAP VERSION 20851 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class _tempuri__GetDate;	/* MESService.h:139 */
class _tempuri__GetDateResponse;	/* MESService.h:142 */
class _tempuri__GetDocCode;	/* MESService.h:145 */
class _tempuri__GetDocCodeResponse;	/* MESService.h:148 */
class _tempuri__ToolingTimes;	/* MESService.h:151 */
class _tempuri__ToolingTimesResponse;	/* MESService.h:154 */
class _tempuri__WorkOrder;	/* MESService.h:157 */
class _tempuri__WorkOrderResponse;	/* MESService.h:160 */
class _tempuri__LineInventory;	/* MESService.h:163 */
class _tempuri__LineInventoryResponse;	/* MESService.h:166 */
class _tempuri__LineInventoryUpdate;	/* MESService.h:169 */
class _tempuri__LineInventoryUpdateResponse;	/* MESService.h:172 */
class _tempuri__LineInventoryReturn;	/* MESService.h:175 */
class _tempuri__LineInventoryReturnResponse;	/* MESService.h:178 */
class _tempuri__AnDon;	/* MESService.h:181 */
class _tempuri__AnDonResponse;	/* MESService.h:184 */
class _tempuri__AnDonCall;	/* MESService.h:187 */
class _tempuri__AnDonCallResponse;	/* MESService.h:190 */
class _tempuri__AnDonTest;	/* MESService.h:193 */
class _tempuri__AnDonTestResponse;	/* MESService.h:196 */
class _tempuri__ItemsAdd;	/* MESService.h:199 */
class _tempuri__ItemsAddResponse;	/* MESService.h:202 */
class _tempuri__DocAdd;	/* MESService.h:205 */
class _tempuri__DocAddResponse;	/* MESService.h:208 */
class _tempuri__SetExMail;	/* MESService.h:211 */
class _tempuri__SetExMailResponse;	/* MESService.h:214 */
class _tempuri__GetDept;	/* MESService.h:217 */
class _tempuri__GetDeptResponse;	/* MESService.h:220 */
class _tempuri__GetPower;	/* MESService.h:223 */
class _tempuri__GetPowerResponse;	/* MESService.h:226 */
class _tempuri__Login;	/* MESService.h:229 */
class _tempuri__LoginResponse;	/* MESService.h:232 */
struct __tempuri__GetDate;	/* MESService.h:1153 */
struct __tempuri__GetDocCode;	/* MESService.h:1223 */
struct __tempuri__ToolingTimes;	/* MESService.h:1293 */
struct __tempuri__WorkOrder;	/* MESService.h:1363 */
struct __tempuri__LineInventory;	/* MESService.h:1433 */
struct __tempuri__LineInventoryUpdate;	/* MESService.h:1503 */
struct __tempuri__LineInventoryReturn;	/* MESService.h:1573 */
struct __tempuri__AnDon;	/* MESService.h:1643 */
struct __tempuri__AnDonCall;	/* MESService.h:1713 */
struct __tempuri__AnDonTest;	/* MESService.h:1783 */
struct __tempuri__ItemsAdd;	/* MESService.h:1853 */
struct __tempuri__DocAdd;	/* MESService.h:1923 */
struct __tempuri__SetExMail;	/* MESService.h:1993 */
struct __tempuri__GetDept;	/* MESService.h:2063 */
struct __tempuri__GetPower;	/* MESService.h:2133 */
struct __tempuri__Login;	/* MESService.h:2203 */
struct __tempuri__GetDate_;	/* MESService.h:2273 */
struct __tempuri__GetDocCode_;	/* MESService.h:2343 */
struct __tempuri__ToolingTimes_;	/* MESService.h:2413 */
struct __tempuri__WorkOrder_;	/* MESService.h:2483 */
struct __tempuri__LineInventory_;	/* MESService.h:2553 */
struct __tempuri__LineInventoryUpdate_;	/* MESService.h:2623 */
struct __tempuri__LineInventoryReturn_;	/* MESService.h:2693 */
struct __tempuri__AnDon_;	/* MESService.h:2763 */
struct __tempuri__AnDonCall_;	/* MESService.h:2833 */
struct __tempuri__AnDonTest_;	/* MESService.h:2903 */
struct __tempuri__ItemsAdd_;	/* MESService.h:2973 */
struct __tempuri__DocAdd_;	/* MESService.h:3043 */
struct __tempuri__SetExMail_;	/* MESService.h:3113 */
struct __tempuri__GetDept_;	/* MESService.h:3183 */
struct __tempuri__GetPower_;	/* MESService.h:3253 */
struct __tempuri__Login_;	/* MESService.h:3323 */

/* MESService.h:139 */
#ifndef SOAP_TYPE__tempuri__GetDate
#define SOAP_TYPE__tempuri__GetDate (7)
/* complex XSD type 'tempuri:GetDate': */
class SOAP_CMAC _tempuri__GetDate {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetDate
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__GetDate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetDate, default initialized and not managed by a soap context
        virtual _tempuri__GetDate *soap_alloc(void) const { return SOAP_NEW(_tempuri__GetDate); }
      public:
        /// Constructor with initializations
        _tempuri__GetDate() : soap() { }
        virtual ~_tempuri__GetDate() { }
        /// Friend allocator used by soap_new__tempuri__GetDate(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetDate * SOAP_FMAC2 soap_instantiate__tempuri__GetDate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:142 */
#ifndef SOAP_TYPE__tempuri__GetDateResponse
#define SOAP_TYPE__tempuri__GetDateResponse (8)
/* complex XSD type 'tempuri:GetDateResponse': */
class SOAP_CMAC _tempuri__GetDateResponse {
      public:
        /// Optional element 'tempuri:GetDateResult' of XSD type 'xsd:string'
        char *GetDateResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetDateResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__GetDateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetDateResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetDateResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__GetDateResponse); }
      public:
        /// Constructor with initializations
        _tempuri__GetDateResponse() : GetDateResult(), soap() { }
        virtual ~_tempuri__GetDateResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetDateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetDateResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetDateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:145 */
#ifndef SOAP_TYPE__tempuri__GetDocCode
#define SOAP_TYPE__tempuri__GetDocCode (9)
/* complex XSD type 'tempuri:GetDocCode': */
class SOAP_CMAC _tempuri__GetDocCode {
      public:
        /// Required element 'tempuri:DocValue' of XSD type 'xsd:int'
        int DocValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetDocCode
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__GetDocCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetDocCode, default initialized and not managed by a soap context
        virtual _tempuri__GetDocCode *soap_alloc(void) const { return SOAP_NEW(_tempuri__GetDocCode); }
      public:
        /// Constructor with initializations
        _tempuri__GetDocCode() : DocValue(), soap() { }
        virtual ~_tempuri__GetDocCode() { }
        /// Friend allocator used by soap_new__tempuri__GetDocCode(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetDocCode * SOAP_FMAC2 soap_instantiate__tempuri__GetDocCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:148 */
#ifndef SOAP_TYPE__tempuri__GetDocCodeResponse
#define SOAP_TYPE__tempuri__GetDocCodeResponse (10)
/* complex XSD type 'tempuri:GetDocCodeResponse': */
class SOAP_CMAC _tempuri__GetDocCodeResponse {
      public:
        /// Optional element 'tempuri:GetDocCodeResult' of XSD type 'xsd:string'
        char *GetDocCodeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetDocCodeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__GetDocCodeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetDocCodeResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetDocCodeResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__GetDocCodeResponse); }
      public:
        /// Constructor with initializations
        _tempuri__GetDocCodeResponse() : GetDocCodeResult(), soap() { }
        virtual ~_tempuri__GetDocCodeResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetDocCodeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetDocCodeResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetDocCodeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:151 */
#ifndef SOAP_TYPE__tempuri__ToolingTimes
#define SOAP_TYPE__tempuri__ToolingTimes (11)
/* complex XSD type 'tempuri:ToolingTimes': */
class SOAP_CMAC _tempuri__ToolingTimes {
      public:
        /// Optional element 'tempuri:BillCode' of XSD type 'xsd:string'
        char *BillCode;
        /// Optional element 'tempuri:DeviceCode' of XSD type 'xsd:string'
        char *DeviceCode;
        /// Required element 'tempuri:Times' of XSD type 'xsd:int'
        int Times;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__ToolingTimes
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__ToolingTimes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__ToolingTimes, default initialized and not managed by a soap context
        virtual _tempuri__ToolingTimes *soap_alloc(void) const { return SOAP_NEW(_tempuri__ToolingTimes); }
      public:
        /// Constructor with initializations
        _tempuri__ToolingTimes() : BillCode(), DeviceCode(), Times(), soap() { }
        virtual ~_tempuri__ToolingTimes() { }
        /// Friend allocator used by soap_new__tempuri__ToolingTimes(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__ToolingTimes * SOAP_FMAC2 soap_instantiate__tempuri__ToolingTimes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:154 */
#ifndef SOAP_TYPE__tempuri__ToolingTimesResponse
#define SOAP_TYPE__tempuri__ToolingTimesResponse (12)
/* complex XSD type 'tempuri:ToolingTimesResponse': */
class SOAP_CMAC _tempuri__ToolingTimesResponse {
      public:
        /// Optional element 'tempuri:ToolingTimesResult' of XSD type 'xsd:string'
        char *ToolingTimesResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__ToolingTimesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__ToolingTimesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__ToolingTimesResponse, default initialized and not managed by a soap context
        virtual _tempuri__ToolingTimesResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__ToolingTimesResponse); }
      public:
        /// Constructor with initializations
        _tempuri__ToolingTimesResponse() : ToolingTimesResult(), soap() { }
        virtual ~_tempuri__ToolingTimesResponse() { }
        /// Friend allocator used by soap_new__tempuri__ToolingTimesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__ToolingTimesResponse * SOAP_FMAC2 soap_instantiate__tempuri__ToolingTimesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:157 */
#ifndef SOAP_TYPE__tempuri__WorkOrder
#define SOAP_TYPE__tempuri__WorkOrder (13)
/* complex XSD type 'tempuri:WorkOrder': */
class SOAP_CMAC _tempuri__WorkOrder {
      public:
        /// Optional element 'tempuri:WorkOrderXml' of XSD type 'xsd:string'
        char *WorkOrderXml;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__WorkOrder
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__WorkOrder; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__WorkOrder, default initialized and not managed by a soap context
        virtual _tempuri__WorkOrder *soap_alloc(void) const { return SOAP_NEW(_tempuri__WorkOrder); }
      public:
        /// Constructor with initializations
        _tempuri__WorkOrder() : WorkOrderXml(), soap() { }
        virtual ~_tempuri__WorkOrder() { }
        /// Friend allocator used by soap_new__tempuri__WorkOrder(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__WorkOrder * SOAP_FMAC2 soap_instantiate__tempuri__WorkOrder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:160 */
#ifndef SOAP_TYPE__tempuri__WorkOrderResponse
#define SOAP_TYPE__tempuri__WorkOrderResponse (14)
/* complex XSD type 'tempuri:WorkOrderResponse': */
class SOAP_CMAC _tempuri__WorkOrderResponse {
      public:
        /// Optional element 'tempuri:WorkOrderResult' of XSD type 'xsd:string'
        char *WorkOrderResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__WorkOrderResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__WorkOrderResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__WorkOrderResponse, default initialized and not managed by a soap context
        virtual _tempuri__WorkOrderResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__WorkOrderResponse); }
      public:
        /// Constructor with initializations
        _tempuri__WorkOrderResponse() : WorkOrderResult(), soap() { }
        virtual ~_tempuri__WorkOrderResponse() { }
        /// Friend allocator used by soap_new__tempuri__WorkOrderResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__WorkOrderResponse * SOAP_FMAC2 soap_instantiate__tempuri__WorkOrderResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:163 */
#ifndef SOAP_TYPE__tempuri__LineInventory
#define SOAP_TYPE__tempuri__LineInventory (15)
/* complex XSD type 'tempuri:LineInventory': */
class SOAP_CMAC _tempuri__LineInventory {
      public:
        /// Optional element 'tempuri:WorkLineCode' of XSD type 'xsd:string'
        char *WorkLineCode;
        /// Optional element 'tempuri:MCode' of XSD type 'xsd:string'
        char *MCode;
        /// Optional element 'tempuri:BatchNo' of XSD type 'xsd:string'
        char *BatchNo;
        /// Optional element 'tempuri:BarCode' of XSD type 'xsd:string'
        char *BarCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LineInventory
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__LineInventory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LineInventory, default initialized and not managed by a soap context
        virtual _tempuri__LineInventory *soap_alloc(void) const { return SOAP_NEW(_tempuri__LineInventory); }
      public:
        /// Constructor with initializations
        _tempuri__LineInventory() : WorkLineCode(), MCode(), BatchNo(), BarCode(), soap() { }
        virtual ~_tempuri__LineInventory() { }
        /// Friend allocator used by soap_new__tempuri__LineInventory(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LineInventory * SOAP_FMAC2 soap_instantiate__tempuri__LineInventory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:166 */
#ifndef SOAP_TYPE__tempuri__LineInventoryResponse
#define SOAP_TYPE__tempuri__LineInventoryResponse (16)
/* complex XSD type 'tempuri:LineInventoryResponse': */
class SOAP_CMAC _tempuri__LineInventoryResponse {
      public:
        /// Optional element 'tempuri:LineInventoryResult' of XSD type 'xsd:string'
        char *LineInventoryResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LineInventoryResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__LineInventoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LineInventoryResponse, default initialized and not managed by a soap context
        virtual _tempuri__LineInventoryResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__LineInventoryResponse); }
      public:
        /// Constructor with initializations
        _tempuri__LineInventoryResponse() : LineInventoryResult(), soap() { }
        virtual ~_tempuri__LineInventoryResponse() { }
        /// Friend allocator used by soap_new__tempuri__LineInventoryResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LineInventoryResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:169 */
#ifndef SOAP_TYPE__tempuri__LineInventoryUpdate
#define SOAP_TYPE__tempuri__LineInventoryUpdate (17)
/* complex XSD type 'tempuri:LineInventoryUpdate': */
class SOAP_CMAC _tempuri__LineInventoryUpdate {
      public:
        /// Optional element 'tempuri:LIXml' of XSD type 'xsd:string'
        char *LIXml;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LineInventoryUpdate
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__LineInventoryUpdate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LineInventoryUpdate, default initialized and not managed by a soap context
        virtual _tempuri__LineInventoryUpdate *soap_alloc(void) const { return SOAP_NEW(_tempuri__LineInventoryUpdate); }
      public:
        /// Constructor with initializations
        _tempuri__LineInventoryUpdate() : LIXml(), soap() { }
        virtual ~_tempuri__LineInventoryUpdate() { }
        /// Friend allocator used by soap_new__tempuri__LineInventoryUpdate(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LineInventoryUpdate * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryUpdate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:172 */
#ifndef SOAP_TYPE__tempuri__LineInventoryUpdateResponse
#define SOAP_TYPE__tempuri__LineInventoryUpdateResponse (18)
/* complex XSD type 'tempuri:LineInventoryUpdateResponse': */
class SOAP_CMAC _tempuri__LineInventoryUpdateResponse {
      public:
        /// Optional element 'tempuri:LineInventoryUpdateResult' of XSD type 'xsd:string'
        char *LineInventoryUpdateResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LineInventoryUpdateResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__LineInventoryUpdateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LineInventoryUpdateResponse, default initialized and not managed by a soap context
        virtual _tempuri__LineInventoryUpdateResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__LineInventoryUpdateResponse); }
      public:
        /// Constructor with initializations
        _tempuri__LineInventoryUpdateResponse() : LineInventoryUpdateResult(), soap() { }
        virtual ~_tempuri__LineInventoryUpdateResponse() { }
        /// Friend allocator used by soap_new__tempuri__LineInventoryUpdateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LineInventoryUpdateResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryUpdateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:175 */
#ifndef SOAP_TYPE__tempuri__LineInventoryReturn
#define SOAP_TYPE__tempuri__LineInventoryReturn (19)
/* complex XSD type 'tempuri:LineInventoryReturn': */
class SOAP_CMAC _tempuri__LineInventoryReturn {
      public:
        /// Optional element 'tempuri:LRXml' of XSD type 'xsd:string'
        char *LRXml;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LineInventoryReturn
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__LineInventoryReturn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LineInventoryReturn, default initialized and not managed by a soap context
        virtual _tempuri__LineInventoryReturn *soap_alloc(void) const { return SOAP_NEW(_tempuri__LineInventoryReturn); }
      public:
        /// Constructor with initializations
        _tempuri__LineInventoryReturn() : LRXml(), soap() { }
        virtual ~_tempuri__LineInventoryReturn() { }
        /// Friend allocator used by soap_new__tempuri__LineInventoryReturn(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LineInventoryReturn * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryReturn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:178 */
#ifndef SOAP_TYPE__tempuri__LineInventoryReturnResponse
#define SOAP_TYPE__tempuri__LineInventoryReturnResponse (20)
/* complex XSD type 'tempuri:LineInventoryReturnResponse': */
class SOAP_CMAC _tempuri__LineInventoryReturnResponse {
      public:
        /// Optional element 'tempuri:LineInventoryReturnResult' of XSD type 'xsd:string'
        char *LineInventoryReturnResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LineInventoryReturnResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__LineInventoryReturnResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LineInventoryReturnResponse, default initialized and not managed by a soap context
        virtual _tempuri__LineInventoryReturnResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__LineInventoryReturnResponse); }
      public:
        /// Constructor with initializations
        _tempuri__LineInventoryReturnResponse() : LineInventoryReturnResult(), soap() { }
        virtual ~_tempuri__LineInventoryReturnResponse() { }
        /// Friend allocator used by soap_new__tempuri__LineInventoryReturnResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LineInventoryReturnResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryReturnResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:181 */
#ifndef SOAP_TYPE__tempuri__AnDon
#define SOAP_TYPE__tempuri__AnDon (21)
/* complex XSD type 'tempuri:AnDon': */
class SOAP_CMAC _tempuri__AnDon {
      public:
        /// Optional element 'tempuri:Type' of XSD type 'xsd:string'
        char *Type;
        /// Optional element 'tempuri:DocXmlMaster' of XSD type 'xsd:string'
        char *DocXmlMaster;
        /// Optional element 'tempuri:DocXmlList' of XSD type 'xsd:string'
        char *DocXmlList;
        /// Optional element 'tempuri:DocXmlSLList' of XSD type 'xsd:string'
        char *DocXmlSLList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDon
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDon; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDon, default initialized and not managed by a soap context
        virtual _tempuri__AnDon *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDon); }
      public:
        /// Constructor with initializations
        _tempuri__AnDon() : Type(), DocXmlMaster(), DocXmlList(), DocXmlSLList(), soap() { }
        virtual ~_tempuri__AnDon() { }
        /// Friend allocator used by soap_new__tempuri__AnDon(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDon * SOAP_FMAC2 soap_instantiate__tempuri__AnDon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:184 */
#ifndef SOAP_TYPE__tempuri__AnDonResponse
#define SOAP_TYPE__tempuri__AnDonResponse (22)
/* complex XSD type 'tempuri:AnDonResponse': */
class SOAP_CMAC _tempuri__AnDonResponse {
      public:
        /// Optional element 'tempuri:AnDonResult' of XSD type 'xsd:string'
        char *AnDonResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonResponse, default initialized and not managed by a soap context
        virtual _tempuri__AnDonResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonResponse); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonResponse() : AnDonResult(), soap() { }
        virtual ~_tempuri__AnDonResponse() { }
        /// Friend allocator used by soap_new__tempuri__AnDonResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:187 */
#ifndef SOAP_TYPE__tempuri__AnDonCall
#define SOAP_TYPE__tempuri__AnDonCall (23)
/* complex XSD type 'tempuri:AnDonCall': */
class SOAP_CMAC _tempuri__AnDonCall {
      public:
        /// Optional element 'tempuri:AnDonCallXml' of XSD type 'xsd:string'
        char *AnDonCallXml;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonCall
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonCall; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonCall, default initialized and not managed by a soap context
        virtual _tempuri__AnDonCall *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonCall); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonCall() : AnDonCallXml(), soap() { }
        virtual ~_tempuri__AnDonCall() { }
        /// Friend allocator used by soap_new__tempuri__AnDonCall(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonCall * SOAP_FMAC2 soap_instantiate__tempuri__AnDonCall(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:190 */
#ifndef SOAP_TYPE__tempuri__AnDonCallResponse
#define SOAP_TYPE__tempuri__AnDonCallResponse (24)
/* complex XSD type 'tempuri:AnDonCallResponse': */
class SOAP_CMAC _tempuri__AnDonCallResponse {
      public:
        /// Optional element 'tempuri:AnDonCallResult' of XSD type 'xsd:string'
        char *AnDonCallResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonCallResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonCallResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonCallResponse, default initialized and not managed by a soap context
        virtual _tempuri__AnDonCallResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonCallResponse); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonCallResponse() : AnDonCallResult(), soap() { }
        virtual ~_tempuri__AnDonCallResponse() { }
        /// Friend allocator used by soap_new__tempuri__AnDonCallResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonCallResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonCallResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:193 */
#ifndef SOAP_TYPE__tempuri__AnDonTest
#define SOAP_TYPE__tempuri__AnDonTest (25)
/* complex XSD type 'tempuri:AnDonTest': */
class SOAP_CMAC _tempuri__AnDonTest {
      public:
        /// Required element 'tempuri:i' of XSD type 'xsd:int'
        int i;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonTest
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonTest, default initialized and not managed by a soap context
        virtual _tempuri__AnDonTest *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonTest); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonTest() : i(), soap() { }
        virtual ~_tempuri__AnDonTest() { }
        /// Friend allocator used by soap_new__tempuri__AnDonTest(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonTest * SOAP_FMAC2 soap_instantiate__tempuri__AnDonTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:196 */
#ifndef SOAP_TYPE__tempuri__AnDonTestResponse
#define SOAP_TYPE__tempuri__AnDonTestResponse (26)
/* complex XSD type 'tempuri:AnDonTestResponse': */
class SOAP_CMAC _tempuri__AnDonTestResponse {
      public:
        /// Optional element 'tempuri:AnDonTestResult' of XSD type 'xsd:string'
        char *AnDonTestResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonTestResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonTestResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonTestResponse, default initialized and not managed by a soap context
        virtual _tempuri__AnDonTestResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonTestResponse); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonTestResponse() : AnDonTestResult(), soap() { }
        virtual ~_tempuri__AnDonTestResponse() { }
        /// Friend allocator used by soap_new__tempuri__AnDonTestResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonTestResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonTestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:199 */
#ifndef SOAP_TYPE__tempuri__ItemsAdd
#define SOAP_TYPE__tempuri__ItemsAdd (27)
/* complex XSD type 'tempuri:ItemsAdd': */
class SOAP_CMAC _tempuri__ItemsAdd {
      public:
        /// Optional element 'tempuri:itemDocXml' of XSD type 'xsd:string'
        char *itemDocXml;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__ItemsAdd
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__ItemsAdd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__ItemsAdd, default initialized and not managed by a soap context
        virtual _tempuri__ItemsAdd *soap_alloc(void) const { return SOAP_NEW(_tempuri__ItemsAdd); }
      public:
        /// Constructor with initializations
        _tempuri__ItemsAdd() : itemDocXml(), soap() { }
        virtual ~_tempuri__ItemsAdd() { }
        /// Friend allocator used by soap_new__tempuri__ItemsAdd(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__ItemsAdd * SOAP_FMAC2 soap_instantiate__tempuri__ItemsAdd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:202 */
#ifndef SOAP_TYPE__tempuri__ItemsAddResponse
#define SOAP_TYPE__tempuri__ItemsAddResponse (28)
/* complex XSD type 'tempuri:ItemsAddResponse': */
class SOAP_CMAC _tempuri__ItemsAddResponse {
      public:
        /// Optional element 'tempuri:ItemsAddResult' of XSD type 'xsd:string'
        char *ItemsAddResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__ItemsAddResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__ItemsAddResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__ItemsAddResponse, default initialized and not managed by a soap context
        virtual _tempuri__ItemsAddResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__ItemsAddResponse); }
      public:
        /// Constructor with initializations
        _tempuri__ItemsAddResponse() : ItemsAddResult(), soap() { }
        virtual ~_tempuri__ItemsAddResponse() { }
        /// Friend allocator used by soap_new__tempuri__ItemsAddResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__ItemsAddResponse * SOAP_FMAC2 soap_instantiate__tempuri__ItemsAddResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:205 */
#ifndef SOAP_TYPE__tempuri__DocAdd
#define SOAP_TYPE__tempuri__DocAdd (29)
/* complex XSD type 'tempuri:DocAdd': */
class SOAP_CMAC _tempuri__DocAdd {
      public:
        /// Optional element 'tempuri:DocTypeCode' of XSD type 'xsd:string'
        char *DocTypeCode;
        /// Optional element 'tempuri:DocXmlMaster' of XSD type 'xsd:string'
        char *DocXmlMaster;
        /// Optional element 'tempuri:DocXmlItems' of XSD type 'xsd:string'
        char *DocXmlItems;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__DocAdd
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__DocAdd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__DocAdd, default initialized and not managed by a soap context
        virtual _tempuri__DocAdd *soap_alloc(void) const { return SOAP_NEW(_tempuri__DocAdd); }
      public:
        /// Constructor with initializations
        _tempuri__DocAdd() : DocTypeCode(), DocXmlMaster(), DocXmlItems(), soap() { }
        virtual ~_tempuri__DocAdd() { }
        /// Friend allocator used by soap_new__tempuri__DocAdd(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__DocAdd * SOAP_FMAC2 soap_instantiate__tempuri__DocAdd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:208 */
#ifndef SOAP_TYPE__tempuri__DocAddResponse
#define SOAP_TYPE__tempuri__DocAddResponse (30)
/* complex XSD type 'tempuri:DocAddResponse': */
class SOAP_CMAC _tempuri__DocAddResponse {
      public:
        /// Optional element 'tempuri:DocAddResult' of XSD type 'xsd:string'
        char *DocAddResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__DocAddResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__DocAddResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__DocAddResponse, default initialized and not managed by a soap context
        virtual _tempuri__DocAddResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__DocAddResponse); }
      public:
        /// Constructor with initializations
        _tempuri__DocAddResponse() : DocAddResult(), soap() { }
        virtual ~_tempuri__DocAddResponse() { }
        /// Friend allocator used by soap_new__tempuri__DocAddResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__DocAddResponse * SOAP_FMAC2 soap_instantiate__tempuri__DocAddResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:211 */
#ifndef SOAP_TYPE__tempuri__SetExMail
#define SOAP_TYPE__tempuri__SetExMail (31)
/* complex XSD type 'tempuri:SetExMail': */
class SOAP_CMAC _tempuri__SetExMail {
      public:
        /// Optional element 'tempuri:to' of XSD type 'xsd:string'
        char *to;
        /// Optional element 'tempuri:title' of XSD type 'xsd:string'
        char *title;
        /// Optional element 'tempuri:body' of XSD type 'xsd:string'
        char *body;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__SetExMail
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__SetExMail; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__SetExMail, default initialized and not managed by a soap context
        virtual _tempuri__SetExMail *soap_alloc(void) const { return SOAP_NEW(_tempuri__SetExMail); }
      public:
        /// Constructor with initializations
        _tempuri__SetExMail() : to(), title(), body(), soap() { }
        virtual ~_tempuri__SetExMail() { }
        /// Friend allocator used by soap_new__tempuri__SetExMail(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__SetExMail * SOAP_FMAC2 soap_instantiate__tempuri__SetExMail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:214 */
#ifndef SOAP_TYPE__tempuri__SetExMailResponse
#define SOAP_TYPE__tempuri__SetExMailResponse (32)
/* complex XSD type 'tempuri:SetExMailResponse': */
class SOAP_CMAC _tempuri__SetExMailResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__SetExMailResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__SetExMailResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__SetExMailResponse, default initialized and not managed by a soap context
        virtual _tempuri__SetExMailResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__SetExMailResponse); }
      public:
        /// Constructor with initializations
        _tempuri__SetExMailResponse() : soap() { }
        virtual ~_tempuri__SetExMailResponse() { }
        /// Friend allocator used by soap_new__tempuri__SetExMailResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__SetExMailResponse * SOAP_FMAC2 soap_instantiate__tempuri__SetExMailResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:217 */
#ifndef SOAP_TYPE__tempuri__GetDept
#define SOAP_TYPE__tempuri__GetDept (33)
/* complex XSD type 'tempuri:GetDept': */
class SOAP_CMAC _tempuri__GetDept {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetDept
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__GetDept; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetDept, default initialized and not managed by a soap context
        virtual _tempuri__GetDept *soap_alloc(void) const { return SOAP_NEW(_tempuri__GetDept); }
      public:
        /// Constructor with initializations
        _tempuri__GetDept() : soap() { }
        virtual ~_tempuri__GetDept() { }
        /// Friend allocator used by soap_new__tempuri__GetDept(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetDept * SOAP_FMAC2 soap_instantiate__tempuri__GetDept(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:220 */
#ifndef SOAP_TYPE__tempuri__GetDeptResponse
#define SOAP_TYPE__tempuri__GetDeptResponse (34)
/* complex XSD type 'tempuri:GetDeptResponse': */
class SOAP_CMAC _tempuri__GetDeptResponse {
      public:
        /// Optional element 'tempuri:GetDeptResult' of XSD type 'xsd:string'
        char *GetDeptResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetDeptResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__GetDeptResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetDeptResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetDeptResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__GetDeptResponse); }
      public:
        /// Constructor with initializations
        _tempuri__GetDeptResponse() : GetDeptResult(), soap() { }
        virtual ~_tempuri__GetDeptResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetDeptResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetDeptResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetDeptResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:223 */
#ifndef SOAP_TYPE__tempuri__GetPower
#define SOAP_TYPE__tempuri__GetPower (35)
/* complex XSD type 'tempuri:GetPower': */
class SOAP_CMAC _tempuri__GetPower {
      public:
        /// Optional element 'tempuri:DeptID' of XSD type 'xsd:string'
        char *DeptID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetPower
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__GetPower; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetPower, default initialized and not managed by a soap context
        virtual _tempuri__GetPower *soap_alloc(void) const { return SOAP_NEW(_tempuri__GetPower); }
      public:
        /// Constructor with initializations
        _tempuri__GetPower() : DeptID(), soap() { }
        virtual ~_tempuri__GetPower() { }
        /// Friend allocator used by soap_new__tempuri__GetPower(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetPower * SOAP_FMAC2 soap_instantiate__tempuri__GetPower(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:226 */
#ifndef SOAP_TYPE__tempuri__GetPowerResponse
#define SOAP_TYPE__tempuri__GetPowerResponse (36)
/* complex XSD type 'tempuri:GetPowerResponse': */
class SOAP_CMAC _tempuri__GetPowerResponse {
      public:
        /// Optional element 'tempuri:GetPowerResult' of XSD type 'xsd:string'
        char *GetPowerResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__GetPowerResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__GetPowerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__GetPowerResponse, default initialized and not managed by a soap context
        virtual _tempuri__GetPowerResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__GetPowerResponse); }
      public:
        /// Constructor with initializations
        _tempuri__GetPowerResponse() : GetPowerResult(), soap() { }
        virtual ~_tempuri__GetPowerResponse() { }
        /// Friend allocator used by soap_new__tempuri__GetPowerResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__GetPowerResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetPowerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:229 */
#ifndef SOAP_TYPE__tempuri__Login
#define SOAP_TYPE__tempuri__Login (37)
/* complex XSD type 'tempuri:Login': */
class SOAP_CMAC _tempuri__Login {
      public:
        /// Optional element 'tempuri:Role' of XSD type 'xsd:string'
        char *Role;
        /// Optional element 'tempuri:UserName' of XSD type 'xsd:string'
        char *UserName;
        /// Optional element 'tempuri:UserPwd' of XSD type 'xsd:string'
        char *UserPwd;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__Login
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__Login; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__Login, default initialized and not managed by a soap context
        virtual _tempuri__Login *soap_alloc(void) const { return SOAP_NEW(_tempuri__Login); }
      public:
        /// Constructor with initializations
        _tempuri__Login() : Role(), UserName(), UserPwd(), soap() { }
        virtual ~_tempuri__Login() { }
        /// Friend allocator used by soap_new__tempuri__Login(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__Login * SOAP_FMAC2 soap_instantiate__tempuri__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:232 */
#ifndef SOAP_TYPE__tempuri__LoginResponse
#define SOAP_TYPE__tempuri__LoginResponse (38)
/* complex XSD type 'tempuri:LoginResponse': */
class SOAP_CMAC _tempuri__LoginResponse {
      public:
        /// Optional element 'tempuri:LoginResult' of XSD type 'xsd:string'
        char *LoginResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LoginResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__LoginResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LoginResponse, default initialized and not managed by a soap context
        virtual _tempuri__LoginResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__LoginResponse); }
      public:
        /// Constructor with initializations
        _tempuri__LoginResponse() : LoginResult(), soap() { }
        virtual ~_tempuri__LoginResponse() { }
        /// Friend allocator used by soap_new__tempuri__LoginResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LoginResponse * SOAP_FMAC2 soap_instantiate__tempuri__LoginResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1153 */
#ifndef SOAP_TYPE___tempuri__GetDate
#define SOAP_TYPE___tempuri__GetDate (43)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetDate {
      public:
        /** Optional element 'tempuri:GetDate' of XSD type 'tempuri:GetDate' */
        _tempuri__GetDate *tempuri__GetDate;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetDate */
        int soap_type() const { return SOAP_TYPE___tempuri__GetDate; }
        /** Constructor with member initializations */
        __tempuri__GetDate() : tempuri__GetDate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetDate * SOAP_FMAC2 soap_instantiate___tempuri__GetDate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1223 */
#ifndef SOAP_TYPE___tempuri__GetDocCode
#define SOAP_TYPE___tempuri__GetDocCode (47)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetDocCode {
      public:
        /** Optional element 'tempuri:GetDocCode' of XSD type 'tempuri:GetDocCode' */
        _tempuri__GetDocCode *tempuri__GetDocCode;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetDocCode */
        int soap_type() const { return SOAP_TYPE___tempuri__GetDocCode; }
        /** Constructor with member initializations */
        __tempuri__GetDocCode() : tempuri__GetDocCode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetDocCode * SOAP_FMAC2 soap_instantiate___tempuri__GetDocCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1293 */
#ifndef SOAP_TYPE___tempuri__ToolingTimes
#define SOAP_TYPE___tempuri__ToolingTimes (51)
/* Wrapper: */
struct SOAP_CMAC __tempuri__ToolingTimes {
      public:
        /** Optional element 'tempuri:ToolingTimes' of XSD type 'tempuri:ToolingTimes' */
        _tempuri__ToolingTimes *tempuri__ToolingTimes;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__ToolingTimes */
        int soap_type() const { return SOAP_TYPE___tempuri__ToolingTimes; }
        /** Constructor with member initializations */
        __tempuri__ToolingTimes() : tempuri__ToolingTimes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__ToolingTimes * SOAP_FMAC2 soap_instantiate___tempuri__ToolingTimes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1363 */
#ifndef SOAP_TYPE___tempuri__WorkOrder
#define SOAP_TYPE___tempuri__WorkOrder (55)
/* Wrapper: */
struct SOAP_CMAC __tempuri__WorkOrder {
      public:
        /** Optional element 'tempuri:WorkOrder' of XSD type 'tempuri:WorkOrder' */
        _tempuri__WorkOrder *tempuri__WorkOrder;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__WorkOrder */
        int soap_type() const { return SOAP_TYPE___tempuri__WorkOrder; }
        /** Constructor with member initializations */
        __tempuri__WorkOrder() : tempuri__WorkOrder() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__WorkOrder * SOAP_FMAC2 soap_instantiate___tempuri__WorkOrder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1433 */
#ifndef SOAP_TYPE___tempuri__LineInventory
#define SOAP_TYPE___tempuri__LineInventory (59)
/* Wrapper: */
struct SOAP_CMAC __tempuri__LineInventory {
      public:
        /** Optional element 'tempuri:LineInventory' of XSD type 'tempuri:LineInventory' */
        _tempuri__LineInventory *tempuri__LineInventory;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__LineInventory */
        int soap_type() const { return SOAP_TYPE___tempuri__LineInventory; }
        /** Constructor with member initializations */
        __tempuri__LineInventory() : tempuri__LineInventory() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__LineInventory * SOAP_FMAC2 soap_instantiate___tempuri__LineInventory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1503 */
#ifndef SOAP_TYPE___tempuri__LineInventoryUpdate
#define SOAP_TYPE___tempuri__LineInventoryUpdate (63)
/* Wrapper: */
struct SOAP_CMAC __tempuri__LineInventoryUpdate {
      public:
        /** Optional element 'tempuri:LineInventoryUpdate' of XSD type 'tempuri:LineInventoryUpdate' */
        _tempuri__LineInventoryUpdate *tempuri__LineInventoryUpdate;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__LineInventoryUpdate */
        int soap_type() const { return SOAP_TYPE___tempuri__LineInventoryUpdate; }
        /** Constructor with member initializations */
        __tempuri__LineInventoryUpdate() : tempuri__LineInventoryUpdate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__LineInventoryUpdate * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryUpdate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1573 */
#ifndef SOAP_TYPE___tempuri__LineInventoryReturn
#define SOAP_TYPE___tempuri__LineInventoryReturn (67)
/* Wrapper: */
struct SOAP_CMAC __tempuri__LineInventoryReturn {
      public:
        /** Optional element 'tempuri:LineInventoryReturn' of XSD type 'tempuri:LineInventoryReturn' */
        _tempuri__LineInventoryReturn *tempuri__LineInventoryReturn;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__LineInventoryReturn */
        int soap_type() const { return SOAP_TYPE___tempuri__LineInventoryReturn; }
        /** Constructor with member initializations */
        __tempuri__LineInventoryReturn() : tempuri__LineInventoryReturn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__LineInventoryReturn * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryReturn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1643 */
#ifndef SOAP_TYPE___tempuri__AnDon
#define SOAP_TYPE___tempuri__AnDon (71)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDon {
      public:
        /** Optional element 'tempuri:AnDon' of XSD type 'tempuri:AnDon' */
        _tempuri__AnDon *tempuri__AnDon;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDon */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDon; }
        /** Constructor with member initializations */
        __tempuri__AnDon() : tempuri__AnDon() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDon * SOAP_FMAC2 soap_instantiate___tempuri__AnDon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1713 */
#ifndef SOAP_TYPE___tempuri__AnDonCall
#define SOAP_TYPE___tempuri__AnDonCall (75)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDonCall {
      public:
        /** Optional element 'tempuri:AnDonCall' of XSD type 'tempuri:AnDonCall' */
        _tempuri__AnDonCall *tempuri__AnDonCall;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDonCall */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDonCall; }
        /** Constructor with member initializations */
        __tempuri__AnDonCall() : tempuri__AnDonCall() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDonCall * SOAP_FMAC2 soap_instantiate___tempuri__AnDonCall(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1783 */
#ifndef SOAP_TYPE___tempuri__AnDonTest
#define SOAP_TYPE___tempuri__AnDonTest (79)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDonTest {
      public:
        /** Optional element 'tempuri:AnDonTest' of XSD type 'tempuri:AnDonTest' */
        _tempuri__AnDonTest *tempuri__AnDonTest;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDonTest */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDonTest; }
        /** Constructor with member initializations */
        __tempuri__AnDonTest() : tempuri__AnDonTest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDonTest * SOAP_FMAC2 soap_instantiate___tempuri__AnDonTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1853 */
#ifndef SOAP_TYPE___tempuri__ItemsAdd
#define SOAP_TYPE___tempuri__ItemsAdd (83)
/* Wrapper: */
struct SOAP_CMAC __tempuri__ItemsAdd {
      public:
        /** Optional element 'tempuri:ItemsAdd' of XSD type 'tempuri:ItemsAdd' */
        _tempuri__ItemsAdd *tempuri__ItemsAdd;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__ItemsAdd */
        int soap_type() const { return SOAP_TYPE___tempuri__ItemsAdd; }
        /** Constructor with member initializations */
        __tempuri__ItemsAdd() : tempuri__ItemsAdd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__ItemsAdd * SOAP_FMAC2 soap_instantiate___tempuri__ItemsAdd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1923 */
#ifndef SOAP_TYPE___tempuri__DocAdd
#define SOAP_TYPE___tempuri__DocAdd (87)
/* Wrapper: */
struct SOAP_CMAC __tempuri__DocAdd {
      public:
        /** Optional element 'tempuri:DocAdd' of XSD type 'tempuri:DocAdd' */
        _tempuri__DocAdd *tempuri__DocAdd;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__DocAdd */
        int soap_type() const { return SOAP_TYPE___tempuri__DocAdd; }
        /** Constructor with member initializations */
        __tempuri__DocAdd() : tempuri__DocAdd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__DocAdd * SOAP_FMAC2 soap_instantiate___tempuri__DocAdd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:1993 */
#ifndef SOAP_TYPE___tempuri__SetExMail
#define SOAP_TYPE___tempuri__SetExMail (91)
/* Wrapper: */
struct SOAP_CMAC __tempuri__SetExMail {
      public:
        /** Optional element 'tempuri:SetExMail' of XSD type 'tempuri:SetExMail' */
        _tempuri__SetExMail *tempuri__SetExMail;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__SetExMail */
        int soap_type() const { return SOAP_TYPE___tempuri__SetExMail; }
        /** Constructor with member initializations */
        __tempuri__SetExMail() : tempuri__SetExMail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__SetExMail * SOAP_FMAC2 soap_instantiate___tempuri__SetExMail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2063 */
#ifndef SOAP_TYPE___tempuri__GetDept
#define SOAP_TYPE___tempuri__GetDept (95)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetDept {
      public:
        /** Optional element 'tempuri:GetDept' of XSD type 'tempuri:GetDept' */
        _tempuri__GetDept *tempuri__GetDept;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetDept */
        int soap_type() const { return SOAP_TYPE___tempuri__GetDept; }
        /** Constructor with member initializations */
        __tempuri__GetDept() : tempuri__GetDept() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetDept * SOAP_FMAC2 soap_instantiate___tempuri__GetDept(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2133 */
#ifndef SOAP_TYPE___tempuri__GetPower
#define SOAP_TYPE___tempuri__GetPower (99)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetPower {
      public:
        /** Optional element 'tempuri:GetPower' of XSD type 'tempuri:GetPower' */
        _tempuri__GetPower *tempuri__GetPower;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetPower */
        int soap_type() const { return SOAP_TYPE___tempuri__GetPower; }
        /** Constructor with member initializations */
        __tempuri__GetPower() : tempuri__GetPower() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetPower * SOAP_FMAC2 soap_instantiate___tempuri__GetPower(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2203 */
#ifndef SOAP_TYPE___tempuri__Login
#define SOAP_TYPE___tempuri__Login (103)
/* Wrapper: */
struct SOAP_CMAC __tempuri__Login {
      public:
        /** Optional element 'tempuri:Login' of XSD type 'tempuri:Login' */
        _tempuri__Login *tempuri__Login;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__Login */
        int soap_type() const { return SOAP_TYPE___tempuri__Login; }
        /** Constructor with member initializations */
        __tempuri__Login() : tempuri__Login() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__Login * SOAP_FMAC2 soap_instantiate___tempuri__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2273 */
#ifndef SOAP_TYPE___tempuri__GetDate_
#define SOAP_TYPE___tempuri__GetDate_ (105)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetDate_ {
      public:
        /** Optional element 'tempuri:GetDate' of XSD type 'tempuri:GetDate' */
        _tempuri__GetDate *tempuri__GetDate;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetDate_ */
        int soap_type() const { return SOAP_TYPE___tempuri__GetDate_; }
        /** Constructor with member initializations */
        __tempuri__GetDate_() : tempuri__GetDate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetDate_ * SOAP_FMAC2 soap_instantiate___tempuri__GetDate_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2343 */
#ifndef SOAP_TYPE___tempuri__GetDocCode_
#define SOAP_TYPE___tempuri__GetDocCode_ (107)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetDocCode_ {
      public:
        /** Optional element 'tempuri:GetDocCode' of XSD type 'tempuri:GetDocCode' */
        _tempuri__GetDocCode *tempuri__GetDocCode;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetDocCode_ */
        int soap_type() const { return SOAP_TYPE___tempuri__GetDocCode_; }
        /** Constructor with member initializations */
        __tempuri__GetDocCode_() : tempuri__GetDocCode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetDocCode_ * SOAP_FMAC2 soap_instantiate___tempuri__GetDocCode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2413 */
#ifndef SOAP_TYPE___tempuri__ToolingTimes_
#define SOAP_TYPE___tempuri__ToolingTimes_ (109)
/* Wrapper: */
struct SOAP_CMAC __tempuri__ToolingTimes_ {
      public:
        /** Optional element 'tempuri:ToolingTimes' of XSD type 'tempuri:ToolingTimes' */
        _tempuri__ToolingTimes *tempuri__ToolingTimes;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__ToolingTimes_ */
        int soap_type() const { return SOAP_TYPE___tempuri__ToolingTimes_; }
        /** Constructor with member initializations */
        __tempuri__ToolingTimes_() : tempuri__ToolingTimes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__ToolingTimes_ * SOAP_FMAC2 soap_instantiate___tempuri__ToolingTimes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2483 */
#ifndef SOAP_TYPE___tempuri__WorkOrder_
#define SOAP_TYPE___tempuri__WorkOrder_ (111)
/* Wrapper: */
struct SOAP_CMAC __tempuri__WorkOrder_ {
      public:
        /** Optional element 'tempuri:WorkOrder' of XSD type 'tempuri:WorkOrder' */
        _tempuri__WorkOrder *tempuri__WorkOrder;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__WorkOrder_ */
        int soap_type() const { return SOAP_TYPE___tempuri__WorkOrder_; }
        /** Constructor with member initializations */
        __tempuri__WorkOrder_() : tempuri__WorkOrder() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__WorkOrder_ * SOAP_FMAC2 soap_instantiate___tempuri__WorkOrder_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2553 */
#ifndef SOAP_TYPE___tempuri__LineInventory_
#define SOAP_TYPE___tempuri__LineInventory_ (113)
/* Wrapper: */
struct SOAP_CMAC __tempuri__LineInventory_ {
      public:
        /** Optional element 'tempuri:LineInventory' of XSD type 'tempuri:LineInventory' */
        _tempuri__LineInventory *tempuri__LineInventory;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__LineInventory_ */
        int soap_type() const { return SOAP_TYPE___tempuri__LineInventory_; }
        /** Constructor with member initializations */
        __tempuri__LineInventory_() : tempuri__LineInventory() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__LineInventory_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventory_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2623 */
#ifndef SOAP_TYPE___tempuri__LineInventoryUpdate_
#define SOAP_TYPE___tempuri__LineInventoryUpdate_ (115)
/* Wrapper: */
struct SOAP_CMAC __tempuri__LineInventoryUpdate_ {
      public:
        /** Optional element 'tempuri:LineInventoryUpdate' of XSD type 'tempuri:LineInventoryUpdate' */
        _tempuri__LineInventoryUpdate *tempuri__LineInventoryUpdate;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__LineInventoryUpdate_ */
        int soap_type() const { return SOAP_TYPE___tempuri__LineInventoryUpdate_; }
        /** Constructor with member initializations */
        __tempuri__LineInventoryUpdate_() : tempuri__LineInventoryUpdate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__LineInventoryUpdate_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryUpdate_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2693 */
#ifndef SOAP_TYPE___tempuri__LineInventoryReturn_
#define SOAP_TYPE___tempuri__LineInventoryReturn_ (117)
/* Wrapper: */
struct SOAP_CMAC __tempuri__LineInventoryReturn_ {
      public:
        /** Optional element 'tempuri:LineInventoryReturn' of XSD type 'tempuri:LineInventoryReturn' */
        _tempuri__LineInventoryReturn *tempuri__LineInventoryReturn;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__LineInventoryReturn_ */
        int soap_type() const { return SOAP_TYPE___tempuri__LineInventoryReturn_; }
        /** Constructor with member initializations */
        __tempuri__LineInventoryReturn_() : tempuri__LineInventoryReturn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__LineInventoryReturn_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryReturn_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2763 */
#ifndef SOAP_TYPE___tempuri__AnDon_
#define SOAP_TYPE___tempuri__AnDon_ (119)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDon_ {
      public:
        /** Optional element 'tempuri:AnDon' of XSD type 'tempuri:AnDon' */
        _tempuri__AnDon *tempuri__AnDon;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDon_ */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDon_; }
        /** Constructor with member initializations */
        __tempuri__AnDon_() : tempuri__AnDon() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDon_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDon_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2833 */
#ifndef SOAP_TYPE___tempuri__AnDonCall_
#define SOAP_TYPE___tempuri__AnDonCall_ (121)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDonCall_ {
      public:
        /** Optional element 'tempuri:AnDonCall' of XSD type 'tempuri:AnDonCall' */
        _tempuri__AnDonCall *tempuri__AnDonCall;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDonCall_ */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDonCall_; }
        /** Constructor with member initializations */
        __tempuri__AnDonCall_() : tempuri__AnDonCall() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDonCall_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDonCall_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2903 */
#ifndef SOAP_TYPE___tempuri__AnDonTest_
#define SOAP_TYPE___tempuri__AnDonTest_ (123)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDonTest_ {
      public:
        /** Optional element 'tempuri:AnDonTest' of XSD type 'tempuri:AnDonTest' */
        _tempuri__AnDonTest *tempuri__AnDonTest;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDonTest_ */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDonTest_; }
        /** Constructor with member initializations */
        __tempuri__AnDonTest_() : tempuri__AnDonTest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDonTest_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDonTest_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:2973 */
#ifndef SOAP_TYPE___tempuri__ItemsAdd_
#define SOAP_TYPE___tempuri__ItemsAdd_ (125)
/* Wrapper: */
struct SOAP_CMAC __tempuri__ItemsAdd_ {
      public:
        /** Optional element 'tempuri:ItemsAdd' of XSD type 'tempuri:ItemsAdd' */
        _tempuri__ItemsAdd *tempuri__ItemsAdd;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__ItemsAdd_ */
        int soap_type() const { return SOAP_TYPE___tempuri__ItemsAdd_; }
        /** Constructor with member initializations */
        __tempuri__ItemsAdd_() : tempuri__ItemsAdd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__ItemsAdd_ * SOAP_FMAC2 soap_instantiate___tempuri__ItemsAdd_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:3043 */
#ifndef SOAP_TYPE___tempuri__DocAdd_
#define SOAP_TYPE___tempuri__DocAdd_ (127)
/* Wrapper: */
struct SOAP_CMAC __tempuri__DocAdd_ {
      public:
        /** Optional element 'tempuri:DocAdd' of XSD type 'tempuri:DocAdd' */
        _tempuri__DocAdd *tempuri__DocAdd;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__DocAdd_ */
        int soap_type() const { return SOAP_TYPE___tempuri__DocAdd_; }
        /** Constructor with member initializations */
        __tempuri__DocAdd_() : tempuri__DocAdd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__DocAdd_ * SOAP_FMAC2 soap_instantiate___tempuri__DocAdd_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:3113 */
#ifndef SOAP_TYPE___tempuri__SetExMail_
#define SOAP_TYPE___tempuri__SetExMail_ (129)
/* Wrapper: */
struct SOAP_CMAC __tempuri__SetExMail_ {
      public:
        /** Optional element 'tempuri:SetExMail' of XSD type 'tempuri:SetExMail' */
        _tempuri__SetExMail *tempuri__SetExMail;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__SetExMail_ */
        int soap_type() const { return SOAP_TYPE___tempuri__SetExMail_; }
        /** Constructor with member initializations */
        __tempuri__SetExMail_() : tempuri__SetExMail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__SetExMail_ * SOAP_FMAC2 soap_instantiate___tempuri__SetExMail_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:3183 */
#ifndef SOAP_TYPE___tempuri__GetDept_
#define SOAP_TYPE___tempuri__GetDept_ (131)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetDept_ {
      public:
        /** Optional element 'tempuri:GetDept' of XSD type 'tempuri:GetDept' */
        _tempuri__GetDept *tempuri__GetDept;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetDept_ */
        int soap_type() const { return SOAP_TYPE___tempuri__GetDept_; }
        /** Constructor with member initializations */
        __tempuri__GetDept_() : tempuri__GetDept() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetDept_ * SOAP_FMAC2 soap_instantiate___tempuri__GetDept_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:3253 */
#ifndef SOAP_TYPE___tempuri__GetPower_
#define SOAP_TYPE___tempuri__GetPower_ (133)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetPower_ {
      public:
        /** Optional element 'tempuri:GetPower' of XSD type 'tempuri:GetPower' */
        _tempuri__GetPower *tempuri__GetPower;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetPower_ */
        int soap_type() const { return SOAP_TYPE___tempuri__GetPower_; }
        /** Constructor with member initializations */
        __tempuri__GetPower_() : tempuri__GetPower() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetPower_ * SOAP_FMAC2 soap_instantiate___tempuri__GetPower_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:3323 */
#ifndef SOAP_TYPE___tempuri__Login_
#define SOAP_TYPE___tempuri__Login_ (135)
/* Wrapper: */
struct SOAP_CMAC __tempuri__Login_ {
      public:
        /** Optional element 'tempuri:Login' of XSD type 'tempuri:Login' */
        _tempuri__Login *tempuri__Login;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__Login_ */
        int soap_type() const { return SOAP_TYPE___tempuri__Login_; }
        /** Constructor with member initializations */
        __tempuri__Login_() : tempuri__Login() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__Login_ * SOAP_FMAC2 soap_instantiate___tempuri__Login_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESService.h:3866 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (136)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MESService.h:3866 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (137)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MESService.h:3866 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (139)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MESService.h:3866 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (142)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MESService.h:3866 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (143)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* MESService.h:120 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* MESService.h:120 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* _tempuri__LoginResponse has binding name '_tempuri__LoginResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__LoginResponse
#define SOAP_TYPE__tempuri__LoginResponse (38)
#endif

/* _tempuri__Login has binding name '_tempuri__Login' for type '' */
#ifndef SOAP_TYPE__tempuri__Login
#define SOAP_TYPE__tempuri__Login (37)
#endif

/* _tempuri__GetPowerResponse has binding name '_tempuri__GetPowerResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetPowerResponse
#define SOAP_TYPE__tempuri__GetPowerResponse (36)
#endif

/* _tempuri__GetPower has binding name '_tempuri__GetPower' for type '' */
#ifndef SOAP_TYPE__tempuri__GetPower
#define SOAP_TYPE__tempuri__GetPower (35)
#endif

/* _tempuri__GetDeptResponse has binding name '_tempuri__GetDeptResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetDeptResponse
#define SOAP_TYPE__tempuri__GetDeptResponse (34)
#endif

/* _tempuri__GetDept has binding name '_tempuri__GetDept' for type '' */
#ifndef SOAP_TYPE__tempuri__GetDept
#define SOAP_TYPE__tempuri__GetDept (33)
#endif

/* _tempuri__SetExMailResponse has binding name '_tempuri__SetExMailResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__SetExMailResponse
#define SOAP_TYPE__tempuri__SetExMailResponse (32)
#endif

/* _tempuri__SetExMail has binding name '_tempuri__SetExMail' for type '' */
#ifndef SOAP_TYPE__tempuri__SetExMail
#define SOAP_TYPE__tempuri__SetExMail (31)
#endif

/* _tempuri__DocAddResponse has binding name '_tempuri__DocAddResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__DocAddResponse
#define SOAP_TYPE__tempuri__DocAddResponse (30)
#endif

/* _tempuri__DocAdd has binding name '_tempuri__DocAdd' for type '' */
#ifndef SOAP_TYPE__tempuri__DocAdd
#define SOAP_TYPE__tempuri__DocAdd (29)
#endif

/* _tempuri__ItemsAddResponse has binding name '_tempuri__ItemsAddResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__ItemsAddResponse
#define SOAP_TYPE__tempuri__ItemsAddResponse (28)
#endif

/* _tempuri__ItemsAdd has binding name '_tempuri__ItemsAdd' for type '' */
#ifndef SOAP_TYPE__tempuri__ItemsAdd
#define SOAP_TYPE__tempuri__ItemsAdd (27)
#endif

/* _tempuri__AnDonTestResponse has binding name '_tempuri__AnDonTestResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonTestResponse
#define SOAP_TYPE__tempuri__AnDonTestResponse (26)
#endif

/* _tempuri__AnDonTest has binding name '_tempuri__AnDonTest' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonTest
#define SOAP_TYPE__tempuri__AnDonTest (25)
#endif

/* _tempuri__AnDonCallResponse has binding name '_tempuri__AnDonCallResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonCallResponse
#define SOAP_TYPE__tempuri__AnDonCallResponse (24)
#endif

/* _tempuri__AnDonCall has binding name '_tempuri__AnDonCall' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonCall
#define SOAP_TYPE__tempuri__AnDonCall (23)
#endif

/* _tempuri__AnDonResponse has binding name '_tempuri__AnDonResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonResponse
#define SOAP_TYPE__tempuri__AnDonResponse (22)
#endif

/* _tempuri__AnDon has binding name '_tempuri__AnDon' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDon
#define SOAP_TYPE__tempuri__AnDon (21)
#endif

/* _tempuri__LineInventoryReturnResponse has binding name '_tempuri__LineInventoryReturnResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__LineInventoryReturnResponse
#define SOAP_TYPE__tempuri__LineInventoryReturnResponse (20)
#endif

/* _tempuri__LineInventoryReturn has binding name '_tempuri__LineInventoryReturn' for type '' */
#ifndef SOAP_TYPE__tempuri__LineInventoryReturn
#define SOAP_TYPE__tempuri__LineInventoryReturn (19)
#endif

/* _tempuri__LineInventoryUpdateResponse has binding name '_tempuri__LineInventoryUpdateResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__LineInventoryUpdateResponse
#define SOAP_TYPE__tempuri__LineInventoryUpdateResponse (18)
#endif

/* _tempuri__LineInventoryUpdate has binding name '_tempuri__LineInventoryUpdate' for type '' */
#ifndef SOAP_TYPE__tempuri__LineInventoryUpdate
#define SOAP_TYPE__tempuri__LineInventoryUpdate (17)
#endif

/* _tempuri__LineInventoryResponse has binding name '_tempuri__LineInventoryResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__LineInventoryResponse
#define SOAP_TYPE__tempuri__LineInventoryResponse (16)
#endif

/* _tempuri__LineInventory has binding name '_tempuri__LineInventory' for type '' */
#ifndef SOAP_TYPE__tempuri__LineInventory
#define SOAP_TYPE__tempuri__LineInventory (15)
#endif

/* _tempuri__WorkOrderResponse has binding name '_tempuri__WorkOrderResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__WorkOrderResponse
#define SOAP_TYPE__tempuri__WorkOrderResponse (14)
#endif

/* _tempuri__WorkOrder has binding name '_tempuri__WorkOrder' for type '' */
#ifndef SOAP_TYPE__tempuri__WorkOrder
#define SOAP_TYPE__tempuri__WorkOrder (13)
#endif

/* _tempuri__ToolingTimesResponse has binding name '_tempuri__ToolingTimesResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__ToolingTimesResponse
#define SOAP_TYPE__tempuri__ToolingTimesResponse (12)
#endif

/* _tempuri__ToolingTimes has binding name '_tempuri__ToolingTimes' for type '' */
#ifndef SOAP_TYPE__tempuri__ToolingTimes
#define SOAP_TYPE__tempuri__ToolingTimes (11)
#endif

/* _tempuri__GetDocCodeResponse has binding name '_tempuri__GetDocCodeResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetDocCodeResponse
#define SOAP_TYPE__tempuri__GetDocCodeResponse (10)
#endif

/* _tempuri__GetDocCode has binding name '_tempuri__GetDocCode' for type '' */
#ifndef SOAP_TYPE__tempuri__GetDocCode
#define SOAP_TYPE__tempuri__GetDocCode (9)
#endif

/* _tempuri__GetDateResponse has binding name '_tempuri__GetDateResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__GetDateResponse
#define SOAP_TYPE__tempuri__GetDateResponse (8)
#endif

/* _tempuri__GetDate has binding name '_tempuri__GetDate' for type '' */
#ifndef SOAP_TYPE__tempuri__GetDate
#define SOAP_TYPE__tempuri__GetDate (7)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (143)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (142)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (139)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (137)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (136)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (145)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (144)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (138)
#endif

/* _tempuri__Login * has binding name 'PointerTo_tempuri__Login' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__Login
#define SOAP_TYPE_PointerTo_tempuri__Login (100)
#endif

/* _tempuri__GetPower * has binding name 'PointerTo_tempuri__GetPower' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetPower
#define SOAP_TYPE_PointerTo_tempuri__GetPower (96)
#endif

/* _tempuri__GetDept * has binding name 'PointerTo_tempuri__GetDept' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetDept
#define SOAP_TYPE_PointerTo_tempuri__GetDept (92)
#endif

/* _tempuri__SetExMail * has binding name 'PointerTo_tempuri__SetExMail' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__SetExMail
#define SOAP_TYPE_PointerTo_tempuri__SetExMail (88)
#endif

/* _tempuri__DocAdd * has binding name 'PointerTo_tempuri__DocAdd' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__DocAdd
#define SOAP_TYPE_PointerTo_tempuri__DocAdd (84)
#endif

/* _tempuri__ItemsAdd * has binding name 'PointerTo_tempuri__ItemsAdd' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__ItemsAdd
#define SOAP_TYPE_PointerTo_tempuri__ItemsAdd (80)
#endif

/* _tempuri__AnDonTest * has binding name 'PointerTo_tempuri__AnDonTest' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__AnDonTest
#define SOAP_TYPE_PointerTo_tempuri__AnDonTest (76)
#endif

/* _tempuri__AnDonCall * has binding name 'PointerTo_tempuri__AnDonCall' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__AnDonCall
#define SOAP_TYPE_PointerTo_tempuri__AnDonCall (72)
#endif

/* _tempuri__AnDon * has binding name 'PointerTo_tempuri__AnDon' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__AnDon
#define SOAP_TYPE_PointerTo_tempuri__AnDon (68)
#endif

/* _tempuri__LineInventoryReturn * has binding name 'PointerTo_tempuri__LineInventoryReturn' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__LineInventoryReturn
#define SOAP_TYPE_PointerTo_tempuri__LineInventoryReturn (64)
#endif

/* _tempuri__LineInventoryUpdate * has binding name 'PointerTo_tempuri__LineInventoryUpdate' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__LineInventoryUpdate
#define SOAP_TYPE_PointerTo_tempuri__LineInventoryUpdate (60)
#endif

/* _tempuri__LineInventory * has binding name 'PointerTo_tempuri__LineInventory' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__LineInventory
#define SOAP_TYPE_PointerTo_tempuri__LineInventory (56)
#endif

/* _tempuri__WorkOrder * has binding name 'PointerTo_tempuri__WorkOrder' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__WorkOrder
#define SOAP_TYPE_PointerTo_tempuri__WorkOrder (52)
#endif

/* _tempuri__ToolingTimes * has binding name 'PointerTo_tempuri__ToolingTimes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__ToolingTimes
#define SOAP_TYPE_PointerTo_tempuri__ToolingTimes (48)
#endif

/* _tempuri__GetDocCode * has binding name 'PointerTo_tempuri__GetDocCode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetDocCode
#define SOAP_TYPE_PointerTo_tempuri__GetDocCode (44)
#endif

/* _tempuri__GetDate * has binding name 'PointerTo_tempuri__GetDate' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__GetDate
#define SOAP_TYPE_PointerTo_tempuri__GetDate (40)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */

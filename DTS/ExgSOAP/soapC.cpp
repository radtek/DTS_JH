/* soapC.cpp
   Generated by gSOAP 2.8.51 for MESService.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.51 2018-01-10 03:42:15 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTo_tempuri__Login:
		return soap_in_PointerTo_tempuri__Login(soap, NULL, NULL, "tempuri:Login");
	case SOAP_TYPE_PointerTo_tempuri__GetPower:
		return soap_in_PointerTo_tempuri__GetPower(soap, NULL, NULL, "tempuri:GetPower");
	case SOAP_TYPE_PointerTo_tempuri__GetDept:
		return soap_in_PointerTo_tempuri__GetDept(soap, NULL, NULL, "tempuri:GetDept");
	case SOAP_TYPE_PointerTo_tempuri__SetExMail:
		return soap_in_PointerTo_tempuri__SetExMail(soap, NULL, NULL, "tempuri:SetExMail");
	case SOAP_TYPE_PointerTo_tempuri__DocAdd:
		return soap_in_PointerTo_tempuri__DocAdd(soap, NULL, NULL, "tempuri:DocAdd");
	case SOAP_TYPE_PointerTo_tempuri__ItemsAdd:
		return soap_in_PointerTo_tempuri__ItemsAdd(soap, NULL, NULL, "tempuri:ItemsAdd");
	case SOAP_TYPE_PointerTo_tempuri__AnDonTest:
		return soap_in_PointerTo_tempuri__AnDonTest(soap, NULL, NULL, "tempuri:AnDonTest");
	case SOAP_TYPE_PointerTo_tempuri__AnDonCall:
		return soap_in_PointerTo_tempuri__AnDonCall(soap, NULL, NULL, "tempuri:AnDonCall");
	case SOAP_TYPE_PointerTo_tempuri__AnDon:
		return soap_in_PointerTo_tempuri__AnDon(soap, NULL, NULL, "tempuri:AnDon");
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryReturn:
		return soap_in_PointerTo_tempuri__LineInventoryReturn(soap, NULL, NULL, "tempuri:LineInventoryReturn");
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryUpdate:
		return soap_in_PointerTo_tempuri__LineInventoryUpdate(soap, NULL, NULL, "tempuri:LineInventoryUpdate");
	case SOAP_TYPE_PointerTo_tempuri__LineInventory:
		return soap_in_PointerTo_tempuri__LineInventory(soap, NULL, NULL, "tempuri:LineInventory");
	case SOAP_TYPE_PointerTo_tempuri__WorkOrder:
		return soap_in_PointerTo_tempuri__WorkOrder(soap, NULL, NULL, "tempuri:WorkOrder");
	case SOAP_TYPE_PointerTo_tempuri__ToolingTimes:
		return soap_in_PointerTo_tempuri__ToolingTimes(soap, NULL, NULL, "tempuri:ToolingTimes");
	case SOAP_TYPE_PointerTo_tempuri__GetDocCode:
		return soap_in_PointerTo_tempuri__GetDocCode(soap, NULL, NULL, "tempuri:GetDocCode");
	case SOAP_TYPE_PointerTo_tempuri__GetDate:
		return soap_in_PointerTo_tempuri__GetDate(soap, NULL, NULL, "tempuri:GetDate");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "tempuri:LoginResponse"))
		{	*type = SOAP_TYPE__tempuri__LoginResponse;
			return soap_in__tempuri__LoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:Login"))
		{	*type = SOAP_TYPE__tempuri__Login;
			return soap_in__tempuri__Login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetPowerResponse"))
		{	*type = SOAP_TYPE__tempuri__GetPowerResponse;
			return soap_in__tempuri__GetPowerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetPower"))
		{	*type = SOAP_TYPE__tempuri__GetPower;
			return soap_in__tempuri__GetPower(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDeptResponse"))
		{	*type = SOAP_TYPE__tempuri__GetDeptResponse;
			return soap_in__tempuri__GetDeptResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDept"))
		{	*type = SOAP_TYPE__tempuri__GetDept;
			return soap_in__tempuri__GetDept(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:SetExMailResponse"))
		{	*type = SOAP_TYPE__tempuri__SetExMailResponse;
			return soap_in__tempuri__SetExMailResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:SetExMail"))
		{	*type = SOAP_TYPE__tempuri__SetExMail;
			return soap_in__tempuri__SetExMail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:DocAddResponse"))
		{	*type = SOAP_TYPE__tempuri__DocAddResponse;
			return soap_in__tempuri__DocAddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:DocAdd"))
		{	*type = SOAP_TYPE__tempuri__DocAdd;
			return soap_in__tempuri__DocAdd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ItemsAddResponse"))
		{	*type = SOAP_TYPE__tempuri__ItemsAddResponse;
			return soap_in__tempuri__ItemsAddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ItemsAdd"))
		{	*type = SOAP_TYPE__tempuri__ItemsAdd;
			return soap_in__tempuri__ItemsAdd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonTestResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDonTestResponse;
			return soap_in__tempuri__AnDonTestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonTest"))
		{	*type = SOAP_TYPE__tempuri__AnDonTest;
			return soap_in__tempuri__AnDonTest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonCallResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDonCallResponse;
			return soap_in__tempuri__AnDonCallResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonCall"))
		{	*type = SOAP_TYPE__tempuri__AnDonCall;
			return soap_in__tempuri__AnDonCall(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDonResponse;
			return soap_in__tempuri__AnDonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDon"))
		{	*type = SOAP_TYPE__tempuri__AnDon;
			return soap_in__tempuri__AnDon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryReturnResponse"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryReturnResponse;
			return soap_in__tempuri__LineInventoryReturnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryReturn"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryReturn;
			return soap_in__tempuri__LineInventoryReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryUpdateResponse"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryUpdateResponse;
			return soap_in__tempuri__LineInventoryUpdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryUpdate"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryUpdate;
			return soap_in__tempuri__LineInventoryUpdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryResponse"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryResponse;
			return soap_in__tempuri__LineInventoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventory"))
		{	*type = SOAP_TYPE__tempuri__LineInventory;
			return soap_in__tempuri__LineInventory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:WorkOrderResponse"))
		{	*type = SOAP_TYPE__tempuri__WorkOrderResponse;
			return soap_in__tempuri__WorkOrderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:WorkOrder"))
		{	*type = SOAP_TYPE__tempuri__WorkOrder;
			return soap_in__tempuri__WorkOrder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ToolingTimesResponse"))
		{	*type = SOAP_TYPE__tempuri__ToolingTimesResponse;
			return soap_in__tempuri__ToolingTimesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ToolingTimes"))
		{	*type = SOAP_TYPE__tempuri__ToolingTimes;
			return soap_in__tempuri__ToolingTimes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDocCodeResponse"))
		{	*type = SOAP_TYPE__tempuri__GetDocCodeResponse;
			return soap_in__tempuri__GetDocCodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDocCode"))
		{	*type = SOAP_TYPE__tempuri__GetDocCode;
			return soap_in__tempuri__GetDocCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDateResponse"))
		{	*type = SOAP_TYPE__tempuri__GetDateResponse;
			return soap_in__tempuri__GetDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDate"))
		{	*type = SOAP_TYPE__tempuri__GetDate;
			return soap_in__tempuri__GetDate(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__tempuri__LoginResponse:
		return ((_tempuri__LoginResponse *)ptr)->soap_out(soap, "tempuri:LoginResponse", id, "");
	case SOAP_TYPE__tempuri__Login:
		return ((_tempuri__Login *)ptr)->soap_out(soap, "tempuri:Login", id, "");
	case SOAP_TYPE__tempuri__GetPowerResponse:
		return ((_tempuri__GetPowerResponse *)ptr)->soap_out(soap, "tempuri:GetPowerResponse", id, "");
	case SOAP_TYPE__tempuri__GetPower:
		return ((_tempuri__GetPower *)ptr)->soap_out(soap, "tempuri:GetPower", id, "");
	case SOAP_TYPE__tempuri__GetDeptResponse:
		return ((_tempuri__GetDeptResponse *)ptr)->soap_out(soap, "tempuri:GetDeptResponse", id, "");
	case SOAP_TYPE__tempuri__GetDept:
		return ((_tempuri__GetDept *)ptr)->soap_out(soap, "tempuri:GetDept", id, "");
	case SOAP_TYPE__tempuri__SetExMailResponse:
		return ((_tempuri__SetExMailResponse *)ptr)->soap_out(soap, "tempuri:SetExMailResponse", id, "");
	case SOAP_TYPE__tempuri__SetExMail:
		return ((_tempuri__SetExMail *)ptr)->soap_out(soap, "tempuri:SetExMail", id, "");
	case SOAP_TYPE__tempuri__DocAddResponse:
		return ((_tempuri__DocAddResponse *)ptr)->soap_out(soap, "tempuri:DocAddResponse", id, "");
	case SOAP_TYPE__tempuri__DocAdd:
		return ((_tempuri__DocAdd *)ptr)->soap_out(soap, "tempuri:DocAdd", id, "");
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		return ((_tempuri__ItemsAddResponse *)ptr)->soap_out(soap, "tempuri:ItemsAddResponse", id, "");
	case SOAP_TYPE__tempuri__ItemsAdd:
		return ((_tempuri__ItemsAdd *)ptr)->soap_out(soap, "tempuri:ItemsAdd", id, "");
	case SOAP_TYPE__tempuri__AnDonTestResponse:
		return ((_tempuri__AnDonTestResponse *)ptr)->soap_out(soap, "tempuri:AnDonTestResponse", id, "");
	case SOAP_TYPE__tempuri__AnDonTest:
		return ((_tempuri__AnDonTest *)ptr)->soap_out(soap, "tempuri:AnDonTest", id, "");
	case SOAP_TYPE__tempuri__AnDonCallResponse:
		return ((_tempuri__AnDonCallResponse *)ptr)->soap_out(soap, "tempuri:AnDonCallResponse", id, "");
	case SOAP_TYPE__tempuri__AnDonCall:
		return ((_tempuri__AnDonCall *)ptr)->soap_out(soap, "tempuri:AnDonCall", id, "");
	case SOAP_TYPE__tempuri__AnDonResponse:
		return ((_tempuri__AnDonResponse *)ptr)->soap_out(soap, "tempuri:AnDonResponse", id, "");
	case SOAP_TYPE__tempuri__AnDon:
		return ((_tempuri__AnDon *)ptr)->soap_out(soap, "tempuri:AnDon", id, "");
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		return ((_tempuri__LineInventoryReturnResponse *)ptr)->soap_out(soap, "tempuri:LineInventoryReturnResponse", id, "");
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		return ((_tempuri__LineInventoryReturn *)ptr)->soap_out(soap, "tempuri:LineInventoryReturn", id, "");
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		return ((_tempuri__LineInventoryUpdateResponse *)ptr)->soap_out(soap, "tempuri:LineInventoryUpdateResponse", id, "");
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		return ((_tempuri__LineInventoryUpdate *)ptr)->soap_out(soap, "tempuri:LineInventoryUpdate", id, "");
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		return ((_tempuri__LineInventoryResponse *)ptr)->soap_out(soap, "tempuri:LineInventoryResponse", id, "");
	case SOAP_TYPE__tempuri__LineInventory:
		return ((_tempuri__LineInventory *)ptr)->soap_out(soap, "tempuri:LineInventory", id, "");
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		return ((_tempuri__WorkOrderResponse *)ptr)->soap_out(soap, "tempuri:WorkOrderResponse", id, "");
	case SOAP_TYPE__tempuri__WorkOrder:
		return ((_tempuri__WorkOrder *)ptr)->soap_out(soap, "tempuri:WorkOrder", id, "");
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		return ((_tempuri__ToolingTimesResponse *)ptr)->soap_out(soap, "tempuri:ToolingTimesResponse", id, "");
	case SOAP_TYPE__tempuri__ToolingTimes:
		return ((_tempuri__ToolingTimes *)ptr)->soap_out(soap, "tempuri:ToolingTimes", id, "");
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		return ((_tempuri__GetDocCodeResponse *)ptr)->soap_out(soap, "tempuri:GetDocCodeResponse", id, "");
	case SOAP_TYPE__tempuri__GetDocCode:
		return ((_tempuri__GetDocCode *)ptr)->soap_out(soap, "tempuri:GetDocCode", id, "");
	case SOAP_TYPE__tempuri__GetDateResponse:
		return ((_tempuri__GetDateResponse *)ptr)->soap_out(soap, "tempuri:GetDateResponse", id, "");
	case SOAP_TYPE__tempuri__GetDate:
		return ((_tempuri__GetDate *)ptr)->soap_out(soap, "tempuri:GetDate", id, "");
	case SOAP_TYPE_PointerTo_tempuri__Login:
		return soap_out_PointerTo_tempuri__Login(soap, tag, id, (_tempuri__Login *const*)ptr, "tempuri:Login");
	case SOAP_TYPE_PointerTo_tempuri__GetPower:
		return soap_out_PointerTo_tempuri__GetPower(soap, tag, id, (_tempuri__GetPower *const*)ptr, "tempuri:GetPower");
	case SOAP_TYPE_PointerTo_tempuri__GetDept:
		return soap_out_PointerTo_tempuri__GetDept(soap, tag, id, (_tempuri__GetDept *const*)ptr, "tempuri:GetDept");
	case SOAP_TYPE_PointerTo_tempuri__SetExMail:
		return soap_out_PointerTo_tempuri__SetExMail(soap, tag, id, (_tempuri__SetExMail *const*)ptr, "tempuri:SetExMail");
	case SOAP_TYPE_PointerTo_tempuri__DocAdd:
		return soap_out_PointerTo_tempuri__DocAdd(soap, tag, id, (_tempuri__DocAdd *const*)ptr, "tempuri:DocAdd");
	case SOAP_TYPE_PointerTo_tempuri__ItemsAdd:
		return soap_out_PointerTo_tempuri__ItemsAdd(soap, tag, id, (_tempuri__ItemsAdd *const*)ptr, "tempuri:ItemsAdd");
	case SOAP_TYPE_PointerTo_tempuri__AnDonTest:
		return soap_out_PointerTo_tempuri__AnDonTest(soap, tag, id, (_tempuri__AnDonTest *const*)ptr, "tempuri:AnDonTest");
	case SOAP_TYPE_PointerTo_tempuri__AnDonCall:
		return soap_out_PointerTo_tempuri__AnDonCall(soap, tag, id, (_tempuri__AnDonCall *const*)ptr, "tempuri:AnDonCall");
	case SOAP_TYPE_PointerTo_tempuri__AnDon:
		return soap_out_PointerTo_tempuri__AnDon(soap, tag, id, (_tempuri__AnDon *const*)ptr, "tempuri:AnDon");
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryReturn:
		return soap_out_PointerTo_tempuri__LineInventoryReturn(soap, tag, id, (_tempuri__LineInventoryReturn *const*)ptr, "tempuri:LineInventoryReturn");
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryUpdate:
		return soap_out_PointerTo_tempuri__LineInventoryUpdate(soap, tag, id, (_tempuri__LineInventoryUpdate *const*)ptr, "tempuri:LineInventoryUpdate");
	case SOAP_TYPE_PointerTo_tempuri__LineInventory:
		return soap_out_PointerTo_tempuri__LineInventory(soap, tag, id, (_tempuri__LineInventory *const*)ptr, "tempuri:LineInventory");
	case SOAP_TYPE_PointerTo_tempuri__WorkOrder:
		return soap_out_PointerTo_tempuri__WorkOrder(soap, tag, id, (_tempuri__WorkOrder *const*)ptr, "tempuri:WorkOrder");
	case SOAP_TYPE_PointerTo_tempuri__ToolingTimes:
		return soap_out_PointerTo_tempuri__ToolingTimes(soap, tag, id, (_tempuri__ToolingTimes *const*)ptr, "tempuri:ToolingTimes");
	case SOAP_TYPE_PointerTo_tempuri__GetDocCode:
		return soap_out_PointerTo_tempuri__GetDocCode(soap, tag, id, (_tempuri__GetDocCode *const*)ptr, "tempuri:GetDocCode");
	case SOAP_TYPE_PointerTo_tempuri__GetDate:
		return soap_out_PointerTo_tempuri__GetDate(soap, tag, id, (_tempuri__GetDate *const*)ptr, "tempuri:GetDate");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__tempuri__LoginResponse:
		((_tempuri__LoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__Login:
		((_tempuri__Login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetPowerResponse:
		((_tempuri__GetPowerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetPower:
		((_tempuri__GetPower *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDeptResponse:
		((_tempuri__GetDeptResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDept:
		((_tempuri__GetDept *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__SetExMailResponse:
		((_tempuri__SetExMailResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__SetExMail:
		((_tempuri__SetExMail *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__DocAddResponse:
		((_tempuri__DocAddResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__DocAdd:
		((_tempuri__DocAdd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		((_tempuri__ItemsAddResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ItemsAdd:
		((_tempuri__ItemsAdd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonTestResponse:
		((_tempuri__AnDonTestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonTest:
		((_tempuri__AnDonTest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonCallResponse:
		((_tempuri__AnDonCallResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonCall:
		((_tempuri__AnDonCall *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonResponse:
		((_tempuri__AnDonResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDon:
		((_tempuri__AnDon *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		((_tempuri__LineInventoryReturnResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		((_tempuri__LineInventoryReturn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		((_tempuri__LineInventoryUpdateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		((_tempuri__LineInventoryUpdate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		((_tempuri__LineInventoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventory:
		((_tempuri__LineInventory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		((_tempuri__WorkOrderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__WorkOrder:
		((_tempuri__WorkOrder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		((_tempuri__ToolingTimesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ToolingTimes:
		((_tempuri__ToolingTimes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		((_tempuri__GetDocCodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDocCode:
		((_tempuri__GetDocCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDateResponse:
		((_tempuri__GetDateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDate:
		((_tempuri__GetDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___tempuri__Login_:
		soap_serialize___tempuri__Login_(soap, (const struct __tempuri__Login_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetPower_:
		soap_serialize___tempuri__GetPower_(soap, (const struct __tempuri__GetPower_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDept_:
		soap_serialize___tempuri__GetDept_(soap, (const struct __tempuri__GetDept_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__SetExMail_:
		soap_serialize___tempuri__SetExMail_(soap, (const struct __tempuri__SetExMail_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__DocAdd_:
		soap_serialize___tempuri__DocAdd_(soap, (const struct __tempuri__DocAdd_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__ItemsAdd_:
		soap_serialize___tempuri__ItemsAdd_(soap, (const struct __tempuri__ItemsAdd_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDonTest_:
		soap_serialize___tempuri__AnDonTest_(soap, (const struct __tempuri__AnDonTest_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDonCall_:
		soap_serialize___tempuri__AnDonCall_(soap, (const struct __tempuri__AnDonCall_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDon_:
		soap_serialize___tempuri__AnDon_(soap, (const struct __tempuri__AnDon_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn_:
		soap_serialize___tempuri__LineInventoryReturn_(soap, (const struct __tempuri__LineInventoryReturn_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate_:
		soap_serialize___tempuri__LineInventoryUpdate_(soap, (const struct __tempuri__LineInventoryUpdate_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventory_:
		soap_serialize___tempuri__LineInventory_(soap, (const struct __tempuri__LineInventory_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__WorkOrder_:
		soap_serialize___tempuri__WorkOrder_(soap, (const struct __tempuri__WorkOrder_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__ToolingTimes_:
		soap_serialize___tempuri__ToolingTimes_(soap, (const struct __tempuri__ToolingTimes_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDocCode_:
		soap_serialize___tempuri__GetDocCode_(soap, (const struct __tempuri__GetDocCode_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDate_:
		soap_serialize___tempuri__GetDate_(soap, (const struct __tempuri__GetDate_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__Login:
		soap_serialize___tempuri__Login(soap, (const struct __tempuri__Login *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetPower:
		soap_serialize___tempuri__GetPower(soap, (const struct __tempuri__GetPower *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDept:
		soap_serialize___tempuri__GetDept(soap, (const struct __tempuri__GetDept *)ptr);
		break;
	case SOAP_TYPE___tempuri__SetExMail:
		soap_serialize___tempuri__SetExMail(soap, (const struct __tempuri__SetExMail *)ptr);
		break;
	case SOAP_TYPE___tempuri__DocAdd:
		soap_serialize___tempuri__DocAdd(soap, (const struct __tempuri__DocAdd *)ptr);
		break;
	case SOAP_TYPE___tempuri__ItemsAdd:
		soap_serialize___tempuri__ItemsAdd(soap, (const struct __tempuri__ItemsAdd *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDonTest:
		soap_serialize___tempuri__AnDonTest(soap, (const struct __tempuri__AnDonTest *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDonCall:
		soap_serialize___tempuri__AnDonCall(soap, (const struct __tempuri__AnDonCall *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDon:
		soap_serialize___tempuri__AnDon(soap, (const struct __tempuri__AnDon *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn:
		soap_serialize___tempuri__LineInventoryReturn(soap, (const struct __tempuri__LineInventoryReturn *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate:
		soap_serialize___tempuri__LineInventoryUpdate(soap, (const struct __tempuri__LineInventoryUpdate *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventory:
		soap_serialize___tempuri__LineInventory(soap, (const struct __tempuri__LineInventory *)ptr);
		break;
	case SOAP_TYPE___tempuri__WorkOrder:
		soap_serialize___tempuri__WorkOrder(soap, (const struct __tempuri__WorkOrder *)ptr);
		break;
	case SOAP_TYPE___tempuri__ToolingTimes:
		soap_serialize___tempuri__ToolingTimes(soap, (const struct __tempuri__ToolingTimes *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDocCode:
		soap_serialize___tempuri__GetDocCode(soap, (const struct __tempuri__GetDocCode *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDate:
		soap_serialize___tempuri__GetDate(soap, (const struct __tempuri__GetDate *)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__Login:
		soap_serialize_PointerTo_tempuri__Login(soap, (_tempuri__Login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetPower:
		soap_serialize_PointerTo_tempuri__GetPower(soap, (_tempuri__GetPower *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetDept:
		soap_serialize_PointerTo_tempuri__GetDept(soap, (_tempuri__GetDept *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__SetExMail:
		soap_serialize_PointerTo_tempuri__SetExMail(soap, (_tempuri__SetExMail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__DocAdd:
		soap_serialize_PointerTo_tempuri__DocAdd(soap, (_tempuri__DocAdd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__ItemsAdd:
		soap_serialize_PointerTo_tempuri__ItemsAdd(soap, (_tempuri__ItemsAdd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDonTest:
		soap_serialize_PointerTo_tempuri__AnDonTest(soap, (_tempuri__AnDonTest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDonCall:
		soap_serialize_PointerTo_tempuri__AnDonCall(soap, (_tempuri__AnDonCall *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDon:
		soap_serialize_PointerTo_tempuri__AnDon(soap, (_tempuri__AnDon *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryReturn:
		soap_serialize_PointerTo_tempuri__LineInventoryReturn(soap, (_tempuri__LineInventoryReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryUpdate:
		soap_serialize_PointerTo_tempuri__LineInventoryUpdate(soap, (_tempuri__LineInventoryUpdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__LineInventory:
		soap_serialize_PointerTo_tempuri__LineInventory(soap, (_tempuri__LineInventory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__WorkOrder:
		soap_serialize_PointerTo_tempuri__WorkOrder(soap, (_tempuri__WorkOrder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__ToolingTimes:
		soap_serialize_PointerTo_tempuri__ToolingTimes(soap, (_tempuri__ToolingTimes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetDocCode:
		soap_serialize_PointerTo_tempuri__GetDocCode(soap, (_tempuri__GetDocCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetDate:
		soap_serialize_PointerTo_tempuri__GetDate(soap, (_tempuri__GetDate *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE__tempuri__GetDate:
		return (void*)soap_instantiate__tempuri__GetDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetDateResponse:
		return (void*)soap_instantiate__tempuri__GetDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetDocCode:
		return (void*)soap_instantiate__tempuri__GetDocCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		return (void*)soap_instantiate__tempuri__GetDocCodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ToolingTimes:
		return (void*)soap_instantiate__tempuri__ToolingTimes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		return (void*)soap_instantiate__tempuri__ToolingTimesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__WorkOrder:
		return (void*)soap_instantiate__tempuri__WorkOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		return (void*)soap_instantiate__tempuri__WorkOrderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventory:
		return (void*)soap_instantiate__tempuri__LineInventory(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		return (void*)soap_instantiate__tempuri__LineInventoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		return (void*)soap_instantiate__tempuri__LineInventoryUpdate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		return (void*)soap_instantiate__tempuri__LineInventoryUpdateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		return (void*)soap_instantiate__tempuri__LineInventoryReturn(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		return (void*)soap_instantiate__tempuri__LineInventoryReturnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDon:
		return (void*)soap_instantiate__tempuri__AnDon(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonResponse:
		return (void*)soap_instantiate__tempuri__AnDonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonCall:
		return (void*)soap_instantiate__tempuri__AnDonCall(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonCallResponse:
		return (void*)soap_instantiate__tempuri__AnDonCallResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonTest:
		return (void*)soap_instantiate__tempuri__AnDonTest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonTestResponse:
		return (void*)soap_instantiate__tempuri__AnDonTestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ItemsAdd:
		return (void*)soap_instantiate__tempuri__ItemsAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		return (void*)soap_instantiate__tempuri__ItemsAddResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__DocAdd:
		return (void*)soap_instantiate__tempuri__DocAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__DocAddResponse:
		return (void*)soap_instantiate__tempuri__DocAddResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__SetExMail:
		return (void*)soap_instantiate__tempuri__SetExMail(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__SetExMailResponse:
		return (void*)soap_instantiate__tempuri__SetExMailResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetDept:
		return (void*)soap_instantiate__tempuri__GetDept(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetDeptResponse:
		return (void*)soap_instantiate__tempuri__GetDeptResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetPower:
		return (void*)soap_instantiate__tempuri__GetPower(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetPowerResponse:
		return (void*)soap_instantiate__tempuri__GetPowerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__Login:
		return (void*)soap_instantiate__tempuri__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LoginResponse:
		return (void*)soap_instantiate__tempuri__LoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDate:
		return (void*)soap_instantiate___tempuri__GetDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDocCode:
		return (void*)soap_instantiate___tempuri__GetDocCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__ToolingTimes:
		return (void*)soap_instantiate___tempuri__ToolingTimes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__WorkOrder:
		return (void*)soap_instantiate___tempuri__WorkOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventory:
		return (void*)soap_instantiate___tempuri__LineInventory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventoryUpdate:
		return (void*)soap_instantiate___tempuri__LineInventoryUpdate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventoryReturn:
		return (void*)soap_instantiate___tempuri__LineInventoryReturn(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDon:
		return (void*)soap_instantiate___tempuri__AnDon(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDonCall:
		return (void*)soap_instantiate___tempuri__AnDonCall(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDonTest:
		return (void*)soap_instantiate___tempuri__AnDonTest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__ItemsAdd:
		return (void*)soap_instantiate___tempuri__ItemsAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__DocAdd:
		return (void*)soap_instantiate___tempuri__DocAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__SetExMail:
		return (void*)soap_instantiate___tempuri__SetExMail(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDept:
		return (void*)soap_instantiate___tempuri__GetDept(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetPower:
		return (void*)soap_instantiate___tempuri__GetPower(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__Login:
		return (void*)soap_instantiate___tempuri__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDate_:
		return (void*)soap_instantiate___tempuri__GetDate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDocCode_:
		return (void*)soap_instantiate___tempuri__GetDocCode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__ToolingTimes_:
		return (void*)soap_instantiate___tempuri__ToolingTimes_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__WorkOrder_:
		return (void*)soap_instantiate___tempuri__WorkOrder_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventory_:
		return (void*)soap_instantiate___tempuri__LineInventory_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventoryUpdate_:
		return (void*)soap_instantiate___tempuri__LineInventoryUpdate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventoryReturn_:
		return (void*)soap_instantiate___tempuri__LineInventoryReturn_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDon_:
		return (void*)soap_instantiate___tempuri__AnDon_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDonCall_:
		return (void*)soap_instantiate___tempuri__AnDonCall_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDonTest_:
		return (void*)soap_instantiate___tempuri__AnDonTest_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__ItemsAdd_:
		return (void*)soap_instantiate___tempuri__ItemsAdd_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__DocAdd_:
		return (void*)soap_instantiate___tempuri__DocAdd_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__SetExMail_:
		return (void*)soap_instantiate___tempuri__SetExMail_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDept_:
		return (void*)soap_instantiate___tempuri__GetDept_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetPower_:
		return (void*)soap_instantiate___tempuri__GetPower_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__Login_:
		return (void*)soap_instantiate___tempuri__Login_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE__tempuri__GetDate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__GetDate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__GetDate*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__GetDateResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__GetDateResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__GetDateResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__GetDocCode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__GetDocCode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__GetDocCode*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__GetDocCodeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__GetDocCodeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__ToolingTimes:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__ToolingTimes*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__ToolingTimes*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__ToolingTimesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__ToolingTimesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__WorkOrder:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__WorkOrder*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__WorkOrder*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__WorkOrderResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__WorkOrderResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__LineInventory:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__LineInventory*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__LineInventory*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__LineInventoryResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__LineInventoryResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__LineInventoryUpdate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__LineInventoryUpdate*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__LineInventoryUpdateResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__LineInventoryUpdateResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__LineInventoryReturn*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__LineInventoryReturn*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__LineInventoryReturnResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__LineInventoryReturnResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDon:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDon*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDon*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonCall:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonCall*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonCall*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonCallResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonCallResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonCallResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonTest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonTest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonTest*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonTestResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonTestResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonTestResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__ItemsAdd:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__ItemsAdd*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__ItemsAdd*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__ItemsAddResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__ItemsAddResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__DocAdd:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__DocAdd*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__DocAdd*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__DocAddResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__DocAddResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__DocAddResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__SetExMail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__SetExMail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__SetExMail*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__SetExMailResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__SetExMailResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__SetExMailResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__GetDept:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__GetDept*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__GetDept*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__GetDeptResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__GetDeptResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__GetDeptResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__GetPower:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__GetPower*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__GetPower*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__GetPowerResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__GetPowerResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__GetPowerResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__Login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__Login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__Login*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__LoginResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__LoginResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__LoginResponse*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__GetDate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__GetDate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__GetDate*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__GetDocCode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__GetDocCode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__GetDocCode*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__ToolingTimes:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__ToolingTimes*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__ToolingTimes*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__WorkOrder:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__WorkOrder*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__WorkOrder*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__LineInventory:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__LineInventory*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__LineInventory*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__LineInventoryUpdate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__LineInventoryUpdate*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__LineInventoryReturn*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__LineInventoryReturn*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDon:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDon*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDon*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDonCall:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDonCall*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDonCall*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDonTest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDonTest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDonTest*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__ItemsAdd:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__ItemsAdd*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__ItemsAdd*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__DocAdd:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__DocAdd*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__DocAdd*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__SetExMail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__SetExMail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__SetExMail*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__GetDept:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__GetDept*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__GetDept*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__GetPower:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__GetPower*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__GetPower*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__Login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__Login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__Login*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__GetDate_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__GetDate_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__GetDate_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__GetDocCode_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__GetDocCode_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__GetDocCode_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__ToolingTimes_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__ToolingTimes_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__ToolingTimes_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__WorkOrder_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__WorkOrder_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__WorkOrder_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__LineInventory_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__LineInventory_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__LineInventory_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__LineInventoryUpdate_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__LineInventoryUpdate_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__LineInventoryReturn_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__LineInventoryReturn_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDon_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDon_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDon_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDonCall_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDonCall_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDonCall_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDonTest_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDonTest_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDonTest_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__ItemsAdd_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__ItemsAdd_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__ItemsAdd_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__DocAdd_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__DocAdd_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__DocAdd_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__SetExMail_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__SetExMail_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__SetExMail_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__GetDept_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__GetDept_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__GetDept_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__GetPower_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__GetPower_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__GetPower_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__Login_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__Login_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__Login_*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE__tempuri__GetDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDate type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDate*)p = *(_tempuri__GetDate*)q;
		break;
	case SOAP_TYPE__tempuri__GetDateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDateResponse*)p = *(_tempuri__GetDateResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetDocCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDocCode type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDocCode*)p = *(_tempuri__GetDocCode*)q;
		break;
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDocCodeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDocCodeResponse*)p = *(_tempuri__GetDocCodeResponse*)q;
		break;
	case SOAP_TYPE__tempuri__ToolingTimes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ToolingTimes type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ToolingTimes*)p = *(_tempuri__ToolingTimes*)q;
		break;
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ToolingTimesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ToolingTimesResponse*)p = *(_tempuri__ToolingTimesResponse*)q;
		break;
	case SOAP_TYPE__tempuri__WorkOrder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__WorkOrder type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__WorkOrder*)p = *(_tempuri__WorkOrder*)q;
		break;
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__WorkOrderResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__WorkOrderResponse*)p = *(_tempuri__WorkOrderResponse*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventory type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventory*)p = *(_tempuri__LineInventory*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryResponse*)p = *(_tempuri__LineInventoryResponse*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryUpdate type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryUpdate*)p = *(_tempuri__LineInventoryUpdate*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryUpdateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryUpdateResponse*)p = *(_tempuri__LineInventoryUpdateResponse*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryReturn type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryReturn*)p = *(_tempuri__LineInventoryReturn*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryReturnResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryReturnResponse*)p = *(_tempuri__LineInventoryReturnResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDon:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDon type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDon*)p = *(_tempuri__AnDon*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonResponse*)p = *(_tempuri__AnDonResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonCall:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonCall type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonCall*)p = *(_tempuri__AnDonCall*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonCallResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonCallResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonCallResponse*)p = *(_tempuri__AnDonCallResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonTest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonTest type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonTest*)p = *(_tempuri__AnDonTest*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonTestResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonTestResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonTestResponse*)p = *(_tempuri__AnDonTestResponse*)q;
		break;
	case SOAP_TYPE__tempuri__ItemsAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ItemsAdd type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ItemsAdd*)p = *(_tempuri__ItemsAdd*)q;
		break;
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ItemsAddResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ItemsAddResponse*)p = *(_tempuri__ItemsAddResponse*)q;
		break;
	case SOAP_TYPE__tempuri__DocAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__DocAdd type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__DocAdd*)p = *(_tempuri__DocAdd*)q;
		break;
	case SOAP_TYPE__tempuri__DocAddResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__DocAddResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__DocAddResponse*)p = *(_tempuri__DocAddResponse*)q;
		break;
	case SOAP_TYPE__tempuri__SetExMail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__SetExMail type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__SetExMail*)p = *(_tempuri__SetExMail*)q;
		break;
	case SOAP_TYPE__tempuri__SetExMailResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__SetExMailResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__SetExMailResponse*)p = *(_tempuri__SetExMailResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetDept:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDept type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDept*)p = *(_tempuri__GetDept*)q;
		break;
	case SOAP_TYPE__tempuri__GetDeptResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDeptResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDeptResponse*)p = *(_tempuri__GetDeptResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetPower:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetPower type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetPower*)p = *(_tempuri__GetPower*)q;
		break;
	case SOAP_TYPE__tempuri__GetPowerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetPowerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetPowerResponse*)p = *(_tempuri__GetPowerResponse*)q;
		break;
	case SOAP_TYPE__tempuri__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__Login type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__Login*)p = *(_tempuri__Login*)q;
		break;
	case SOAP_TYPE__tempuri__LoginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LoginResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LoginResponse*)p = *(_tempuri__LoginResponse*)q;
		break;
	case SOAP_TYPE___tempuri__GetDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDate type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDate*)p = *(struct __tempuri__GetDate*)q;
		break;
	case SOAP_TYPE___tempuri__GetDocCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDocCode type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDocCode*)p = *(struct __tempuri__GetDocCode*)q;
		break;
	case SOAP_TYPE___tempuri__ToolingTimes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__ToolingTimes type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__ToolingTimes*)p = *(struct __tempuri__ToolingTimes*)q;
		break;
	case SOAP_TYPE___tempuri__WorkOrder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__WorkOrder type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__WorkOrder*)p = *(struct __tempuri__WorkOrder*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventory type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventory*)p = *(struct __tempuri__LineInventory*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventoryUpdate type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventoryUpdate*)p = *(struct __tempuri__LineInventoryUpdate*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventoryReturn type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventoryReturn*)p = *(struct __tempuri__LineInventoryReturn*)q;
		break;
	case SOAP_TYPE___tempuri__AnDon:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDon type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDon*)p = *(struct __tempuri__AnDon*)q;
		break;
	case SOAP_TYPE___tempuri__AnDonCall:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDonCall type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDonCall*)p = *(struct __tempuri__AnDonCall*)q;
		break;
	case SOAP_TYPE___tempuri__AnDonTest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDonTest type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDonTest*)p = *(struct __tempuri__AnDonTest*)q;
		break;
	case SOAP_TYPE___tempuri__ItemsAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__ItemsAdd type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__ItemsAdd*)p = *(struct __tempuri__ItemsAdd*)q;
		break;
	case SOAP_TYPE___tempuri__DocAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__DocAdd type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__DocAdd*)p = *(struct __tempuri__DocAdd*)q;
		break;
	case SOAP_TYPE___tempuri__SetExMail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__SetExMail type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__SetExMail*)p = *(struct __tempuri__SetExMail*)q;
		break;
	case SOAP_TYPE___tempuri__GetDept:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDept type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDept*)p = *(struct __tempuri__GetDept*)q;
		break;
	case SOAP_TYPE___tempuri__GetPower:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetPower type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetPower*)p = *(struct __tempuri__GetPower*)q;
		break;
	case SOAP_TYPE___tempuri__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__Login type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__Login*)p = *(struct __tempuri__Login*)q;
		break;
	case SOAP_TYPE___tempuri__GetDate_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDate_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDate_*)p = *(struct __tempuri__GetDate_*)q;
		break;
	case SOAP_TYPE___tempuri__GetDocCode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDocCode_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDocCode_*)p = *(struct __tempuri__GetDocCode_*)q;
		break;
	case SOAP_TYPE___tempuri__ToolingTimes_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__ToolingTimes_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__ToolingTimes_*)p = *(struct __tempuri__ToolingTimes_*)q;
		break;
	case SOAP_TYPE___tempuri__WorkOrder_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__WorkOrder_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__WorkOrder_*)p = *(struct __tempuri__WorkOrder_*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventory_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventory_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventory_*)p = *(struct __tempuri__LineInventory_*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventoryUpdate_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventoryUpdate_*)p = *(struct __tempuri__LineInventoryUpdate_*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventoryReturn_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventoryReturn_*)p = *(struct __tempuri__LineInventoryReturn_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDon_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDon_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDon_*)p = *(struct __tempuri__AnDon_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDonCall_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDonCall_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDonCall_*)p = *(struct __tempuri__AnDonCall_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDonTest_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDonTest_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDonTest_*)p = *(struct __tempuri__AnDonTest_*)q;
		break;
	case SOAP_TYPE___tempuri__ItemsAdd_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__ItemsAdd_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__ItemsAdd_*)p = *(struct __tempuri__ItemsAdd_*)q;
		break;
	case SOAP_TYPE___tempuri__DocAdd_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__DocAdd_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__DocAdd_*)p = *(struct __tempuri__DocAdd_*)q;
		break;
	case SOAP_TYPE___tempuri__SetExMail_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__SetExMail_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__SetExMail_*)p = *(struct __tempuri__SetExMail_*)q;
		break;
	case SOAP_TYPE___tempuri__GetDept_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDept_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDept_*)p = *(struct __tempuri__GetDept_*)q;
		break;
	case SOAP_TYPE___tempuri__GetPower_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetPower_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetPower_*)p = *(struct __tempuri__GetPower_*)q;
		break;
	case SOAP_TYPE___tempuri__Login_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__Login_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__Login_*)p = *(struct __tempuri__Login_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__LoginResponse::LoginResult);
	/* transient soap skipped */
}

void _tempuri__LoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LoginResponse::LoginResult);
#endif
}

int _tempuri__LoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LoginResponse(struct soap *soap, const char *tag, int id, const _tempuri__LoginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LoginResponse), type))
		return soap->error;
	if (a->LoginResult)
		soap_element_result(soap, "tempuri:LoginResult");
	if (soap_out_string(soap, "tempuri:LoginResult", -1, (char*const*)&a->_tempuri__LoginResponse::LoginResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LoginResponse * SOAP_FMAC4 soap_in__tempuri__LoginResponse(struct soap *soap, const char *tag, _tempuri__LoginResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LoginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LoginResponse, sizeof(_tempuri__LoginResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LoginResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LoginResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LoginResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LoginResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:LoginResult", (char**)&a->_tempuri__LoginResponse::LoginResult, "xsd:string"))
				{	soap_flag_LoginResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:LoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LoginResponse, SOAP_TYPE__tempuri__LoginResponse, sizeof(_tempuri__LoginResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LoginResponse * SOAP_FMAC2 soap_instantiate__tempuri__LoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LoginResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LoginResponse *p;
	size_t k = sizeof(_tempuri__LoginResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__LoginResponse);
		if (p)
			((_tempuri__LoginResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__LoginResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__LoginResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LoginResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__LoginResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__LoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LoginResponse(soap, tag ? tag : "tempuri:LoginResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LoginResponse * SOAP_FMAC4 soap_get__tempuri__LoginResponse(struct soap *soap, _tempuri__LoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__Login::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__Login::Role);
	soap_default_string(soap, &this->_tempuri__Login::UserName);
	soap_default_string(soap, &this->_tempuri__Login::UserPwd);
	/* transient soap skipped */
}

void _tempuri__Login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__Login::Role);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__Login::UserName);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__Login::UserPwd);
#endif
}

int _tempuri__Login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__Login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__Login(struct soap *soap, const char *tag, int id, const _tempuri__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__Login), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:Role", -1, (char*const*)&a->_tempuri__Login::Role, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:UserName", -1, (char*const*)&a->_tempuri__Login::UserName, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:UserPwd", -1, (char*const*)&a->_tempuri__Login::UserPwd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__Login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__Login(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__Login * SOAP_FMAC4 soap_in__tempuri__Login(struct soap *soap, const char *tag, _tempuri__Login *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__Login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__Login, sizeof(_tempuri__Login), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__Login)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__Login *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Role1 = 1;
	size_t soap_flag_UserName1 = 1;
	size_t soap_flag_UserPwd1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Role1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:Role", (char**)&a->_tempuri__Login::Role, "xsd:string"))
				{	soap_flag_Role1--;
					continue;
				}
			}
			if (soap_flag_UserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:UserName", (char**)&a->_tempuri__Login::UserName, "xsd:string"))
				{	soap_flag_UserName1--;
					continue;
				}
			}
			if (soap_flag_UserPwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:UserPwd", (char**)&a->_tempuri__Login::UserPwd, "xsd:string"))
				{	soap_flag_UserPwd1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__Login, SOAP_TYPE__tempuri__Login, sizeof(_tempuri__Login), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__Login * SOAP_FMAC2 soap_instantiate__tempuri__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__Login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__Login *p;
	size_t k = sizeof(_tempuri__Login);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__Login);
		if (p)
			((_tempuri__Login*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__Login, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__Login*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__Login location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__Login, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__Login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__Login(soap, tag ? tag : "tempuri:Login", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__Login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__Login(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__Login * SOAP_FMAC4 soap_get__tempuri__Login(struct soap *soap, _tempuri__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetPowerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__GetPowerResponse::GetPowerResult);
	/* transient soap skipped */
}

void _tempuri__GetPowerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__GetPowerResponse::GetPowerResult);
#endif
}

int _tempuri__GetPowerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetPowerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetPowerResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetPowerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetPowerResponse), type))
		return soap->error;
	if (a->GetPowerResult)
		soap_element_result(soap, "tempuri:GetPowerResult");
	if (soap_out_string(soap, "tempuri:GetPowerResult", -1, (char*const*)&a->_tempuri__GetPowerResponse::GetPowerResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetPowerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetPowerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetPowerResponse * SOAP_FMAC4 soap_in__tempuri__GetPowerResponse(struct soap *soap, const char *tag, _tempuri__GetPowerResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetPowerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetPowerResponse, sizeof(_tempuri__GetPowerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetPowerResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetPowerResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetPowerResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPowerResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:GetPowerResult", (char**)&a->_tempuri__GetPowerResponse::GetPowerResult, "xsd:string"))
				{	soap_flag_GetPowerResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetPowerResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetPowerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetPowerResponse, SOAP_TYPE__tempuri__GetPowerResponse, sizeof(_tempuri__GetPowerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetPowerResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetPowerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetPowerResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetPowerResponse *p;
	size_t k = sizeof(_tempuri__GetPowerResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__GetPowerResponse);
		if (p)
			((_tempuri__GetPowerResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__GetPowerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__GetPowerResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetPowerResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__GetPowerResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__GetPowerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetPowerResponse(soap, tag ? tag : "tempuri:GetPowerResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetPowerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetPowerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetPowerResponse * SOAP_FMAC4 soap_get__tempuri__GetPowerResponse(struct soap *soap, _tempuri__GetPowerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetPowerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetPower::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__GetPower::DeptID);
	/* transient soap skipped */
}

void _tempuri__GetPower::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__GetPower::DeptID);
#endif
}

int _tempuri__GetPower::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetPower(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetPower(struct soap *soap, const char *tag, int id, const _tempuri__GetPower *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetPower), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DeptID", -1, (char*const*)&a->_tempuri__GetPower::DeptID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetPower::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetPower(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetPower * SOAP_FMAC4 soap_in__tempuri__GetPower(struct soap *soap, const char *tag, _tempuri__GetPower *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetPower *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetPower, sizeof(_tempuri__GetPower), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetPower)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetPower *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DeptID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeptID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DeptID", (char**)&a->_tempuri__GetPower::DeptID, "xsd:string"))
				{	soap_flag_DeptID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetPower *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetPower, SOAP_TYPE__tempuri__GetPower, sizeof(_tempuri__GetPower), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetPower * SOAP_FMAC2 soap_instantiate__tempuri__GetPower(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetPower(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetPower *p;
	size_t k = sizeof(_tempuri__GetPower);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__GetPower);
		if (p)
			((_tempuri__GetPower*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__GetPower, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__GetPower*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetPower location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__GetPower, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__GetPower::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetPower(soap, tag ? tag : "tempuri:GetPower", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetPower::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetPower(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetPower * SOAP_FMAC4 soap_get__tempuri__GetPower(struct soap *soap, _tempuri__GetPower *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetPower(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDeptResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__GetDeptResponse::GetDeptResult);
	/* transient soap skipped */
}

void _tempuri__GetDeptResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__GetDeptResponse::GetDeptResult);
#endif
}

int _tempuri__GetDeptResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDeptResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDeptResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetDeptResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDeptResponse), type))
		return soap->error;
	if (a->GetDeptResult)
		soap_element_result(soap, "tempuri:GetDeptResult");
	if (soap_out_string(soap, "tempuri:GetDeptResult", -1, (char*const*)&a->_tempuri__GetDeptResponse::GetDeptResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDeptResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDeptResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDeptResponse * SOAP_FMAC4 soap_in__tempuri__GetDeptResponse(struct soap *soap, const char *tag, _tempuri__GetDeptResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDeptResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDeptResponse, sizeof(_tempuri__GetDeptResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDeptResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDeptResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDeptResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDeptResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:GetDeptResult", (char**)&a->_tempuri__GetDeptResponse::GetDeptResult, "xsd:string"))
				{	soap_flag_GetDeptResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetDeptResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDeptResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDeptResponse, SOAP_TYPE__tempuri__GetDeptResponse, sizeof(_tempuri__GetDeptResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDeptResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetDeptResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDeptResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDeptResponse *p;
	size_t k = sizeof(_tempuri__GetDeptResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__GetDeptResponse);
		if (p)
			((_tempuri__GetDeptResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__GetDeptResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__GetDeptResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDeptResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__GetDeptResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__GetDeptResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDeptResponse(soap, tag ? tag : "tempuri:GetDeptResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDeptResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDeptResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDeptResponse * SOAP_FMAC4 soap_get__tempuri__GetDeptResponse(struct soap *soap, _tempuri__GetDeptResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDeptResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDept::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tempuri__GetDept::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetDept::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDept(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDept(struct soap *soap, const char *tag, int id, const _tempuri__GetDept *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDept), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDept::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDept(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDept * SOAP_FMAC4 soap_in__tempuri__GetDept(struct soap *soap, const char *tag, _tempuri__GetDept *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDept *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDept, sizeof(_tempuri__GetDept), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDept)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDept *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDept *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDept, SOAP_TYPE__tempuri__GetDept, sizeof(_tempuri__GetDept), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDept * SOAP_FMAC2 soap_instantiate__tempuri__GetDept(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDept(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDept *p;
	size_t k = sizeof(_tempuri__GetDept);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__GetDept);
		if (p)
			((_tempuri__GetDept*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__GetDept, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__GetDept*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDept location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__GetDept, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__GetDept::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDept(soap, tag ? tag : "tempuri:GetDept", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDept::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDept(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDept * SOAP_FMAC4 soap_get__tempuri__GetDept(struct soap *soap, _tempuri__GetDept *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDept(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__SetExMailResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tempuri__SetExMailResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__SetExMailResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__SetExMailResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__SetExMailResponse(struct soap *soap, const char *tag, int id, const _tempuri__SetExMailResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__SetExMailResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__SetExMailResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__SetExMailResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__SetExMailResponse * SOAP_FMAC4 soap_in__tempuri__SetExMailResponse(struct soap *soap, const char *tag, _tempuri__SetExMailResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__SetExMailResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__SetExMailResponse, sizeof(_tempuri__SetExMailResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__SetExMailResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__SetExMailResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__SetExMailResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__SetExMailResponse, SOAP_TYPE__tempuri__SetExMailResponse, sizeof(_tempuri__SetExMailResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__SetExMailResponse * SOAP_FMAC2 soap_instantiate__tempuri__SetExMailResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__SetExMailResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__SetExMailResponse *p;
	size_t k = sizeof(_tempuri__SetExMailResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__SetExMailResponse);
		if (p)
			((_tempuri__SetExMailResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__SetExMailResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__SetExMailResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__SetExMailResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__SetExMailResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__SetExMailResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__SetExMailResponse(soap, tag ? tag : "tempuri:SetExMailResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__SetExMailResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__SetExMailResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__SetExMailResponse * SOAP_FMAC4 soap_get__tempuri__SetExMailResponse(struct soap *soap, _tempuri__SetExMailResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__SetExMailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__SetExMail::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__SetExMail::to);
	soap_default_string(soap, &this->_tempuri__SetExMail::title);
	soap_default_string(soap, &this->_tempuri__SetExMail::body);
	/* transient soap skipped */
}

void _tempuri__SetExMail::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__SetExMail::to);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__SetExMail::title);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__SetExMail::body);
#endif
}

int _tempuri__SetExMail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__SetExMail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__SetExMail(struct soap *soap, const char *tag, int id, const _tempuri__SetExMail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__SetExMail), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:to", -1, (char*const*)&a->_tempuri__SetExMail::to, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:title", -1, (char*const*)&a->_tempuri__SetExMail::title, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:body", -1, (char*const*)&a->_tempuri__SetExMail::body, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__SetExMail::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__SetExMail(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__SetExMail * SOAP_FMAC4 soap_in__tempuri__SetExMail(struct soap *soap, const char *tag, _tempuri__SetExMail *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__SetExMail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__SetExMail, sizeof(_tempuri__SetExMail), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__SetExMail)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__SetExMail *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_to1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_body1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_to1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:to", (char**)&a->_tempuri__SetExMail::to, "xsd:string"))
				{	soap_flag_to1--;
					continue;
				}
			}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:title", (char**)&a->_tempuri__SetExMail::title, "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			}
			if (soap_flag_body1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:body", (char**)&a->_tempuri__SetExMail::body, "xsd:string"))
				{	soap_flag_body1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__SetExMail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__SetExMail, SOAP_TYPE__tempuri__SetExMail, sizeof(_tempuri__SetExMail), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__SetExMail * SOAP_FMAC2 soap_instantiate__tempuri__SetExMail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__SetExMail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__SetExMail *p;
	size_t k = sizeof(_tempuri__SetExMail);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__SetExMail);
		if (p)
			((_tempuri__SetExMail*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__SetExMail, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__SetExMail*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__SetExMail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__SetExMail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__SetExMail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__SetExMail(soap, tag ? tag : "tempuri:SetExMail", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__SetExMail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__SetExMail(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__SetExMail * SOAP_FMAC4 soap_get__tempuri__SetExMail(struct soap *soap, _tempuri__SetExMail *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__SetExMail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__DocAddResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__DocAddResponse::DocAddResult);
	/* transient soap skipped */
}

void _tempuri__DocAddResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__DocAddResponse::DocAddResult);
#endif
}

int _tempuri__DocAddResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__DocAddResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__DocAddResponse(struct soap *soap, const char *tag, int id, const _tempuri__DocAddResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__DocAddResponse), type))
		return soap->error;
	if (a->DocAddResult)
		soap_element_result(soap, "tempuri:DocAddResult");
	if (soap_out_string(soap, "tempuri:DocAddResult", -1, (char*const*)&a->_tempuri__DocAddResponse::DocAddResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__DocAddResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__DocAddResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__DocAddResponse * SOAP_FMAC4 soap_in__tempuri__DocAddResponse(struct soap *soap, const char *tag, _tempuri__DocAddResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__DocAddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__DocAddResponse, sizeof(_tempuri__DocAddResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__DocAddResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__DocAddResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DocAddResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocAddResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocAddResult", (char**)&a->_tempuri__DocAddResponse::DocAddResult, "xsd:string"))
				{	soap_flag_DocAddResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:DocAddResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__DocAddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__DocAddResponse, SOAP_TYPE__tempuri__DocAddResponse, sizeof(_tempuri__DocAddResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__DocAddResponse * SOAP_FMAC2 soap_instantiate__tempuri__DocAddResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__DocAddResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__DocAddResponse *p;
	size_t k = sizeof(_tempuri__DocAddResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__DocAddResponse);
		if (p)
			((_tempuri__DocAddResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__DocAddResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__DocAddResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__DocAddResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__DocAddResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__DocAddResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__DocAddResponse(soap, tag ? tag : "tempuri:DocAddResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__DocAddResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__DocAddResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__DocAddResponse * SOAP_FMAC4 soap_get__tempuri__DocAddResponse(struct soap *soap, _tempuri__DocAddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__DocAddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__DocAdd::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__DocAdd::DocTypeCode);
	soap_default_string(soap, &this->_tempuri__DocAdd::DocXmlMaster);
	soap_default_string(soap, &this->_tempuri__DocAdd::DocXmlItems);
	/* transient soap skipped */
}

void _tempuri__DocAdd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__DocAdd::DocTypeCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__DocAdd::DocXmlMaster);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__DocAdd::DocXmlItems);
#endif
}

int _tempuri__DocAdd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__DocAdd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__DocAdd(struct soap *soap, const char *tag, int id, const _tempuri__DocAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__DocAdd), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DocTypeCode", -1, (char*const*)&a->_tempuri__DocAdd::DocTypeCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DocXmlMaster", -1, (char*const*)&a->_tempuri__DocAdd::DocXmlMaster, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DocXmlItems", -1, (char*const*)&a->_tempuri__DocAdd::DocXmlItems, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__DocAdd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__DocAdd(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__DocAdd * SOAP_FMAC4 soap_in__tempuri__DocAdd(struct soap *soap, const char *tag, _tempuri__DocAdd *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__DocAdd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__DocAdd, sizeof(_tempuri__DocAdd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__DocAdd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__DocAdd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DocTypeCode1 = 1;
	size_t soap_flag_DocXmlMaster1 = 1;
	size_t soap_flag_DocXmlItems1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocTypeCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocTypeCode", (char**)&a->_tempuri__DocAdd::DocTypeCode, "xsd:string"))
				{	soap_flag_DocTypeCode1--;
					continue;
				}
			}
			if (soap_flag_DocXmlMaster1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocXmlMaster", (char**)&a->_tempuri__DocAdd::DocXmlMaster, "xsd:string"))
				{	soap_flag_DocXmlMaster1--;
					continue;
				}
			}
			if (soap_flag_DocXmlItems1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocXmlItems", (char**)&a->_tempuri__DocAdd::DocXmlItems, "xsd:string"))
				{	soap_flag_DocXmlItems1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__DocAdd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__DocAdd, SOAP_TYPE__tempuri__DocAdd, sizeof(_tempuri__DocAdd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__DocAdd * SOAP_FMAC2 soap_instantiate__tempuri__DocAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__DocAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__DocAdd *p;
	size_t k = sizeof(_tempuri__DocAdd);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__DocAdd);
		if (p)
			((_tempuri__DocAdd*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__DocAdd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__DocAdd*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__DocAdd location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__DocAdd, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__DocAdd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__DocAdd(soap, tag ? tag : "tempuri:DocAdd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__DocAdd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__DocAdd(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__DocAdd * SOAP_FMAC4 soap_get__tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__DocAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ItemsAddResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__ItemsAddResponse::ItemsAddResult);
	/* transient soap skipped */
}

void _tempuri__ItemsAddResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__ItemsAddResponse::ItemsAddResult);
#endif
}

int _tempuri__ItemsAddResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ItemsAddResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ItemsAddResponse(struct soap *soap, const char *tag, int id, const _tempuri__ItemsAddResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ItemsAddResponse), type))
		return soap->error;
	if (a->ItemsAddResult)
		soap_element_result(soap, "tempuri:ItemsAddResult");
	if (soap_out_string(soap, "tempuri:ItemsAddResult", -1, (char*const*)&a->_tempuri__ItemsAddResponse::ItemsAddResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ItemsAddResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__ItemsAddResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ItemsAddResponse * SOAP_FMAC4 soap_in__tempuri__ItemsAddResponse(struct soap *soap, const char *tag, _tempuri__ItemsAddResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ItemsAddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ItemsAddResponse, sizeof(_tempuri__ItemsAddResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ItemsAddResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ItemsAddResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ItemsAddResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ItemsAddResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:ItemsAddResult", (char**)&a->_tempuri__ItemsAddResponse::ItemsAddResult, "xsd:string"))
				{	soap_flag_ItemsAddResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:ItemsAddResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ItemsAddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ItemsAddResponse, SOAP_TYPE__tempuri__ItemsAddResponse, sizeof(_tempuri__ItemsAddResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ItemsAddResponse * SOAP_FMAC2 soap_instantiate__tempuri__ItemsAddResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ItemsAddResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ItemsAddResponse *p;
	size_t k = sizeof(_tempuri__ItemsAddResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__ItemsAddResponse);
		if (p)
			((_tempuri__ItemsAddResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__ItemsAddResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__ItemsAddResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ItemsAddResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__ItemsAddResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__ItemsAddResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ItemsAddResponse(soap, tag ? tag : "tempuri:ItemsAddResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ItemsAddResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ItemsAddResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ItemsAddResponse * SOAP_FMAC4 soap_get__tempuri__ItemsAddResponse(struct soap *soap, _tempuri__ItemsAddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ItemsAddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ItemsAdd::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__ItemsAdd::itemDocXml);
	/* transient soap skipped */
}

void _tempuri__ItemsAdd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__ItemsAdd::itemDocXml);
#endif
}

int _tempuri__ItemsAdd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ItemsAdd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ItemsAdd(struct soap *soap, const char *tag, int id, const _tempuri__ItemsAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ItemsAdd), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:itemDocXml", -1, (char*const*)&a->_tempuri__ItemsAdd::itemDocXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ItemsAdd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__ItemsAdd(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ItemsAdd * SOAP_FMAC4 soap_in__tempuri__ItemsAdd(struct soap *soap, const char *tag, _tempuri__ItemsAdd *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ItemsAdd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ItemsAdd, sizeof(_tempuri__ItemsAdd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ItemsAdd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ItemsAdd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_itemDocXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_itemDocXml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:itemDocXml", (char**)&a->_tempuri__ItemsAdd::itemDocXml, "xsd:string"))
				{	soap_flag_itemDocXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ItemsAdd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ItemsAdd, SOAP_TYPE__tempuri__ItemsAdd, sizeof(_tempuri__ItemsAdd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ItemsAdd * SOAP_FMAC2 soap_instantiate__tempuri__ItemsAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ItemsAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ItemsAdd *p;
	size_t k = sizeof(_tempuri__ItemsAdd);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__ItemsAdd);
		if (p)
			((_tempuri__ItemsAdd*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__ItemsAdd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__ItemsAdd*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ItemsAdd location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__ItemsAdd, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__ItemsAdd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ItemsAdd(soap, tag ? tag : "tempuri:ItemsAdd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ItemsAdd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ItemsAdd(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ItemsAdd * SOAP_FMAC4 soap_get__tempuri__ItemsAdd(struct soap *soap, _tempuri__ItemsAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ItemsAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonTestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__AnDonTestResponse::AnDonTestResult);
	/* transient soap skipped */
}

void _tempuri__AnDonTestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonTestResponse::AnDonTestResult);
#endif
}

int _tempuri__AnDonTestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonTestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonTestResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDonTestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonTestResponse), type))
		return soap->error;
	if (a->AnDonTestResult)
		soap_element_result(soap, "tempuri:AnDonTestResult");
	if (soap_out_string(soap, "tempuri:AnDonTestResult", -1, (char*const*)&a->_tempuri__AnDonTestResponse::AnDonTestResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonTestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonTestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonTestResponse * SOAP_FMAC4 soap_in__tempuri__AnDonTestResponse(struct soap *soap, const char *tag, _tempuri__AnDonTestResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonTestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonTestResponse, sizeof(_tempuri__AnDonTestResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonTestResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonTestResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDonTestResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDonTestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:AnDonTestResult", (char**)&a->_tempuri__AnDonTestResponse::AnDonTestResult, "xsd:string"))
				{	soap_flag_AnDonTestResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDonTestResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDonTestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonTestResponse, SOAP_TYPE__tempuri__AnDonTestResponse, sizeof(_tempuri__AnDonTestResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonTestResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonTestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonTestResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonTestResponse *p;
	size_t k = sizeof(_tempuri__AnDonTestResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonTestResponse);
		if (p)
			((_tempuri__AnDonTestResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonTestResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonTestResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonTestResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonTestResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonTestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonTestResponse(soap, tag ? tag : "tempuri:AnDonTestResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonTestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonTestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonTestResponse * SOAP_FMAC4 soap_get__tempuri__AnDonTestResponse(struct soap *soap, _tempuri__AnDonTestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonTestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonTest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_tempuri__AnDonTest::i);
	/* transient soap skipped */
}

void _tempuri__AnDonTest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__AnDonTest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonTest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonTest(struct soap *soap, const char *tag, int id, const _tempuri__AnDonTest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonTest), type))
		return soap->error;
	if (soap_out_int(soap, "tempuri:i", -1, &a->_tempuri__AnDonTest::i, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonTest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonTest(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonTest * SOAP_FMAC4 soap_in__tempuri__AnDonTest(struct soap *soap, const char *tag, _tempuri__AnDonTest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonTest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonTest, sizeof(_tempuri__AnDonTest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonTest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonTest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_i1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_i1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tempuri:i", &a->_tempuri__AnDonTest::i, "xsd:int"))
				{	soap_flag_i1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_i1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tempuri__AnDonTest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonTest, SOAP_TYPE__tempuri__AnDonTest, sizeof(_tempuri__AnDonTest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonTest * SOAP_FMAC2 soap_instantiate__tempuri__AnDonTest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonTest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonTest *p;
	size_t k = sizeof(_tempuri__AnDonTest);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonTest);
		if (p)
			((_tempuri__AnDonTest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonTest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonTest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonTest location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonTest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonTest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonTest(soap, tag ? tag : "tempuri:AnDonTest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonTest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonTest(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonTest * SOAP_FMAC4 soap_get__tempuri__AnDonTest(struct soap *soap, _tempuri__AnDonTest *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonCallResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__AnDonCallResponse::AnDonCallResult);
	/* transient soap skipped */
}

void _tempuri__AnDonCallResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonCallResponse::AnDonCallResult);
#endif
}

int _tempuri__AnDonCallResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonCallResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonCallResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDonCallResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonCallResponse), type))
		return soap->error;
	if (a->AnDonCallResult)
		soap_element_result(soap, "tempuri:AnDonCallResult");
	if (soap_out_string(soap, "tempuri:AnDonCallResult", -1, (char*const*)&a->_tempuri__AnDonCallResponse::AnDonCallResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonCallResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonCallResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonCallResponse * SOAP_FMAC4 soap_in__tempuri__AnDonCallResponse(struct soap *soap, const char *tag, _tempuri__AnDonCallResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonCallResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonCallResponse, sizeof(_tempuri__AnDonCallResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonCallResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonCallResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDonCallResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDonCallResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:AnDonCallResult", (char**)&a->_tempuri__AnDonCallResponse::AnDonCallResult, "xsd:string"))
				{	soap_flag_AnDonCallResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDonCallResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDonCallResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonCallResponse, SOAP_TYPE__tempuri__AnDonCallResponse, sizeof(_tempuri__AnDonCallResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonCallResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonCallResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonCallResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonCallResponse *p;
	size_t k = sizeof(_tempuri__AnDonCallResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonCallResponse);
		if (p)
			((_tempuri__AnDonCallResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonCallResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonCallResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonCallResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonCallResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonCallResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonCallResponse(soap, tag ? tag : "tempuri:AnDonCallResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonCallResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonCallResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonCallResponse * SOAP_FMAC4 soap_get__tempuri__AnDonCallResponse(struct soap *soap, _tempuri__AnDonCallResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonCallResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonCall::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__AnDonCall::AnDonCallXml);
	/* transient soap skipped */
}

void _tempuri__AnDonCall::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonCall::AnDonCallXml);
#endif
}

int _tempuri__AnDonCall::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonCall(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonCall(struct soap *soap, const char *tag, int id, const _tempuri__AnDonCall *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonCall), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:AnDonCallXml", -1, (char*const*)&a->_tempuri__AnDonCall::AnDonCallXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonCall::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonCall(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonCall * SOAP_FMAC4 soap_in__tempuri__AnDonCall(struct soap *soap, const char *tag, _tempuri__AnDonCall *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonCall *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonCall, sizeof(_tempuri__AnDonCall), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonCall)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonCall *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDonCallXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDonCallXml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:AnDonCallXml", (char**)&a->_tempuri__AnDonCall::AnDonCallXml, "xsd:string"))
				{	soap_flag_AnDonCallXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDonCall *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonCall, SOAP_TYPE__tempuri__AnDonCall, sizeof(_tempuri__AnDonCall), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonCall * SOAP_FMAC2 soap_instantiate__tempuri__AnDonCall(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonCall(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonCall *p;
	size_t k = sizeof(_tempuri__AnDonCall);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonCall);
		if (p)
			((_tempuri__AnDonCall*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonCall, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonCall*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonCall location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonCall, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonCall::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonCall(soap, tag ? tag : "tempuri:AnDonCall", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonCall::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonCall(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonCall * SOAP_FMAC4 soap_get__tempuri__AnDonCall(struct soap *soap, _tempuri__AnDonCall *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonCall(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__AnDonResponse::AnDonResult);
	/* transient soap skipped */
}

void _tempuri__AnDonResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonResponse::AnDonResult);
#endif
}

int _tempuri__AnDonResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDonResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonResponse), type))
		return soap->error;
	if (a->AnDonResult)
		soap_element_result(soap, "tempuri:AnDonResult");
	if (soap_out_string(soap, "tempuri:AnDonResult", -1, (char*const*)&a->_tempuri__AnDonResponse::AnDonResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonResponse * SOAP_FMAC4 soap_in__tempuri__AnDonResponse(struct soap *soap, const char *tag, _tempuri__AnDonResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonResponse, sizeof(_tempuri__AnDonResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDonResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDonResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:AnDonResult", (char**)&a->_tempuri__AnDonResponse::AnDonResult, "xsd:string"))
				{	soap_flag_AnDonResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDonResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonResponse, SOAP_TYPE__tempuri__AnDonResponse, sizeof(_tempuri__AnDonResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonResponse *p;
	size_t k = sizeof(_tempuri__AnDonResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonResponse);
		if (p)
			((_tempuri__AnDonResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonResponse(soap, tag ? tag : "tempuri:AnDonResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonResponse * SOAP_FMAC4 soap_get__tempuri__AnDonResponse(struct soap *soap, _tempuri__AnDonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDon::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__AnDon::Type);
	soap_default_string(soap, &this->_tempuri__AnDon::DocXmlMaster);
	soap_default_string(soap, &this->_tempuri__AnDon::DocXmlList);
	soap_default_string(soap, &this->_tempuri__AnDon::DocXmlSLList);
	/* transient soap skipped */
}

void _tempuri__AnDon::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDon::Type);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDon::DocXmlMaster);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDon::DocXmlList);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDon::DocXmlSLList);
#endif
}

int _tempuri__AnDon::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDon(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDon(struct soap *soap, const char *tag, int id, const _tempuri__AnDon *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDon), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:Type", -1, (char*const*)&a->_tempuri__AnDon::Type, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DocXmlMaster", -1, (char*const*)&a->_tempuri__AnDon::DocXmlMaster, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DocXmlList", -1, (char*const*)&a->_tempuri__AnDon::DocXmlList, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DocXmlSLList", -1, (char*const*)&a->_tempuri__AnDon::DocXmlSLList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDon::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDon(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDon * SOAP_FMAC4 soap_in__tempuri__AnDon(struct soap *soap, const char *tag, _tempuri__AnDon *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDon *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDon, sizeof(_tempuri__AnDon), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDon)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDon *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_DocXmlMaster1 = 1;
	size_t soap_flag_DocXmlList1 = 1;
	size_t soap_flag_DocXmlSLList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:Type", (char**)&a->_tempuri__AnDon::Type, "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_DocXmlMaster1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocXmlMaster", (char**)&a->_tempuri__AnDon::DocXmlMaster, "xsd:string"))
				{	soap_flag_DocXmlMaster1--;
					continue;
				}
			}
			if (soap_flag_DocXmlList1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocXmlList", (char**)&a->_tempuri__AnDon::DocXmlList, "xsd:string"))
				{	soap_flag_DocXmlList1--;
					continue;
				}
			}
			if (soap_flag_DocXmlSLList1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocXmlSLList", (char**)&a->_tempuri__AnDon::DocXmlSLList, "xsd:string"))
				{	soap_flag_DocXmlSLList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDon, SOAP_TYPE__tempuri__AnDon, sizeof(_tempuri__AnDon), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDon * SOAP_FMAC2 soap_instantiate__tempuri__AnDon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDon(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDon *p;
	size_t k = sizeof(_tempuri__AnDon);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDon);
		if (p)
			((_tempuri__AnDon*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDon, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDon*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDon location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDon, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDon::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDon(soap, tag ? tag : "tempuri:AnDon", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDon::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDon(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDon * SOAP_FMAC4 soap_get__tempuri__AnDon(struct soap *soap, _tempuri__AnDon *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryReturnResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__LineInventoryReturnResponse::LineInventoryReturnResult);
	/* transient soap skipped */
}

void _tempuri__LineInventoryReturnResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventoryReturnResponse::LineInventoryReturnResult);
#endif
}

int _tempuri__LineInventoryReturnResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryReturnResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryReturnResponse(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryReturnResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryReturnResponse), type))
		return soap->error;
	if (a->LineInventoryReturnResult)
		soap_element_result(soap, "tempuri:LineInventoryReturnResult");
	if (soap_out_string(soap, "tempuri:LineInventoryReturnResult", -1, (char*const*)&a->_tempuri__LineInventoryReturnResponse::LineInventoryReturnResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryReturnResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryReturnResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryReturnResponse * SOAP_FMAC4 soap_in__tempuri__LineInventoryReturnResponse(struct soap *soap, const char *tag, _tempuri__LineInventoryReturnResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryReturnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryReturnResponse, sizeof(_tempuri__LineInventoryReturnResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryReturnResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryReturnResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LineInventoryReturnResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineInventoryReturnResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:LineInventoryReturnResult", (char**)&a->_tempuri__LineInventoryReturnResponse::LineInventoryReturnResult, "xsd:string"))
				{	soap_flag_LineInventoryReturnResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:LineInventoryReturnResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryReturnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryReturnResponse, SOAP_TYPE__tempuri__LineInventoryReturnResponse, sizeof(_tempuri__LineInventoryReturnResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryReturnResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryReturnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryReturnResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryReturnResponse *p;
	size_t k = sizeof(_tempuri__LineInventoryReturnResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__LineInventoryReturnResponse);
		if (p)
			((_tempuri__LineInventoryReturnResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__LineInventoryReturnResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__LineInventoryReturnResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryReturnResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__LineInventoryReturnResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__LineInventoryReturnResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryReturnResponse(soap, tag ? tag : "tempuri:LineInventoryReturnResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryReturnResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryReturnResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryReturnResponse * SOAP_FMAC4 soap_get__tempuri__LineInventoryReturnResponse(struct soap *soap, _tempuri__LineInventoryReturnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryReturnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryReturn::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__LineInventoryReturn::LRXml);
	/* transient soap skipped */
}

void _tempuri__LineInventoryReturn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventoryReturn::LRXml);
#endif
}

int _tempuri__LineInventoryReturn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryReturn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryReturn(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryReturn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryReturn), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:LRXml", -1, (char*const*)&a->_tempuri__LineInventoryReturn::LRXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryReturn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryReturn(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryReturn * SOAP_FMAC4 soap_in__tempuri__LineInventoryReturn(struct soap *soap, const char *tag, _tempuri__LineInventoryReturn *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryReturn, sizeof(_tempuri__LineInventoryReturn), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryReturn)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryReturn *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LRXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LRXml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:LRXml", (char**)&a->_tempuri__LineInventoryReturn::LRXml, "xsd:string"))
				{	soap_flag_LRXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryReturn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryReturn, SOAP_TYPE__tempuri__LineInventoryReturn, sizeof(_tempuri__LineInventoryReturn), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryReturn * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryReturn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryReturn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryReturn *p;
	size_t k = sizeof(_tempuri__LineInventoryReturn);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__LineInventoryReturn);
		if (p)
			((_tempuri__LineInventoryReturn*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__LineInventoryReturn, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__LineInventoryReturn*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryReturn location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__LineInventoryReturn, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__LineInventoryReturn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryReturn(soap, tag ? tag : "tempuri:LineInventoryReturn", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryReturn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryReturn(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryReturn * SOAP_FMAC4 soap_get__tempuri__LineInventoryReturn(struct soap *soap, _tempuri__LineInventoryReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryUpdateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__LineInventoryUpdateResponse::LineInventoryUpdateResult);
	/* transient soap skipped */
}

void _tempuri__LineInventoryUpdateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventoryUpdateResponse::LineInventoryUpdateResult);
#endif
}

int _tempuri__LineInventoryUpdateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryUpdateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryUpdateResponse(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryUpdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryUpdateResponse), type))
		return soap->error;
	if (a->LineInventoryUpdateResult)
		soap_element_result(soap, "tempuri:LineInventoryUpdateResult");
	if (soap_out_string(soap, "tempuri:LineInventoryUpdateResult", -1, (char*const*)&a->_tempuri__LineInventoryUpdateResponse::LineInventoryUpdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryUpdateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryUpdateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdateResponse * SOAP_FMAC4 soap_in__tempuri__LineInventoryUpdateResponse(struct soap *soap, const char *tag, _tempuri__LineInventoryUpdateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryUpdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryUpdateResponse, sizeof(_tempuri__LineInventoryUpdateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryUpdateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryUpdateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LineInventoryUpdateResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineInventoryUpdateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:LineInventoryUpdateResult", (char**)&a->_tempuri__LineInventoryUpdateResponse::LineInventoryUpdateResult, "xsd:string"))
				{	soap_flag_LineInventoryUpdateResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:LineInventoryUpdateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryUpdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryUpdateResponse, SOAP_TYPE__tempuri__LineInventoryUpdateResponse, sizeof(_tempuri__LineInventoryUpdateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryUpdateResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryUpdateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryUpdateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryUpdateResponse *p;
	size_t k = sizeof(_tempuri__LineInventoryUpdateResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__LineInventoryUpdateResponse);
		if (p)
			((_tempuri__LineInventoryUpdateResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__LineInventoryUpdateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__LineInventoryUpdateResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryUpdateResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__LineInventoryUpdateResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__LineInventoryUpdateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryUpdateResponse(soap, tag ? tag : "tempuri:LineInventoryUpdateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryUpdateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryUpdateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdateResponse * SOAP_FMAC4 soap_get__tempuri__LineInventoryUpdateResponse(struct soap *soap, _tempuri__LineInventoryUpdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryUpdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryUpdate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__LineInventoryUpdate::LIXml);
	/* transient soap skipped */
}

void _tempuri__LineInventoryUpdate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventoryUpdate::LIXml);
#endif
}

int _tempuri__LineInventoryUpdate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryUpdate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryUpdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryUpdate), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:LIXml", -1, (char*const*)&a->_tempuri__LineInventoryUpdate::LIXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryUpdate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryUpdate(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdate * SOAP_FMAC4 soap_in__tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, _tempuri__LineInventoryUpdate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryUpdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryUpdate, sizeof(_tempuri__LineInventoryUpdate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryUpdate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryUpdate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LIXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LIXml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:LIXml", (char**)&a->_tempuri__LineInventoryUpdate::LIXml, "xsd:string"))
				{	soap_flag_LIXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryUpdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryUpdate, SOAP_TYPE__tempuri__LineInventoryUpdate, sizeof(_tempuri__LineInventoryUpdate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryUpdate * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryUpdate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryUpdate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryUpdate *p;
	size_t k = sizeof(_tempuri__LineInventoryUpdate);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__LineInventoryUpdate);
		if (p)
			((_tempuri__LineInventoryUpdate*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__LineInventoryUpdate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__LineInventoryUpdate*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryUpdate location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__LineInventoryUpdate, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__LineInventoryUpdate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryUpdate(soap, tag ? tag : "tempuri:LineInventoryUpdate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryUpdate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryUpdate(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdate * SOAP_FMAC4 soap_get__tempuri__LineInventoryUpdate(struct soap *soap, _tempuri__LineInventoryUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__LineInventoryResponse::LineInventoryResult);
	/* transient soap skipped */
}

void _tempuri__LineInventoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventoryResponse::LineInventoryResult);
#endif
}

int _tempuri__LineInventoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryResponse(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryResponse), type))
		return soap->error;
	if (a->LineInventoryResult)
		soap_element_result(soap, "tempuri:LineInventoryResult");
	if (soap_out_string(soap, "tempuri:LineInventoryResult", -1, (char*const*)&a->_tempuri__LineInventoryResponse::LineInventoryResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryResponse * SOAP_FMAC4 soap_in__tempuri__LineInventoryResponse(struct soap *soap, const char *tag, _tempuri__LineInventoryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryResponse, sizeof(_tempuri__LineInventoryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LineInventoryResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineInventoryResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:LineInventoryResult", (char**)&a->_tempuri__LineInventoryResponse::LineInventoryResult, "xsd:string"))
				{	soap_flag_LineInventoryResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:LineInventoryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryResponse, SOAP_TYPE__tempuri__LineInventoryResponse, sizeof(_tempuri__LineInventoryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryResponse *p;
	size_t k = sizeof(_tempuri__LineInventoryResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__LineInventoryResponse);
		if (p)
			((_tempuri__LineInventoryResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__LineInventoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__LineInventoryResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__LineInventoryResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__LineInventoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryResponse(soap, tag ? tag : "tempuri:LineInventoryResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryResponse * SOAP_FMAC4 soap_get__tempuri__LineInventoryResponse(struct soap *soap, _tempuri__LineInventoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventory::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__LineInventory::WorkLineCode);
	soap_default_string(soap, &this->_tempuri__LineInventory::MCode);
	soap_default_string(soap, &this->_tempuri__LineInventory::BatchNo);
	soap_default_string(soap, &this->_tempuri__LineInventory::BarCode);
	/* transient soap skipped */
}

void _tempuri__LineInventory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventory::WorkLineCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventory::MCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventory::BatchNo);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventory::BarCode);
#endif
}

int _tempuri__LineInventory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventory(struct soap *soap, const char *tag, int id, const _tempuri__LineInventory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventory), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:WorkLineCode", -1, (char*const*)&a->_tempuri__LineInventory::WorkLineCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:MCode", -1, (char*const*)&a->_tempuri__LineInventory::MCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:BatchNo", -1, (char*const*)&a->_tempuri__LineInventory::BatchNo, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:BarCode", -1, (char*const*)&a->_tempuri__LineInventory::BarCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventory(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventory * SOAP_FMAC4 soap_in__tempuri__LineInventory(struct soap *soap, const char *tag, _tempuri__LineInventory *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventory, sizeof(_tempuri__LineInventory), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventory)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventory *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WorkLineCode1 = 1;
	size_t soap_flag_MCode1 = 1;
	size_t soap_flag_BatchNo1 = 1;
	size_t soap_flag_BarCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WorkLineCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:WorkLineCode", (char**)&a->_tempuri__LineInventory::WorkLineCode, "xsd:string"))
				{	soap_flag_WorkLineCode1--;
					continue;
				}
			}
			if (soap_flag_MCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:MCode", (char**)&a->_tempuri__LineInventory::MCode, "xsd:string"))
				{	soap_flag_MCode1--;
					continue;
				}
			}
			if (soap_flag_BatchNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:BatchNo", (char**)&a->_tempuri__LineInventory::BatchNo, "xsd:string"))
				{	soap_flag_BatchNo1--;
					continue;
				}
			}
			if (soap_flag_BarCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:BarCode", (char**)&a->_tempuri__LineInventory::BarCode, "xsd:string"))
				{	soap_flag_BarCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventory, SOAP_TYPE__tempuri__LineInventory, sizeof(_tempuri__LineInventory), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventory * SOAP_FMAC2 soap_instantiate__tempuri__LineInventory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventory *p;
	size_t k = sizeof(_tempuri__LineInventory);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__LineInventory);
		if (p)
			((_tempuri__LineInventory*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__LineInventory, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__LineInventory*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventory location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__LineInventory, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__LineInventory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventory(soap, tag ? tag : "tempuri:LineInventory", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventory(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventory * SOAP_FMAC4 soap_get__tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__WorkOrderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__WorkOrderResponse::WorkOrderResult);
	/* transient soap skipped */
}

void _tempuri__WorkOrderResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__WorkOrderResponse::WorkOrderResult);
#endif
}

int _tempuri__WorkOrderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__WorkOrderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__WorkOrderResponse(struct soap *soap, const char *tag, int id, const _tempuri__WorkOrderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__WorkOrderResponse), type))
		return soap->error;
	if (a->WorkOrderResult)
		soap_element_result(soap, "tempuri:WorkOrderResult");
	if (soap_out_string(soap, "tempuri:WorkOrderResult", -1, (char*const*)&a->_tempuri__WorkOrderResponse::WorkOrderResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__WorkOrderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__WorkOrderResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__WorkOrderResponse * SOAP_FMAC4 soap_in__tempuri__WorkOrderResponse(struct soap *soap, const char *tag, _tempuri__WorkOrderResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__WorkOrderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__WorkOrderResponse, sizeof(_tempuri__WorkOrderResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__WorkOrderResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__WorkOrderResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WorkOrderResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WorkOrderResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:WorkOrderResult", (char**)&a->_tempuri__WorkOrderResponse::WorkOrderResult, "xsd:string"))
				{	soap_flag_WorkOrderResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:WorkOrderResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__WorkOrderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__WorkOrderResponse, SOAP_TYPE__tempuri__WorkOrderResponse, sizeof(_tempuri__WorkOrderResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__WorkOrderResponse * SOAP_FMAC2 soap_instantiate__tempuri__WorkOrderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__WorkOrderResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__WorkOrderResponse *p;
	size_t k = sizeof(_tempuri__WorkOrderResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__WorkOrderResponse);
		if (p)
			((_tempuri__WorkOrderResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__WorkOrderResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__WorkOrderResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__WorkOrderResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__WorkOrderResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__WorkOrderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__WorkOrderResponse(soap, tag ? tag : "tempuri:WorkOrderResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__WorkOrderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__WorkOrderResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__WorkOrderResponse * SOAP_FMAC4 soap_get__tempuri__WorkOrderResponse(struct soap *soap, _tempuri__WorkOrderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__WorkOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__WorkOrder::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__WorkOrder::WorkOrderXml);
	/* transient soap skipped */
}

void _tempuri__WorkOrder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__WorkOrder::WorkOrderXml);
#endif
}

int _tempuri__WorkOrder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__WorkOrder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__WorkOrder(struct soap *soap, const char *tag, int id, const _tempuri__WorkOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__WorkOrder), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:WorkOrderXml", -1, (char*const*)&a->_tempuri__WorkOrder::WorkOrderXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__WorkOrder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__WorkOrder(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__WorkOrder * SOAP_FMAC4 soap_in__tempuri__WorkOrder(struct soap *soap, const char *tag, _tempuri__WorkOrder *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__WorkOrder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__WorkOrder, sizeof(_tempuri__WorkOrder), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__WorkOrder)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__WorkOrder *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WorkOrderXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WorkOrderXml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:WorkOrderXml", (char**)&a->_tempuri__WorkOrder::WorkOrderXml, "xsd:string"))
				{	soap_flag_WorkOrderXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__WorkOrder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__WorkOrder, SOAP_TYPE__tempuri__WorkOrder, sizeof(_tempuri__WorkOrder), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__WorkOrder * SOAP_FMAC2 soap_instantiate__tempuri__WorkOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__WorkOrder(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__WorkOrder *p;
	size_t k = sizeof(_tempuri__WorkOrder);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__WorkOrder);
		if (p)
			((_tempuri__WorkOrder*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__WorkOrder, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__WorkOrder*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__WorkOrder location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__WorkOrder, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__WorkOrder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__WorkOrder(soap, tag ? tag : "tempuri:WorkOrder", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__WorkOrder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__WorkOrder(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__WorkOrder * SOAP_FMAC4 soap_get__tempuri__WorkOrder(struct soap *soap, _tempuri__WorkOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__WorkOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ToolingTimesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__ToolingTimesResponse::ToolingTimesResult);
	/* transient soap skipped */
}

void _tempuri__ToolingTimesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__ToolingTimesResponse::ToolingTimesResult);
#endif
}

int _tempuri__ToolingTimesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ToolingTimesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ToolingTimesResponse(struct soap *soap, const char *tag, int id, const _tempuri__ToolingTimesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ToolingTimesResponse), type))
		return soap->error;
	if (a->ToolingTimesResult)
		soap_element_result(soap, "tempuri:ToolingTimesResult");
	if (soap_out_string(soap, "tempuri:ToolingTimesResult", -1, (char*const*)&a->_tempuri__ToolingTimesResponse::ToolingTimesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ToolingTimesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__ToolingTimesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ToolingTimesResponse * SOAP_FMAC4 soap_in__tempuri__ToolingTimesResponse(struct soap *soap, const char *tag, _tempuri__ToolingTimesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ToolingTimesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ToolingTimesResponse, sizeof(_tempuri__ToolingTimesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ToolingTimesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ToolingTimesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ToolingTimesResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToolingTimesResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:ToolingTimesResult", (char**)&a->_tempuri__ToolingTimesResponse::ToolingTimesResult, "xsd:string"))
				{	soap_flag_ToolingTimesResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:ToolingTimesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ToolingTimesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ToolingTimesResponse, SOAP_TYPE__tempuri__ToolingTimesResponse, sizeof(_tempuri__ToolingTimesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ToolingTimesResponse * SOAP_FMAC2 soap_instantiate__tempuri__ToolingTimesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ToolingTimesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ToolingTimesResponse *p;
	size_t k = sizeof(_tempuri__ToolingTimesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__ToolingTimesResponse);
		if (p)
			((_tempuri__ToolingTimesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__ToolingTimesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__ToolingTimesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ToolingTimesResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__ToolingTimesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__ToolingTimesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ToolingTimesResponse(soap, tag ? tag : "tempuri:ToolingTimesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ToolingTimesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ToolingTimesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ToolingTimesResponse * SOAP_FMAC4 soap_get__tempuri__ToolingTimesResponse(struct soap *soap, _tempuri__ToolingTimesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ToolingTimesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ToolingTimes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__ToolingTimes::BillCode);
	soap_default_string(soap, &this->_tempuri__ToolingTimes::DeviceCode);
	soap_default_int(soap, &this->_tempuri__ToolingTimes::Times);
	/* transient soap skipped */
}

void _tempuri__ToolingTimes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__ToolingTimes::BillCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__ToolingTimes::DeviceCode);
#endif
}

int _tempuri__ToolingTimes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ToolingTimes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ToolingTimes(struct soap *soap, const char *tag, int id, const _tempuri__ToolingTimes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ToolingTimes), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:BillCode", -1, (char*const*)&a->_tempuri__ToolingTimes::BillCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DeviceCode", -1, (char*const*)&a->_tempuri__ToolingTimes::DeviceCode, ""))
		return soap->error;
	if (soap_out_int(soap, "tempuri:Times", -1, &a->_tempuri__ToolingTimes::Times, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ToolingTimes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__ToolingTimes(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ToolingTimes * SOAP_FMAC4 soap_in__tempuri__ToolingTimes(struct soap *soap, const char *tag, _tempuri__ToolingTimes *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ToolingTimes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ToolingTimes, sizeof(_tempuri__ToolingTimes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ToolingTimes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ToolingTimes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BillCode1 = 1;
	size_t soap_flag_DeviceCode1 = 1;
	size_t soap_flag_Times1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BillCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:BillCode", (char**)&a->_tempuri__ToolingTimes::BillCode, "xsd:string"))
				{	soap_flag_BillCode1--;
					continue;
				}
			}
			if (soap_flag_DeviceCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DeviceCode", (char**)&a->_tempuri__ToolingTimes::DeviceCode, "xsd:string"))
				{	soap_flag_DeviceCode1--;
					continue;
				}
			}
			if (soap_flag_Times1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tempuri:Times", &a->_tempuri__ToolingTimes::Times, "xsd:int"))
				{	soap_flag_Times1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Times1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tempuri__ToolingTimes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ToolingTimes, SOAP_TYPE__tempuri__ToolingTimes, sizeof(_tempuri__ToolingTimes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ToolingTimes * SOAP_FMAC2 soap_instantiate__tempuri__ToolingTimes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ToolingTimes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ToolingTimes *p;
	size_t k = sizeof(_tempuri__ToolingTimes);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__ToolingTimes);
		if (p)
			((_tempuri__ToolingTimes*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__ToolingTimes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__ToolingTimes*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ToolingTimes location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__ToolingTimes, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__ToolingTimes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ToolingTimes(soap, tag ? tag : "tempuri:ToolingTimes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ToolingTimes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ToolingTimes(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ToolingTimes * SOAP_FMAC4 soap_get__tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ToolingTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDocCodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__GetDocCodeResponse::GetDocCodeResult);
	/* transient soap skipped */
}

void _tempuri__GetDocCodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__GetDocCodeResponse::GetDocCodeResult);
#endif
}

int _tempuri__GetDocCodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDocCodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDocCodeResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetDocCodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDocCodeResponse), type))
		return soap->error;
	if (a->GetDocCodeResult)
		soap_element_result(soap, "tempuri:GetDocCodeResult");
	if (soap_out_string(soap, "tempuri:GetDocCodeResult", -1, (char*const*)&a->_tempuri__GetDocCodeResponse::GetDocCodeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDocCodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDocCodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDocCodeResponse * SOAP_FMAC4 soap_in__tempuri__GetDocCodeResponse(struct soap *soap, const char *tag, _tempuri__GetDocCodeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDocCodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDocCodeResponse, sizeof(_tempuri__GetDocCodeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDocCodeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDocCodeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDocCodeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDocCodeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:GetDocCodeResult", (char**)&a->_tempuri__GetDocCodeResponse::GetDocCodeResult, "xsd:string"))
				{	soap_flag_GetDocCodeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetDocCodeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDocCodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDocCodeResponse, SOAP_TYPE__tempuri__GetDocCodeResponse, sizeof(_tempuri__GetDocCodeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDocCodeResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetDocCodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDocCodeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDocCodeResponse *p;
	size_t k = sizeof(_tempuri__GetDocCodeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__GetDocCodeResponse);
		if (p)
			((_tempuri__GetDocCodeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__GetDocCodeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__GetDocCodeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDocCodeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__GetDocCodeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__GetDocCodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDocCodeResponse(soap, tag ? tag : "tempuri:GetDocCodeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDocCodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDocCodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDocCodeResponse * SOAP_FMAC4 soap_get__tempuri__GetDocCodeResponse(struct soap *soap, _tempuri__GetDocCodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDocCodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDocCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__GetDocCode::DocName);
	/* transient soap skipped */
}

void _tempuri__GetDocCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__GetDocCode::DocName);
#endif
}

int _tempuri__GetDocCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDocCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDocCode(struct soap *soap, const char *tag, int id, const _tempuri__GetDocCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDocCode), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DocName", -1, (char*const*)&a->_tempuri__GetDocCode::DocName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDocCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDocCode(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDocCode * SOAP_FMAC4 soap_in__tempuri__GetDocCode(struct soap *soap, const char *tag, _tempuri__GetDocCode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDocCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDocCode, sizeof(_tempuri__GetDocCode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDocCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDocCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DocName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocName", (char**)&a->_tempuri__GetDocCode::DocName, "xsd:string"))
				{	soap_flag_DocName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDocCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDocCode, SOAP_TYPE__tempuri__GetDocCode, sizeof(_tempuri__GetDocCode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDocCode * SOAP_FMAC2 soap_instantiate__tempuri__GetDocCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDocCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDocCode *p;
	size_t k = sizeof(_tempuri__GetDocCode);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__GetDocCode);
		if (p)
			((_tempuri__GetDocCode*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__GetDocCode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__GetDocCode*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDocCode location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__GetDocCode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__GetDocCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDocCode(soap, tag ? tag : "tempuri:GetDocCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDocCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDocCode(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDocCode * SOAP_FMAC4 soap_get__tempuri__GetDocCode(struct soap *soap, _tempuri__GetDocCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDocCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__GetDateResponse::GetDateResult);
	/* transient soap skipped */
}

void _tempuri__GetDateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__GetDateResponse::GetDateResult);
#endif
}

int _tempuri__GetDateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDateResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDateResponse), type))
		return soap->error;
	if (a->GetDateResult)
		soap_element_result(soap, "tempuri:GetDateResult");
	if (soap_out_string(soap, "tempuri:GetDateResult", -1, (char*const*)&a->_tempuri__GetDateResponse::GetDateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDateResponse * SOAP_FMAC4 soap_in__tempuri__GetDateResponse(struct soap *soap, const char *tag, _tempuri__GetDateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDateResponse, sizeof(_tempuri__GetDateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDateResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:GetDateResult", (char**)&a->_tempuri__GetDateResponse::GetDateResult, "xsd:string"))
				{	soap_flag_GetDateResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetDateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDateResponse, SOAP_TYPE__tempuri__GetDateResponse, sizeof(_tempuri__GetDateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDateResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDateResponse *p;
	size_t k = sizeof(_tempuri__GetDateResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__GetDateResponse);
		if (p)
			((_tempuri__GetDateResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__GetDateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__GetDateResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDateResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__GetDateResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__GetDateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDateResponse(soap, tag ? tag : "tempuri:GetDateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDateResponse * SOAP_FMAC4 soap_get__tempuri__GetDateResponse(struct soap *soap, _tempuri__GetDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tempuri__GetDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDate(struct soap *soap, const char *tag, int id, const _tempuri__GetDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDate), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDate(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDate * SOAP_FMAC4 soap_in__tempuri__GetDate(struct soap *soap, const char *tag, _tempuri__GetDate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDate, sizeof(_tempuri__GetDate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDate, SOAP_TYPE__tempuri__GetDate, sizeof(_tempuri__GetDate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDate * SOAP_FMAC2 soap_instantiate__tempuri__GetDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDate *p;
	size_t k = sizeof(_tempuri__GetDate);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__GetDate);
		if (p)
			((_tempuri__GetDate*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__GetDate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__GetDate*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDate location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__GetDate, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__GetDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDate(soap, tag ? tag : "tempuri:GetDate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDate(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDate * SOAP_FMAC4 soap_get__tempuri__GetDate(struct soap *soap, _tempuri__GetDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__Login_(struct soap *soap, struct __tempuri__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__Login_(struct soap *soap, const struct __tempuri__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__Login(soap, &a->tempuri__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__Login_(struct soap *soap, const char *tag, int id, const struct __tempuri__Login_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__Login(soap, "tempuri:Login", -1, &a->tempuri__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__Login_ * SOAP_FMAC4 soap_in___tempuri__Login_(struct soap *soap, const char *tag, struct __tempuri__Login_ *a, const char *type)
{
	size_t soap_flag_tempuri__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__Login_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__Login_, sizeof(struct __tempuri__Login_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__Login_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__Login && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__Login(soap, "tempuri:Login", &a->tempuri__Login, ""))
				{	soap_flag_tempuri__Login--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__Login_ * SOAP_FMAC2 soap_instantiate___tempuri__Login_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__Login_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__Login_ *p;
	size_t k = sizeof(struct __tempuri__Login_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__Login_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__Login_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__Login_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__Login_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__Login_(struct soap *soap, const struct __tempuri__Login_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__Login_(soap, tag ? tag : "-tempuri:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__Login_ * SOAP_FMAC4 soap_get___tempuri__Login_(struct soap *soap, struct __tempuri__Login_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__Login_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetPower_(struct soap *soap, struct __tempuri__GetPower_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetPower = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetPower_(struct soap *soap, const struct __tempuri__GetPower_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetPower(soap, &a->tempuri__GetPower);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetPower_(struct soap *soap, const char *tag, int id, const struct __tempuri__GetPower_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetPower(soap, "tempuri:GetPower", -1, &a->tempuri__GetPower, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetPower_ * SOAP_FMAC4 soap_in___tempuri__GetPower_(struct soap *soap, const char *tag, struct __tempuri__GetPower_ *a, const char *type)
{
	size_t soap_flag_tempuri__GetPower = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetPower_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetPower_, sizeof(struct __tempuri__GetPower_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetPower_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetPower && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetPower(soap, "tempuri:GetPower", &a->tempuri__GetPower, ""))
				{	soap_flag_tempuri__GetPower--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetPower_ * SOAP_FMAC2 soap_instantiate___tempuri__GetPower_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetPower_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetPower_ *p;
	size_t k = sizeof(struct __tempuri__GetPower_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__GetPower_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__GetPower_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetPower_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__GetPower_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetPower_(struct soap *soap, const struct __tempuri__GetPower_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetPower_(soap, tag ? tag : "-tempuri:GetPower", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetPower_ * SOAP_FMAC4 soap_get___tempuri__GetPower_(struct soap *soap, struct __tempuri__GetPower_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetPower_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDept_(struct soap *soap, struct __tempuri__GetDept_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDept = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDept_(struct soap *soap, const struct __tempuri__GetDept_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDept(soap, &a->tempuri__GetDept);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDept_(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDept_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDept(soap, "tempuri:GetDept", -1, &a->tempuri__GetDept, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDept_ * SOAP_FMAC4 soap_in___tempuri__GetDept_(struct soap *soap, const char *tag, struct __tempuri__GetDept_ *a, const char *type)
{
	size_t soap_flag_tempuri__GetDept = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDept_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDept_, sizeof(struct __tempuri__GetDept_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDept_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDept && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDept(soap, "tempuri:GetDept", &a->tempuri__GetDept, ""))
				{	soap_flag_tempuri__GetDept--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDept_ * SOAP_FMAC2 soap_instantiate___tempuri__GetDept_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDept_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDept_ *p;
	size_t k = sizeof(struct __tempuri__GetDept_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__GetDept_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__GetDept_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDept_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__GetDept_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDept_(struct soap *soap, const struct __tempuri__GetDept_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDept_(soap, tag ? tag : "-tempuri:GetDept", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDept_ * SOAP_FMAC4 soap_get___tempuri__GetDept_(struct soap *soap, struct __tempuri__GetDept_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDept_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__SetExMail_(struct soap *soap, struct __tempuri__SetExMail_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__SetExMail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__SetExMail_(struct soap *soap, const struct __tempuri__SetExMail_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__SetExMail(soap, &a->tempuri__SetExMail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__SetExMail_(struct soap *soap, const char *tag, int id, const struct __tempuri__SetExMail_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__SetExMail(soap, "tempuri:SetExMail", -1, &a->tempuri__SetExMail, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__SetExMail_ * SOAP_FMAC4 soap_in___tempuri__SetExMail_(struct soap *soap, const char *tag, struct __tempuri__SetExMail_ *a, const char *type)
{
	size_t soap_flag_tempuri__SetExMail = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__SetExMail_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__SetExMail_, sizeof(struct __tempuri__SetExMail_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__SetExMail_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__SetExMail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__SetExMail(soap, "tempuri:SetExMail", &a->tempuri__SetExMail, ""))
				{	soap_flag_tempuri__SetExMail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__SetExMail_ * SOAP_FMAC2 soap_instantiate___tempuri__SetExMail_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__SetExMail_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__SetExMail_ *p;
	size_t k = sizeof(struct __tempuri__SetExMail_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__SetExMail_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__SetExMail_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__SetExMail_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__SetExMail_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__SetExMail_(struct soap *soap, const struct __tempuri__SetExMail_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__SetExMail_(soap, tag ? tag : "-tempuri:SetExMail", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__SetExMail_ * SOAP_FMAC4 soap_get___tempuri__SetExMail_(struct soap *soap, struct __tempuri__SetExMail_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__SetExMail_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__DocAdd_(struct soap *soap, struct __tempuri__DocAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__DocAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__DocAdd_(struct soap *soap, const struct __tempuri__DocAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__DocAdd(soap, &a->tempuri__DocAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__DocAdd_(struct soap *soap, const char *tag, int id, const struct __tempuri__DocAdd_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", -1, &a->tempuri__DocAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd_ * SOAP_FMAC4 soap_in___tempuri__DocAdd_(struct soap *soap, const char *tag, struct __tempuri__DocAdd_ *a, const char *type)
{
	size_t soap_flag_tempuri__DocAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__DocAdd_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__DocAdd_, sizeof(struct __tempuri__DocAdd_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__DocAdd_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__DocAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", &a->tempuri__DocAdd, ""))
				{	soap_flag_tempuri__DocAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__DocAdd_ * SOAP_FMAC2 soap_instantiate___tempuri__DocAdd_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__DocAdd_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__DocAdd_ *p;
	size_t k = sizeof(struct __tempuri__DocAdd_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__DocAdd_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__DocAdd_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__DocAdd_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__DocAdd_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__DocAdd_(struct soap *soap, const struct __tempuri__DocAdd_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__DocAdd_(soap, tag ? tag : "-tempuri:DocAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd_ * SOAP_FMAC4 soap_get___tempuri__DocAdd_(struct soap *soap, struct __tempuri__DocAdd_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__DocAdd_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__ItemsAdd_(struct soap *soap, struct __tempuri__ItemsAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ItemsAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__ItemsAdd_(struct soap *soap, const struct __tempuri__ItemsAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ItemsAdd(soap, &a->tempuri__ItemsAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__ItemsAdd_(struct soap *soap, const char *tag, int id, const struct __tempuri__ItemsAdd_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ItemsAdd(soap, "tempuri:ItemsAdd", -1, &a->tempuri__ItemsAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ItemsAdd_ * SOAP_FMAC4 soap_in___tempuri__ItemsAdd_(struct soap *soap, const char *tag, struct __tempuri__ItemsAdd_ *a, const char *type)
{
	size_t soap_flag_tempuri__ItemsAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__ItemsAdd_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__ItemsAdd_, sizeof(struct __tempuri__ItemsAdd_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__ItemsAdd_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ItemsAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ItemsAdd(soap, "tempuri:ItemsAdd", &a->tempuri__ItemsAdd, ""))
				{	soap_flag_tempuri__ItemsAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__ItemsAdd_ * SOAP_FMAC2 soap_instantiate___tempuri__ItemsAdd_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__ItemsAdd_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__ItemsAdd_ *p;
	size_t k = sizeof(struct __tempuri__ItemsAdd_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__ItemsAdd_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__ItemsAdd_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__ItemsAdd_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__ItemsAdd_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__ItemsAdd_(struct soap *soap, const struct __tempuri__ItemsAdd_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__ItemsAdd_(soap, tag ? tag : "-tempuri:ItemsAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ItemsAdd_ * SOAP_FMAC4 soap_get___tempuri__ItemsAdd_(struct soap *soap, struct __tempuri__ItemsAdd_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__ItemsAdd_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDonTest_(struct soap *soap, struct __tempuri__AnDonTest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDonTest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDonTest_(struct soap *soap, const struct __tempuri__AnDonTest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDonTest(soap, &a->tempuri__AnDonTest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDonTest_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDonTest_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDonTest(soap, "tempuri:AnDonTest", -1, &a->tempuri__AnDonTest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonTest_ * SOAP_FMAC4 soap_in___tempuri__AnDonTest_(struct soap *soap, const char *tag, struct __tempuri__AnDonTest_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDonTest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDonTest_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDonTest_, sizeof(struct __tempuri__AnDonTest_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDonTest_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDonTest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDonTest(soap, "tempuri:AnDonTest", &a->tempuri__AnDonTest, ""))
				{	soap_flag_tempuri__AnDonTest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDonTest_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDonTest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDonTest_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDonTest_ *p;
	size_t k = sizeof(struct __tempuri__AnDonTest_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDonTest_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDonTest_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDonTest_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDonTest_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDonTest_(struct soap *soap, const struct __tempuri__AnDonTest_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDonTest_(soap, tag ? tag : "-tempuri:AnDonTest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonTest_ * SOAP_FMAC4 soap_get___tempuri__AnDonTest_(struct soap *soap, struct __tempuri__AnDonTest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDonTest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDonCall_(struct soap *soap, struct __tempuri__AnDonCall_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDonCall = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDonCall_(struct soap *soap, const struct __tempuri__AnDonCall_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDonCall(soap, &a->tempuri__AnDonCall);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDonCall_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDonCall_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDonCall(soap, "tempuri:AnDonCall", -1, &a->tempuri__AnDonCall, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonCall_ * SOAP_FMAC4 soap_in___tempuri__AnDonCall_(struct soap *soap, const char *tag, struct __tempuri__AnDonCall_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDonCall = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDonCall_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDonCall_, sizeof(struct __tempuri__AnDonCall_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDonCall_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDonCall && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDonCall(soap, "tempuri:AnDonCall", &a->tempuri__AnDonCall, ""))
				{	soap_flag_tempuri__AnDonCall--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDonCall_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDonCall_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDonCall_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDonCall_ *p;
	size_t k = sizeof(struct __tempuri__AnDonCall_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDonCall_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDonCall_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDonCall_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDonCall_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDonCall_(struct soap *soap, const struct __tempuri__AnDonCall_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDonCall_(soap, tag ? tag : "-tempuri:AnDonCall", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonCall_ * SOAP_FMAC4 soap_get___tempuri__AnDonCall_(struct soap *soap, struct __tempuri__AnDonCall_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDonCall_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDon_(struct soap *soap, struct __tempuri__AnDon_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDon = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDon_(struct soap *soap, const struct __tempuri__AnDon_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDon(soap, &a->tempuri__AnDon);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDon_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDon_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDon(soap, "tempuri:AnDon", -1, &a->tempuri__AnDon, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDon_ * SOAP_FMAC4 soap_in___tempuri__AnDon_(struct soap *soap, const char *tag, struct __tempuri__AnDon_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDon = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDon_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDon_, sizeof(struct __tempuri__AnDon_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDon_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDon && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDon(soap, "tempuri:AnDon", &a->tempuri__AnDon, ""))
				{	soap_flag_tempuri__AnDon--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDon_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDon_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDon_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDon_ *p;
	size_t k = sizeof(struct __tempuri__AnDon_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDon_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDon_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDon_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDon_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDon_(struct soap *soap, const struct __tempuri__AnDon_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDon_(soap, tag ? tag : "-tempuri:AnDon", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDon_ * SOAP_FMAC4 soap_get___tempuri__AnDon_(struct soap *soap, struct __tempuri__AnDon_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDon_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventoryReturn_(struct soap *soap, struct __tempuri__LineInventoryReturn_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventoryReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventoryReturn_(struct soap *soap, const struct __tempuri__LineInventoryReturn_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventoryReturn(soap, &a->tempuri__LineInventoryReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventoryReturn_(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventoryReturn_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventoryReturn(soap, "tempuri:LineInventoryReturn", -1, &a->tempuri__LineInventoryReturn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryReturn_ * SOAP_FMAC4 soap_in___tempuri__LineInventoryReturn_(struct soap *soap, const char *tag, struct __tempuri__LineInventoryReturn_ *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventoryReturn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventoryReturn_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventoryReturn_, sizeof(struct __tempuri__LineInventoryReturn_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventoryReturn_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventoryReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventoryReturn(soap, "tempuri:LineInventoryReturn", &a->tempuri__LineInventoryReturn, ""))
				{	soap_flag_tempuri__LineInventoryReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventoryReturn_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryReturn_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventoryReturn_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventoryReturn_ *p;
	size_t k = sizeof(struct __tempuri__LineInventoryReturn_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__LineInventoryReturn_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__LineInventoryReturn_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventoryReturn_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__LineInventoryReturn_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventoryReturn_(struct soap *soap, const struct __tempuri__LineInventoryReturn_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventoryReturn_(soap, tag ? tag : "-tempuri:LineInventoryReturn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryReturn_ * SOAP_FMAC4 soap_get___tempuri__LineInventoryReturn_(struct soap *soap, struct __tempuri__LineInventoryReturn_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventoryReturn_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventoryUpdate_(struct soap *soap, struct __tempuri__LineInventoryUpdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventoryUpdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventoryUpdate_(struct soap *soap, const struct __tempuri__LineInventoryUpdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventoryUpdate(soap, &a->tempuri__LineInventoryUpdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventoryUpdate_(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventoryUpdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventoryUpdate(soap, "tempuri:LineInventoryUpdate", -1, &a->tempuri__LineInventoryUpdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryUpdate_ * SOAP_FMAC4 soap_in___tempuri__LineInventoryUpdate_(struct soap *soap, const char *tag, struct __tempuri__LineInventoryUpdate_ *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventoryUpdate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventoryUpdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventoryUpdate_, sizeof(struct __tempuri__LineInventoryUpdate_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventoryUpdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventoryUpdate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventoryUpdate(soap, "tempuri:LineInventoryUpdate", &a->tempuri__LineInventoryUpdate, ""))
				{	soap_flag_tempuri__LineInventoryUpdate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventoryUpdate_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryUpdate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventoryUpdate_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventoryUpdate_ *p;
	size_t k = sizeof(struct __tempuri__LineInventoryUpdate_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__LineInventoryUpdate_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__LineInventoryUpdate_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventoryUpdate_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__LineInventoryUpdate_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventoryUpdate_(struct soap *soap, const struct __tempuri__LineInventoryUpdate_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventoryUpdate_(soap, tag ? tag : "-tempuri:LineInventoryUpdate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryUpdate_ * SOAP_FMAC4 soap_get___tempuri__LineInventoryUpdate_(struct soap *soap, struct __tempuri__LineInventoryUpdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventoryUpdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventory_(struct soap *soap, struct __tempuri__LineInventory_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventory_(struct soap *soap, const struct __tempuri__LineInventory_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventory(soap, &a->tempuri__LineInventory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventory_(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventory_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", -1, &a->tempuri__LineInventory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory_ * SOAP_FMAC4 soap_in___tempuri__LineInventory_(struct soap *soap, const char *tag, struct __tempuri__LineInventory_ *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventory = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventory_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventory_, sizeof(struct __tempuri__LineInventory_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventory_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventory && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", &a->tempuri__LineInventory, ""))
				{	soap_flag_tempuri__LineInventory--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventory_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventory_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventory_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventory_ *p;
	size_t k = sizeof(struct __tempuri__LineInventory_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__LineInventory_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__LineInventory_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventory_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__LineInventory_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventory_(struct soap *soap, const struct __tempuri__LineInventory_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventory_(soap, tag ? tag : "-tempuri:LineInventory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory_ * SOAP_FMAC4 soap_get___tempuri__LineInventory_(struct soap *soap, struct __tempuri__LineInventory_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventory_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__WorkOrder_(struct soap *soap, struct __tempuri__WorkOrder_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__WorkOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__WorkOrder_(struct soap *soap, const struct __tempuri__WorkOrder_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__WorkOrder(soap, &a->tempuri__WorkOrder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__WorkOrder_(struct soap *soap, const char *tag, int id, const struct __tempuri__WorkOrder_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__WorkOrder(soap, "tempuri:WorkOrder", -1, &a->tempuri__WorkOrder, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__WorkOrder_ * SOAP_FMAC4 soap_in___tempuri__WorkOrder_(struct soap *soap, const char *tag, struct __tempuri__WorkOrder_ *a, const char *type)
{
	size_t soap_flag_tempuri__WorkOrder = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__WorkOrder_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__WorkOrder_, sizeof(struct __tempuri__WorkOrder_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__WorkOrder_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__WorkOrder && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__WorkOrder(soap, "tempuri:WorkOrder", &a->tempuri__WorkOrder, ""))
				{	soap_flag_tempuri__WorkOrder--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__WorkOrder_ * SOAP_FMAC2 soap_instantiate___tempuri__WorkOrder_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__WorkOrder_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__WorkOrder_ *p;
	size_t k = sizeof(struct __tempuri__WorkOrder_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__WorkOrder_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__WorkOrder_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__WorkOrder_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__WorkOrder_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__WorkOrder_(struct soap *soap, const struct __tempuri__WorkOrder_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__WorkOrder_(soap, tag ? tag : "-tempuri:WorkOrder", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__WorkOrder_ * SOAP_FMAC4 soap_get___tempuri__WorkOrder_(struct soap *soap, struct __tempuri__WorkOrder_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__WorkOrder_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__ToolingTimes_(struct soap *soap, struct __tempuri__ToolingTimes_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ToolingTimes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__ToolingTimes_(struct soap *soap, const struct __tempuri__ToolingTimes_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ToolingTimes(soap, &a->tempuri__ToolingTimes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__ToolingTimes_(struct soap *soap, const char *tag, int id, const struct __tempuri__ToolingTimes_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", -1, &a->tempuri__ToolingTimes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes_ * SOAP_FMAC4 soap_in___tempuri__ToolingTimes_(struct soap *soap, const char *tag, struct __tempuri__ToolingTimes_ *a, const char *type)
{
	size_t soap_flag_tempuri__ToolingTimes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__ToolingTimes_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__ToolingTimes_, sizeof(struct __tempuri__ToolingTimes_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__ToolingTimes_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ToolingTimes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", &a->tempuri__ToolingTimes, ""))
				{	soap_flag_tempuri__ToolingTimes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__ToolingTimes_ * SOAP_FMAC2 soap_instantiate___tempuri__ToolingTimes_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__ToolingTimes_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__ToolingTimes_ *p;
	size_t k = sizeof(struct __tempuri__ToolingTimes_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__ToolingTimes_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__ToolingTimes_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__ToolingTimes_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__ToolingTimes_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__ToolingTimes_(struct soap *soap, const struct __tempuri__ToolingTimes_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__ToolingTimes_(soap, tag ? tag : "-tempuri:ToolingTimes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes_ * SOAP_FMAC4 soap_get___tempuri__ToolingTimes_(struct soap *soap, struct __tempuri__ToolingTimes_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__ToolingTimes_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDocCode_(struct soap *soap, struct __tempuri__GetDocCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDocCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDocCode_(struct soap *soap, const struct __tempuri__GetDocCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDocCode(soap, &a->tempuri__GetDocCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDocCode_(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDocCode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDocCode(soap, "tempuri:GetDocCode", -1, &a->tempuri__GetDocCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDocCode_ * SOAP_FMAC4 soap_in___tempuri__GetDocCode_(struct soap *soap, const char *tag, struct __tempuri__GetDocCode_ *a, const char *type)
{
	size_t soap_flag_tempuri__GetDocCode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDocCode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDocCode_, sizeof(struct __tempuri__GetDocCode_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDocCode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDocCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDocCode(soap, "tempuri:GetDocCode", &a->tempuri__GetDocCode, ""))
				{	soap_flag_tempuri__GetDocCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDocCode_ * SOAP_FMAC2 soap_instantiate___tempuri__GetDocCode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDocCode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDocCode_ *p;
	size_t k = sizeof(struct __tempuri__GetDocCode_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__GetDocCode_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__GetDocCode_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDocCode_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__GetDocCode_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDocCode_(struct soap *soap, const struct __tempuri__GetDocCode_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDocCode_(soap, tag ? tag : "-tempuri:GetDocCode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDocCode_ * SOAP_FMAC4 soap_get___tempuri__GetDocCode_(struct soap *soap, struct __tempuri__GetDocCode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDocCode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDate_(struct soap *soap, struct __tempuri__GetDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDate_(struct soap *soap, const struct __tempuri__GetDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDate(soap, &a->tempuri__GetDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDate_(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDate(soap, "tempuri:GetDate", -1, &a->tempuri__GetDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDate_ * SOAP_FMAC4 soap_in___tempuri__GetDate_(struct soap *soap, const char *tag, struct __tempuri__GetDate_ *a, const char *type)
{
	size_t soap_flag_tempuri__GetDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDate_, sizeof(struct __tempuri__GetDate_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDate(soap, "tempuri:GetDate", &a->tempuri__GetDate, ""))
				{	soap_flag_tempuri__GetDate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDate_ * SOAP_FMAC2 soap_instantiate___tempuri__GetDate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDate_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDate_ *p;
	size_t k = sizeof(struct __tempuri__GetDate_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__GetDate_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__GetDate_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDate_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__GetDate_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDate_(struct soap *soap, const struct __tempuri__GetDate_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDate_(soap, tag ? tag : "-tempuri:GetDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDate_ * SOAP_FMAC4 soap_get___tempuri__GetDate_(struct soap *soap, struct __tempuri__GetDate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__Login(struct soap *soap, struct __tempuri__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__Login(struct soap *soap, const struct __tempuri__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__Login(soap, &a->tempuri__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__Login(struct soap *soap, const char *tag, int id, const struct __tempuri__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__Login(soap, "tempuri:Login", -1, &a->tempuri__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__Login * SOAP_FMAC4 soap_in___tempuri__Login(struct soap *soap, const char *tag, struct __tempuri__Login *a, const char *type)
{
	size_t soap_flag_tempuri__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__Login *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__Login, sizeof(struct __tempuri__Login), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__Login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__Login && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__Login(soap, "tempuri:Login", &a->tempuri__Login, ""))
				{	soap_flag_tempuri__Login--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__Login * SOAP_FMAC2 soap_instantiate___tempuri__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__Login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__Login *p;
	size_t k = sizeof(struct __tempuri__Login);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__Login);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__Login, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__Login location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__Login, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__Login(struct soap *soap, const struct __tempuri__Login *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__Login(soap, tag ? tag : "-tempuri:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__Login * SOAP_FMAC4 soap_get___tempuri__Login(struct soap *soap, struct __tempuri__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetPower(struct soap *soap, struct __tempuri__GetPower *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetPower = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetPower(struct soap *soap, const struct __tempuri__GetPower *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetPower(soap, &a->tempuri__GetPower);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetPower(struct soap *soap, const char *tag, int id, const struct __tempuri__GetPower *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetPower(soap, "tempuri:GetPower", -1, &a->tempuri__GetPower, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetPower * SOAP_FMAC4 soap_in___tempuri__GetPower(struct soap *soap, const char *tag, struct __tempuri__GetPower *a, const char *type)
{
	size_t soap_flag_tempuri__GetPower = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetPower *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetPower, sizeof(struct __tempuri__GetPower), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetPower(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetPower && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetPower(soap, "tempuri:GetPower", &a->tempuri__GetPower, ""))
				{	soap_flag_tempuri__GetPower--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetPower * SOAP_FMAC2 soap_instantiate___tempuri__GetPower(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetPower(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetPower *p;
	size_t k = sizeof(struct __tempuri__GetPower);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__GetPower);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__GetPower, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetPower location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__GetPower, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetPower(struct soap *soap, const struct __tempuri__GetPower *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetPower(soap, tag ? tag : "-tempuri:GetPower", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetPower * SOAP_FMAC4 soap_get___tempuri__GetPower(struct soap *soap, struct __tempuri__GetPower *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetPower(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDept(struct soap *soap, struct __tempuri__GetDept *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDept = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDept(struct soap *soap, const struct __tempuri__GetDept *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDept(soap, &a->tempuri__GetDept);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDept(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDept *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDept(soap, "tempuri:GetDept", -1, &a->tempuri__GetDept, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDept * SOAP_FMAC4 soap_in___tempuri__GetDept(struct soap *soap, const char *tag, struct __tempuri__GetDept *a, const char *type)
{
	size_t soap_flag_tempuri__GetDept = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDept *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDept, sizeof(struct __tempuri__GetDept), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDept(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDept && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDept(soap, "tempuri:GetDept", &a->tempuri__GetDept, ""))
				{	soap_flag_tempuri__GetDept--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDept * SOAP_FMAC2 soap_instantiate___tempuri__GetDept(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDept(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDept *p;
	size_t k = sizeof(struct __tempuri__GetDept);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__GetDept);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__GetDept, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDept location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__GetDept, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDept(struct soap *soap, const struct __tempuri__GetDept *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDept(soap, tag ? tag : "-tempuri:GetDept", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDept * SOAP_FMAC4 soap_get___tempuri__GetDept(struct soap *soap, struct __tempuri__GetDept *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDept(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__SetExMail(struct soap *soap, struct __tempuri__SetExMail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__SetExMail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__SetExMail(struct soap *soap, const struct __tempuri__SetExMail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__SetExMail(soap, &a->tempuri__SetExMail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__SetExMail(struct soap *soap, const char *tag, int id, const struct __tempuri__SetExMail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__SetExMail(soap, "tempuri:SetExMail", -1, &a->tempuri__SetExMail, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__SetExMail * SOAP_FMAC4 soap_in___tempuri__SetExMail(struct soap *soap, const char *tag, struct __tempuri__SetExMail *a, const char *type)
{
	size_t soap_flag_tempuri__SetExMail = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__SetExMail *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__SetExMail, sizeof(struct __tempuri__SetExMail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__SetExMail(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__SetExMail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__SetExMail(soap, "tempuri:SetExMail", &a->tempuri__SetExMail, ""))
				{	soap_flag_tempuri__SetExMail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__SetExMail * SOAP_FMAC2 soap_instantiate___tempuri__SetExMail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__SetExMail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__SetExMail *p;
	size_t k = sizeof(struct __tempuri__SetExMail);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__SetExMail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__SetExMail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__SetExMail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__SetExMail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__SetExMail(struct soap *soap, const struct __tempuri__SetExMail *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__SetExMail(soap, tag ? tag : "-tempuri:SetExMail", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__SetExMail * SOAP_FMAC4 soap_get___tempuri__SetExMail(struct soap *soap, struct __tempuri__SetExMail *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__SetExMail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__DocAdd(struct soap *soap, struct __tempuri__DocAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__DocAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__DocAdd(struct soap *soap, const struct __tempuri__DocAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__DocAdd(soap, &a->tempuri__DocAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__DocAdd(struct soap *soap, const char *tag, int id, const struct __tempuri__DocAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", -1, &a->tempuri__DocAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd * SOAP_FMAC4 soap_in___tempuri__DocAdd(struct soap *soap, const char *tag, struct __tempuri__DocAdd *a, const char *type)
{
	size_t soap_flag_tempuri__DocAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__DocAdd *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__DocAdd, sizeof(struct __tempuri__DocAdd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__DocAdd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__DocAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", &a->tempuri__DocAdd, ""))
				{	soap_flag_tempuri__DocAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__DocAdd * SOAP_FMAC2 soap_instantiate___tempuri__DocAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__DocAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__DocAdd *p;
	size_t k = sizeof(struct __tempuri__DocAdd);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__DocAdd);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__DocAdd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__DocAdd location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__DocAdd, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__DocAdd(struct soap *soap, const struct __tempuri__DocAdd *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__DocAdd(soap, tag ? tag : "-tempuri:DocAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd * SOAP_FMAC4 soap_get___tempuri__DocAdd(struct soap *soap, struct __tempuri__DocAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__DocAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__ItemsAdd(struct soap *soap, struct __tempuri__ItemsAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ItemsAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__ItemsAdd(struct soap *soap, const struct __tempuri__ItemsAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ItemsAdd(soap, &a->tempuri__ItemsAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__ItemsAdd(struct soap *soap, const char *tag, int id, const struct __tempuri__ItemsAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ItemsAdd(soap, "tempuri:ItemsAdd", -1, &a->tempuri__ItemsAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ItemsAdd * SOAP_FMAC4 soap_in___tempuri__ItemsAdd(struct soap *soap, const char *tag, struct __tempuri__ItemsAdd *a, const char *type)
{
	size_t soap_flag_tempuri__ItemsAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__ItemsAdd *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__ItemsAdd, sizeof(struct __tempuri__ItemsAdd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__ItemsAdd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ItemsAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ItemsAdd(soap, "tempuri:ItemsAdd", &a->tempuri__ItemsAdd, ""))
				{	soap_flag_tempuri__ItemsAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__ItemsAdd * SOAP_FMAC2 soap_instantiate___tempuri__ItemsAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__ItemsAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__ItemsAdd *p;
	size_t k = sizeof(struct __tempuri__ItemsAdd);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__ItemsAdd);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__ItemsAdd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__ItemsAdd location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__ItemsAdd, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__ItemsAdd(struct soap *soap, const struct __tempuri__ItemsAdd *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__ItemsAdd(soap, tag ? tag : "-tempuri:ItemsAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ItemsAdd * SOAP_FMAC4 soap_get___tempuri__ItemsAdd(struct soap *soap, struct __tempuri__ItemsAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__ItemsAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDonTest(struct soap *soap, struct __tempuri__AnDonTest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDonTest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDonTest(struct soap *soap, const struct __tempuri__AnDonTest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDonTest(soap, &a->tempuri__AnDonTest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDonTest(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDonTest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDonTest(soap, "tempuri:AnDonTest", -1, &a->tempuri__AnDonTest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonTest * SOAP_FMAC4 soap_in___tempuri__AnDonTest(struct soap *soap, const char *tag, struct __tempuri__AnDonTest *a, const char *type)
{
	size_t soap_flag_tempuri__AnDonTest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDonTest *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDonTest, sizeof(struct __tempuri__AnDonTest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDonTest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDonTest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDonTest(soap, "tempuri:AnDonTest", &a->tempuri__AnDonTest, ""))
				{	soap_flag_tempuri__AnDonTest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDonTest * SOAP_FMAC2 soap_instantiate___tempuri__AnDonTest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDonTest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDonTest *p;
	size_t k = sizeof(struct __tempuri__AnDonTest);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDonTest);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDonTest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDonTest location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDonTest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDonTest(struct soap *soap, const struct __tempuri__AnDonTest *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDonTest(soap, tag ? tag : "-tempuri:AnDonTest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonTest * SOAP_FMAC4 soap_get___tempuri__AnDonTest(struct soap *soap, struct __tempuri__AnDonTest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDonTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDonCall(struct soap *soap, struct __tempuri__AnDonCall *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDonCall = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDonCall(struct soap *soap, const struct __tempuri__AnDonCall *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDonCall(soap, &a->tempuri__AnDonCall);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDonCall(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDonCall *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDonCall(soap, "tempuri:AnDonCall", -1, &a->tempuri__AnDonCall, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonCall * SOAP_FMAC4 soap_in___tempuri__AnDonCall(struct soap *soap, const char *tag, struct __tempuri__AnDonCall *a, const char *type)
{
	size_t soap_flag_tempuri__AnDonCall = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDonCall *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDonCall, sizeof(struct __tempuri__AnDonCall), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDonCall(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDonCall && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDonCall(soap, "tempuri:AnDonCall", &a->tempuri__AnDonCall, ""))
				{	soap_flag_tempuri__AnDonCall--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDonCall * SOAP_FMAC2 soap_instantiate___tempuri__AnDonCall(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDonCall(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDonCall *p;
	size_t k = sizeof(struct __tempuri__AnDonCall);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDonCall);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDonCall, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDonCall location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDonCall, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDonCall(struct soap *soap, const struct __tempuri__AnDonCall *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDonCall(soap, tag ? tag : "-tempuri:AnDonCall", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonCall * SOAP_FMAC4 soap_get___tempuri__AnDonCall(struct soap *soap, struct __tempuri__AnDonCall *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDonCall(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDon(struct soap *soap, struct __tempuri__AnDon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDon = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDon(struct soap *soap, const struct __tempuri__AnDon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDon(soap, &a->tempuri__AnDon);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDon(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDon *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDon(soap, "tempuri:AnDon", -1, &a->tempuri__AnDon, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDon * SOAP_FMAC4 soap_in___tempuri__AnDon(struct soap *soap, const char *tag, struct __tempuri__AnDon *a, const char *type)
{
	size_t soap_flag_tempuri__AnDon = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDon *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDon, sizeof(struct __tempuri__AnDon), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDon(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDon && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDon(soap, "tempuri:AnDon", &a->tempuri__AnDon, ""))
				{	soap_flag_tempuri__AnDon--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDon * SOAP_FMAC2 soap_instantiate___tempuri__AnDon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDon(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDon *p;
	size_t k = sizeof(struct __tempuri__AnDon);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDon);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDon, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDon location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDon, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDon(struct soap *soap, const struct __tempuri__AnDon *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDon(soap, tag ? tag : "-tempuri:AnDon", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDon * SOAP_FMAC4 soap_get___tempuri__AnDon(struct soap *soap, struct __tempuri__AnDon *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventoryReturn(struct soap *soap, struct __tempuri__LineInventoryReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventoryReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventoryReturn(struct soap *soap, const struct __tempuri__LineInventoryReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventoryReturn(soap, &a->tempuri__LineInventoryReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventoryReturn(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventoryReturn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventoryReturn(soap, "tempuri:LineInventoryReturn", -1, &a->tempuri__LineInventoryReturn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryReturn * SOAP_FMAC4 soap_in___tempuri__LineInventoryReturn(struct soap *soap, const char *tag, struct __tempuri__LineInventoryReturn *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventoryReturn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventoryReturn *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventoryReturn, sizeof(struct __tempuri__LineInventoryReturn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventoryReturn(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventoryReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventoryReturn(soap, "tempuri:LineInventoryReturn", &a->tempuri__LineInventoryReturn, ""))
				{	soap_flag_tempuri__LineInventoryReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventoryReturn * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryReturn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventoryReturn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventoryReturn *p;
	size_t k = sizeof(struct __tempuri__LineInventoryReturn);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__LineInventoryReturn);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__LineInventoryReturn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventoryReturn location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__LineInventoryReturn, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventoryReturn(struct soap *soap, const struct __tempuri__LineInventoryReturn *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventoryReturn(soap, tag ? tag : "-tempuri:LineInventoryReturn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryReturn * SOAP_FMAC4 soap_get___tempuri__LineInventoryReturn(struct soap *soap, struct __tempuri__LineInventoryReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventoryReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventoryUpdate(struct soap *soap, struct __tempuri__LineInventoryUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventoryUpdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventoryUpdate(struct soap *soap, const struct __tempuri__LineInventoryUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventoryUpdate(soap, &a->tempuri__LineInventoryUpdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventoryUpdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventoryUpdate(soap, "tempuri:LineInventoryUpdate", -1, &a->tempuri__LineInventoryUpdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryUpdate * SOAP_FMAC4 soap_in___tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, struct __tempuri__LineInventoryUpdate *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventoryUpdate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventoryUpdate *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventoryUpdate, sizeof(struct __tempuri__LineInventoryUpdate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventoryUpdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventoryUpdate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventoryUpdate(soap, "tempuri:LineInventoryUpdate", &a->tempuri__LineInventoryUpdate, ""))
				{	soap_flag_tempuri__LineInventoryUpdate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventoryUpdate * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryUpdate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventoryUpdate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventoryUpdate *p;
	size_t k = sizeof(struct __tempuri__LineInventoryUpdate);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__LineInventoryUpdate);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__LineInventoryUpdate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventoryUpdate location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__LineInventoryUpdate, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventoryUpdate(struct soap *soap, const struct __tempuri__LineInventoryUpdate *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventoryUpdate(soap, tag ? tag : "-tempuri:LineInventoryUpdate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryUpdate * SOAP_FMAC4 soap_get___tempuri__LineInventoryUpdate(struct soap *soap, struct __tempuri__LineInventoryUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventoryUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventory(struct soap *soap, struct __tempuri__LineInventory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventory(struct soap *soap, const struct __tempuri__LineInventory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventory(soap, &a->tempuri__LineInventory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventory(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", -1, &a->tempuri__LineInventory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory * SOAP_FMAC4 soap_in___tempuri__LineInventory(struct soap *soap, const char *tag, struct __tempuri__LineInventory *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventory = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventory *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventory, sizeof(struct __tempuri__LineInventory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventory && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", &a->tempuri__LineInventory, ""))
				{	soap_flag_tempuri__LineInventory--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventory * SOAP_FMAC2 soap_instantiate___tempuri__LineInventory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventory *p;
	size_t k = sizeof(struct __tempuri__LineInventory);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__LineInventory);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__LineInventory, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventory location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__LineInventory, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventory(struct soap *soap, const struct __tempuri__LineInventory *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventory(soap, tag ? tag : "-tempuri:LineInventory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory * SOAP_FMAC4 soap_get___tempuri__LineInventory(struct soap *soap, struct __tempuri__LineInventory *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__WorkOrder(struct soap *soap, struct __tempuri__WorkOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__WorkOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__WorkOrder(struct soap *soap, const struct __tempuri__WorkOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__WorkOrder(soap, &a->tempuri__WorkOrder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__WorkOrder(struct soap *soap, const char *tag, int id, const struct __tempuri__WorkOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__WorkOrder(soap, "tempuri:WorkOrder", -1, &a->tempuri__WorkOrder, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__WorkOrder * SOAP_FMAC4 soap_in___tempuri__WorkOrder(struct soap *soap, const char *tag, struct __tempuri__WorkOrder *a, const char *type)
{
	size_t soap_flag_tempuri__WorkOrder = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__WorkOrder *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__WorkOrder, sizeof(struct __tempuri__WorkOrder), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__WorkOrder(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__WorkOrder && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__WorkOrder(soap, "tempuri:WorkOrder", &a->tempuri__WorkOrder, ""))
				{	soap_flag_tempuri__WorkOrder--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__WorkOrder * SOAP_FMAC2 soap_instantiate___tempuri__WorkOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__WorkOrder(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__WorkOrder *p;
	size_t k = sizeof(struct __tempuri__WorkOrder);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__WorkOrder);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__WorkOrder, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__WorkOrder location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__WorkOrder, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__WorkOrder(struct soap *soap, const struct __tempuri__WorkOrder *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__WorkOrder(soap, tag ? tag : "-tempuri:WorkOrder", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__WorkOrder * SOAP_FMAC4 soap_get___tempuri__WorkOrder(struct soap *soap, struct __tempuri__WorkOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__WorkOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__ToolingTimes(struct soap *soap, struct __tempuri__ToolingTimes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ToolingTimes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__ToolingTimes(struct soap *soap, const struct __tempuri__ToolingTimes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ToolingTimes(soap, &a->tempuri__ToolingTimes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__ToolingTimes(struct soap *soap, const char *tag, int id, const struct __tempuri__ToolingTimes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", -1, &a->tempuri__ToolingTimes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes * SOAP_FMAC4 soap_in___tempuri__ToolingTimes(struct soap *soap, const char *tag, struct __tempuri__ToolingTimes *a, const char *type)
{
	size_t soap_flag_tempuri__ToolingTimes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__ToolingTimes *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__ToolingTimes, sizeof(struct __tempuri__ToolingTimes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__ToolingTimes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ToolingTimes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", &a->tempuri__ToolingTimes, ""))
				{	soap_flag_tempuri__ToolingTimes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__ToolingTimes * SOAP_FMAC2 soap_instantiate___tempuri__ToolingTimes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__ToolingTimes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__ToolingTimes *p;
	size_t k = sizeof(struct __tempuri__ToolingTimes);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__ToolingTimes);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__ToolingTimes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__ToolingTimes location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__ToolingTimes, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__ToolingTimes(struct soap *soap, const struct __tempuri__ToolingTimes *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__ToolingTimes(soap, tag ? tag : "-tempuri:ToolingTimes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes * SOAP_FMAC4 soap_get___tempuri__ToolingTimes(struct soap *soap, struct __tempuri__ToolingTimes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__ToolingTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDocCode(struct soap *soap, struct __tempuri__GetDocCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDocCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDocCode(struct soap *soap, const struct __tempuri__GetDocCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDocCode(soap, &a->tempuri__GetDocCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDocCode(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDocCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDocCode(soap, "tempuri:GetDocCode", -1, &a->tempuri__GetDocCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDocCode * SOAP_FMAC4 soap_in___tempuri__GetDocCode(struct soap *soap, const char *tag, struct __tempuri__GetDocCode *a, const char *type)
{
	size_t soap_flag_tempuri__GetDocCode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDocCode *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDocCode, sizeof(struct __tempuri__GetDocCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDocCode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDocCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDocCode(soap, "tempuri:GetDocCode", &a->tempuri__GetDocCode, ""))
				{	soap_flag_tempuri__GetDocCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDocCode * SOAP_FMAC2 soap_instantiate___tempuri__GetDocCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDocCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDocCode *p;
	size_t k = sizeof(struct __tempuri__GetDocCode);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__GetDocCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__GetDocCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDocCode location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__GetDocCode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDocCode(struct soap *soap, const struct __tempuri__GetDocCode *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDocCode(soap, tag ? tag : "-tempuri:GetDocCode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDocCode * SOAP_FMAC4 soap_get___tempuri__GetDocCode(struct soap *soap, struct __tempuri__GetDocCode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDocCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDate(struct soap *soap, struct __tempuri__GetDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDate(struct soap *soap, const struct __tempuri__GetDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDate(soap, &a->tempuri__GetDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDate(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDate(soap, "tempuri:GetDate", -1, &a->tempuri__GetDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDate * SOAP_FMAC4 soap_in___tempuri__GetDate(struct soap *soap, const char *tag, struct __tempuri__GetDate *a, const char *type)
{
	size_t soap_flag_tempuri__GetDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDate *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDate, sizeof(struct __tempuri__GetDate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDate(soap, "tempuri:GetDate", &a->tempuri__GetDate, ""))
				{	soap_flag_tempuri__GetDate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDate * SOAP_FMAC2 soap_instantiate___tempuri__GetDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDate *p;
	size_t k = sizeof(struct __tempuri__GetDate);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__GetDate);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__GetDate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDate location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__GetDate, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDate(struct soap *soap, const struct __tempuri__GetDate *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDate(soap, tag ? tag : "-tempuri:GetDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDate * SOAP_FMAC4 soap_get___tempuri__GetDate(struct soap *soap, struct __tempuri__GetDate *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__Login(struct soap *soap, _tempuri__Login *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__Login))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__Login(struct soap *soap, const char *tag, int id, _tempuri__Login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__Login, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__Login ? type : NULL);
}

SOAP_FMAC3 _tempuri__Login ** SOAP_FMAC4 soap_in_PointerTo_tempuri__Login(struct soap *soap, const char *tag, _tempuri__Login **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__Login **)soap_malloc(soap, sizeof(_tempuri__Login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__Login *)soap_instantiate__tempuri__Login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__Login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__Login, sizeof(_tempuri__Login), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__Login(struct soap *soap, _tempuri__Login *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__Login(soap, tag ? tag : "tempuri:Login", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__Login ** SOAP_FMAC4 soap_get_PointerTo_tempuri__Login(struct soap *soap, _tempuri__Login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetPower(struct soap *soap, _tempuri__GetPower *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetPower))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetPower(struct soap *soap, const char *tag, int id, _tempuri__GetPower *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetPower, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetPower ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetPower ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetPower(struct soap *soap, const char *tag, _tempuri__GetPower **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetPower **)soap_malloc(soap, sizeof(_tempuri__GetPower *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetPower *)soap_instantiate__tempuri__GetPower(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetPower **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetPower, sizeof(_tempuri__GetPower), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetPower(struct soap *soap, _tempuri__GetPower *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetPower(soap, tag ? tag : "tempuri:GetPower", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetPower ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetPower(struct soap *soap, _tempuri__GetPower **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetPower(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetDept(struct soap *soap, _tempuri__GetDept *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetDept))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetDept(struct soap *soap, const char *tag, int id, _tempuri__GetDept *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetDept, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetDept ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetDept ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetDept(struct soap *soap, const char *tag, _tempuri__GetDept **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetDept **)soap_malloc(soap, sizeof(_tempuri__GetDept *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetDept *)soap_instantiate__tempuri__GetDept(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetDept **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetDept, sizeof(_tempuri__GetDept), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetDept(struct soap *soap, _tempuri__GetDept *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetDept(soap, tag ? tag : "tempuri:GetDept", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetDept ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetDept(struct soap *soap, _tempuri__GetDept **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetDept(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__SetExMail(struct soap *soap, _tempuri__SetExMail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__SetExMail))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__SetExMail(struct soap *soap, const char *tag, int id, _tempuri__SetExMail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__SetExMail, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__SetExMail ? type : NULL);
}

SOAP_FMAC3 _tempuri__SetExMail ** SOAP_FMAC4 soap_in_PointerTo_tempuri__SetExMail(struct soap *soap, const char *tag, _tempuri__SetExMail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__SetExMail **)soap_malloc(soap, sizeof(_tempuri__SetExMail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__SetExMail *)soap_instantiate__tempuri__SetExMail(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__SetExMail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__SetExMail, sizeof(_tempuri__SetExMail), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__SetExMail(struct soap *soap, _tempuri__SetExMail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__SetExMail(soap, tag ? tag : "tempuri:SetExMail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__SetExMail ** SOAP_FMAC4 soap_get_PointerTo_tempuri__SetExMail(struct soap *soap, _tempuri__SetExMail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__SetExMail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__DocAdd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__DocAdd(struct soap *soap, const char *tag, int id, _tempuri__DocAdd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__DocAdd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__DocAdd ? type : NULL);
}

SOAP_FMAC3 _tempuri__DocAdd ** SOAP_FMAC4 soap_in_PointerTo_tempuri__DocAdd(struct soap *soap, const char *tag, _tempuri__DocAdd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__DocAdd **)soap_malloc(soap, sizeof(_tempuri__DocAdd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__DocAdd *)soap_instantiate__tempuri__DocAdd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__DocAdd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__DocAdd, sizeof(_tempuri__DocAdd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__DocAdd(soap, tag ? tag : "tempuri:DocAdd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__DocAdd ** SOAP_FMAC4 soap_get_PointerTo_tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__DocAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__ItemsAdd(struct soap *soap, _tempuri__ItemsAdd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__ItemsAdd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__ItemsAdd(struct soap *soap, const char *tag, int id, _tempuri__ItemsAdd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__ItemsAdd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__ItemsAdd ? type : NULL);
}

SOAP_FMAC3 _tempuri__ItemsAdd ** SOAP_FMAC4 soap_in_PointerTo_tempuri__ItemsAdd(struct soap *soap, const char *tag, _tempuri__ItemsAdd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__ItemsAdd **)soap_malloc(soap, sizeof(_tempuri__ItemsAdd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__ItemsAdd *)soap_instantiate__tempuri__ItemsAdd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__ItemsAdd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__ItemsAdd, sizeof(_tempuri__ItemsAdd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__ItemsAdd(struct soap *soap, _tempuri__ItemsAdd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__ItemsAdd(soap, tag ? tag : "tempuri:ItemsAdd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__ItemsAdd ** SOAP_FMAC4 soap_get_PointerTo_tempuri__ItemsAdd(struct soap *soap, _tempuri__ItemsAdd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__ItemsAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDonTest(struct soap *soap, _tempuri__AnDonTest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDonTest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDonTest(struct soap *soap, const char *tag, int id, _tempuri__AnDonTest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDonTest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDonTest ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDonTest ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDonTest(struct soap *soap, const char *tag, _tempuri__AnDonTest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDonTest **)soap_malloc(soap, sizeof(_tempuri__AnDonTest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDonTest *)soap_instantiate__tempuri__AnDonTest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDonTest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDonTest, sizeof(_tempuri__AnDonTest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDonTest(struct soap *soap, _tempuri__AnDonTest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDonTest(soap, tag ? tag : "tempuri:AnDonTest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDonTest ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDonTest(struct soap *soap, _tempuri__AnDonTest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDonTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDonCall(struct soap *soap, _tempuri__AnDonCall *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDonCall))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDonCall(struct soap *soap, const char *tag, int id, _tempuri__AnDonCall *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDonCall, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDonCall ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDonCall ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDonCall(struct soap *soap, const char *tag, _tempuri__AnDonCall **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDonCall **)soap_malloc(soap, sizeof(_tempuri__AnDonCall *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDonCall *)soap_instantiate__tempuri__AnDonCall(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDonCall **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDonCall, sizeof(_tempuri__AnDonCall), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDonCall(struct soap *soap, _tempuri__AnDonCall *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDonCall(soap, tag ? tag : "tempuri:AnDonCall", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDonCall ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDonCall(struct soap *soap, _tempuri__AnDonCall **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDonCall(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDon(struct soap *soap, _tempuri__AnDon *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDon))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDon(struct soap *soap, const char *tag, int id, _tempuri__AnDon *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDon, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDon ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDon ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDon(struct soap *soap, const char *tag, _tempuri__AnDon **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDon **)soap_malloc(soap, sizeof(_tempuri__AnDon *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDon *)soap_instantiate__tempuri__AnDon(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDon **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDon, sizeof(_tempuri__AnDon), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDon(struct soap *soap, _tempuri__AnDon *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDon(soap, tag ? tag : "tempuri:AnDon", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDon ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDon(struct soap *soap, _tempuri__AnDon **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, _tempuri__LineInventoryReturn *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__LineInventoryReturn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, const char *tag, int id, _tempuri__LineInventoryReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__LineInventoryReturn, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__LineInventoryReturn ? type : NULL);
}

SOAP_FMAC3 _tempuri__LineInventoryReturn ** SOAP_FMAC4 soap_in_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, const char *tag, _tempuri__LineInventoryReturn **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__LineInventoryReturn **)soap_malloc(soap, sizeof(_tempuri__LineInventoryReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__LineInventoryReturn *)soap_instantiate__tempuri__LineInventoryReturn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__LineInventoryReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__LineInventoryReturn, sizeof(_tempuri__LineInventoryReturn), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, _tempuri__LineInventoryReturn *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__LineInventoryReturn(soap, tag ? tag : "tempuri:LineInventoryReturn", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__LineInventoryReturn ** SOAP_FMAC4 soap_get_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, _tempuri__LineInventoryReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__LineInventoryReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, _tempuri__LineInventoryUpdate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__LineInventoryUpdate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, int id, _tempuri__LineInventoryUpdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__LineInventoryUpdate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__LineInventoryUpdate ? type : NULL);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdate ** SOAP_FMAC4 soap_in_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, _tempuri__LineInventoryUpdate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__LineInventoryUpdate **)soap_malloc(soap, sizeof(_tempuri__LineInventoryUpdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__LineInventoryUpdate *)soap_instantiate__tempuri__LineInventoryUpdate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__LineInventoryUpdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__LineInventoryUpdate, sizeof(_tempuri__LineInventoryUpdate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, _tempuri__LineInventoryUpdate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__LineInventoryUpdate(soap, tag ? tag : "tempuri:LineInventoryUpdate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdate ** SOAP_FMAC4 soap_get_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, _tempuri__LineInventoryUpdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__LineInventoryUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__LineInventory))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__LineInventory(struct soap *soap, const char *tag, int id, _tempuri__LineInventory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__LineInventory, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__LineInventory ? type : NULL);
}

SOAP_FMAC3 _tempuri__LineInventory ** SOAP_FMAC4 soap_in_PointerTo_tempuri__LineInventory(struct soap *soap, const char *tag, _tempuri__LineInventory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__LineInventory **)soap_malloc(soap, sizeof(_tempuri__LineInventory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__LineInventory *)soap_instantiate__tempuri__LineInventory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__LineInventory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__LineInventory, sizeof(_tempuri__LineInventory), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__LineInventory(soap, tag ? tag : "tempuri:LineInventory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__LineInventory ** SOAP_FMAC4 soap_get_PointerTo_tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__LineInventory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__WorkOrder(struct soap *soap, _tempuri__WorkOrder *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__WorkOrder))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__WorkOrder(struct soap *soap, const char *tag, int id, _tempuri__WorkOrder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__WorkOrder, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__WorkOrder ? type : NULL);
}

SOAP_FMAC3 _tempuri__WorkOrder ** SOAP_FMAC4 soap_in_PointerTo_tempuri__WorkOrder(struct soap *soap, const char *tag, _tempuri__WorkOrder **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__WorkOrder **)soap_malloc(soap, sizeof(_tempuri__WorkOrder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__WorkOrder *)soap_instantiate__tempuri__WorkOrder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__WorkOrder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__WorkOrder, sizeof(_tempuri__WorkOrder), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__WorkOrder(struct soap *soap, _tempuri__WorkOrder *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__WorkOrder(soap, tag ? tag : "tempuri:WorkOrder", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__WorkOrder ** SOAP_FMAC4 soap_get_PointerTo_tempuri__WorkOrder(struct soap *soap, _tempuri__WorkOrder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__WorkOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__ToolingTimes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__ToolingTimes(struct soap *soap, const char *tag, int id, _tempuri__ToolingTimes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__ToolingTimes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__ToolingTimes ? type : NULL);
}

SOAP_FMAC3 _tempuri__ToolingTimes ** SOAP_FMAC4 soap_in_PointerTo_tempuri__ToolingTimes(struct soap *soap, const char *tag, _tempuri__ToolingTimes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__ToolingTimes **)soap_malloc(soap, sizeof(_tempuri__ToolingTimes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__ToolingTimes *)soap_instantiate__tempuri__ToolingTimes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__ToolingTimes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__ToolingTimes, sizeof(_tempuri__ToolingTimes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__ToolingTimes(soap, tag ? tag : "tempuri:ToolingTimes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__ToolingTimes ** SOAP_FMAC4 soap_get_PointerTo_tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__ToolingTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetDocCode(struct soap *soap, _tempuri__GetDocCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetDocCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetDocCode(struct soap *soap, const char *tag, int id, _tempuri__GetDocCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetDocCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetDocCode ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetDocCode ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetDocCode(struct soap *soap, const char *tag, _tempuri__GetDocCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetDocCode **)soap_malloc(soap, sizeof(_tempuri__GetDocCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetDocCode *)soap_instantiate__tempuri__GetDocCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetDocCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetDocCode, sizeof(_tempuri__GetDocCode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetDocCode(struct soap *soap, _tempuri__GetDocCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetDocCode(soap, tag ? tag : "tempuri:GetDocCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetDocCode ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetDocCode(struct soap *soap, _tempuri__GetDocCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetDocCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetDate(struct soap *soap, _tempuri__GetDate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetDate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetDate(struct soap *soap, const char *tag, int id, _tempuri__GetDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetDate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetDate ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetDate ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetDate(struct soap *soap, const char *tag, _tempuri__GetDate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetDate **)soap_malloc(soap, sizeof(_tempuri__GetDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetDate *)soap_instantiate__tempuri__GetDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetDate, sizeof(_tempuri__GetDate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetDate(struct soap *soap, _tempuri__GetDate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetDate(soap, tag ? tag : "tempuri:GetDate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetDate ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetDate(struct soap *soap, _tempuri__GetDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */

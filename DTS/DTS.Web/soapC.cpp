/* soapC.cpp
   Generated by gSOAP 2.8.64 for MESService.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.64 2018-06-26 07:04:54 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_tempuri__AnDanSLTypeAdd:
		return soap_in_PointerTo_tempuri__AnDanSLTypeAdd(soap, NULL, NULL, "tempuri:AnDanSLTypeAdd");
	case SOAP_TYPE_PointerTo_tempuri__AnDanSLTypeGet:
		return soap_in_PointerTo_tempuri__AnDanSLTypeGet(soap, NULL, NULL, "tempuri:AnDanSLTypeGet");
	case SOAP_TYPE_PointerTo_tempuri__AnDan2PeoplePresent:
		return soap_in_PointerTo_tempuri__AnDan2PeoplePresent(soap, NULL, NULL, "tempuri:AnDan2PeoplePresent");
	case SOAP_TYPE_PointerTo_tempuri__AnDan3AddUsers:
		return soap_in_PointerTo_tempuri__AnDan3AddUsers(soap, NULL, NULL, "tempuri:AnDan3AddUsers");
	case SOAP_TYPE_PointerTo_tempuri__AnDan4UpdPeoplePresent:
		return soap_in_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, NULL, NULL, "tempuri:AnDan4UpdPeoplePresent");
	case SOAP_TYPE_PointerTo_tempuri__AnDan1Send:
		return soap_in_PointerTo_tempuri__AnDan1Send(soap, NULL, NULL, "tempuri:AnDan1Send");
	case SOAP_TYPE_PointerTo_tempuri__Login:
		return soap_in_PointerTo_tempuri__Login(soap, NULL, NULL, "tempuri:Login");
	case SOAP_TYPE_PointerTo_tempuri__GetPower:
		return soap_in_PointerTo_tempuri__GetPower(soap, NULL, NULL, "tempuri:GetPower");
	case SOAP_TYPE_PointerTo_tempuri__GetDept:
		return soap_in_PointerTo_tempuri__GetDept(soap, NULL, NULL, "tempuri:GetDept");
	case SOAP_TYPE_PointerTo_tempuri__DocAdd:
		return soap_in_PointerTo_tempuri__DocAdd(soap, NULL, NULL, "tempuri:DocAdd");
	case SOAP_TYPE_PointerTo_tempuri__ItemsAdd:
		return soap_in_PointerTo_tempuri__ItemsAdd(soap, NULL, NULL, "tempuri:ItemsAdd");
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryReturn:
		return soap_in_PointerTo_tempuri__LineInventoryReturn(soap, NULL, NULL, "tempuri:LineInventoryReturn");
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryUpdate:
		return soap_in_PointerTo_tempuri__LineInventoryUpdate(soap, NULL, NULL, "tempuri:LineInventoryUpdate");
	case SOAP_TYPE_PointerTo_tempuri__LineInventory:
		return soap_in_PointerTo_tempuri__LineInventory(soap, NULL, NULL, "tempuri:LineInventory");
	case SOAP_TYPE_PointerTo_tempuri__WorkOrder:
		return soap_in_PointerTo_tempuri__WorkOrder(soap, NULL, NULL, "tempuri:WorkOrder");
	case SOAP_TYPE_PointerTo_tempuri__ToolingTimes:
		return soap_in_PointerTo_tempuri__ToolingTimes(soap, NULL, NULL, "tempuri:ToolingTimes");
	case SOAP_TYPE_PointerTo_tempuri__GetDocCode:
		return soap_in_PointerTo_tempuri__GetDocCode(soap, NULL, NULL, "tempuri:GetDocCode");
	case SOAP_TYPE_PointerTo_tempuri__GetDate:
		return soap_in_PointerTo_tempuri__GetDate(soap, NULL, NULL, "tempuri:GetDate");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "tempuri:AnDanSLTypeAddResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDanSLTypeAddResponse;
			return soap_in__tempuri__AnDanSLTypeAddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDanSLTypeAdd"))
		{	*type = SOAP_TYPE__tempuri__AnDanSLTypeAdd;
			return soap_in__tempuri__AnDanSLTypeAdd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDanSLTypeGetResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDanSLTypeGetResponse;
			return soap_in__tempuri__AnDanSLTypeGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDanSLTypeGet"))
		{	*type = SOAP_TYPE__tempuri__AnDanSLTypeGet;
			return soap_in__tempuri__AnDanSLTypeGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDan2PeoplePresentResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse;
			return soap_in__tempuri__AnDan2PeoplePresentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDan2PeoplePresent"))
		{	*type = SOAP_TYPE__tempuri__AnDan2PeoplePresent;
			return soap_in__tempuri__AnDan2PeoplePresent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDan3AddUsersResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDan3AddUsersResponse;
			return soap_in__tempuri__AnDan3AddUsersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDan3AddUsers"))
		{	*type = SOAP_TYPE__tempuri__AnDan3AddUsers;
			return soap_in__tempuri__AnDan3AddUsers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDan4UpdPeoplePresentResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse;
			return soap_in__tempuri__AnDan4UpdPeoplePresentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDan4UpdPeoplePresent"))
		{	*type = SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent;
			return soap_in__tempuri__AnDan4UpdPeoplePresent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDan1SendResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDan1SendResponse;
			return soap_in__tempuri__AnDan1SendResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDan1Send"))
		{	*type = SOAP_TYPE__tempuri__AnDan1Send;
			return soap_in__tempuri__AnDan1Send(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LoginResponse"))
		{	*type = SOAP_TYPE__tempuri__LoginResponse;
			return soap_in__tempuri__LoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:Login"))
		{	*type = SOAP_TYPE__tempuri__Login;
			return soap_in__tempuri__Login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetPowerResponse"))
		{	*type = SOAP_TYPE__tempuri__GetPowerResponse;
			return soap_in__tempuri__GetPowerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetPower"))
		{	*type = SOAP_TYPE__tempuri__GetPower;
			return soap_in__tempuri__GetPower(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDeptResponse"))
		{	*type = SOAP_TYPE__tempuri__GetDeptResponse;
			return soap_in__tempuri__GetDeptResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDept"))
		{	*type = SOAP_TYPE__tempuri__GetDept;
			return soap_in__tempuri__GetDept(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:DocAddResponse"))
		{	*type = SOAP_TYPE__tempuri__DocAddResponse;
			return soap_in__tempuri__DocAddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:DocAdd"))
		{	*type = SOAP_TYPE__tempuri__DocAdd;
			return soap_in__tempuri__DocAdd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ItemsAddResponse"))
		{	*type = SOAP_TYPE__tempuri__ItemsAddResponse;
			return soap_in__tempuri__ItemsAddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ItemsAdd"))
		{	*type = SOAP_TYPE__tempuri__ItemsAdd;
			return soap_in__tempuri__ItemsAdd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryReturnResponse"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryReturnResponse;
			return soap_in__tempuri__LineInventoryReturnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryReturn"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryReturn;
			return soap_in__tempuri__LineInventoryReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryUpdateResponse"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryUpdateResponse;
			return soap_in__tempuri__LineInventoryUpdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryUpdate"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryUpdate;
			return soap_in__tempuri__LineInventoryUpdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryResponse"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryResponse;
			return soap_in__tempuri__LineInventoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventory"))
		{	*type = SOAP_TYPE__tempuri__LineInventory;
			return soap_in__tempuri__LineInventory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:WorkOrderResponse"))
		{	*type = SOAP_TYPE__tempuri__WorkOrderResponse;
			return soap_in__tempuri__WorkOrderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:WorkOrder"))
		{	*type = SOAP_TYPE__tempuri__WorkOrder;
			return soap_in__tempuri__WorkOrder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ToolingTimesResponse"))
		{	*type = SOAP_TYPE__tempuri__ToolingTimesResponse;
			return soap_in__tempuri__ToolingTimesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ToolingTimes"))
		{	*type = SOAP_TYPE__tempuri__ToolingTimes;
			return soap_in__tempuri__ToolingTimes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDocCodeResponse"))
		{	*type = SOAP_TYPE__tempuri__GetDocCodeResponse;
			return soap_in__tempuri__GetDocCodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDocCode"))
		{	*type = SOAP_TYPE__tempuri__GetDocCode;
			return soap_in__tempuri__GetDocCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDateResponse"))
		{	*type = SOAP_TYPE__tempuri__GetDateResponse;
			return soap_in__tempuri__GetDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:GetDate"))
		{	*type = SOAP_TYPE__tempuri__GetDate;
			return soap_in__tempuri__GetDate(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__tempuri__AnDanSLTypeAddResponse:
		return ((_tempuri__AnDanSLTypeAddResponse *)ptr)->soap_out(soap, "tempuri:AnDanSLTypeAddResponse", id, "");
	case SOAP_TYPE__tempuri__AnDanSLTypeAdd:
		return ((_tempuri__AnDanSLTypeAdd *)ptr)->soap_out(soap, "tempuri:AnDanSLTypeAdd", id, "");
	case SOAP_TYPE__tempuri__AnDanSLTypeGetResponse:
		return ((_tempuri__AnDanSLTypeGetResponse *)ptr)->soap_out(soap, "tempuri:AnDanSLTypeGetResponse", id, "");
	case SOAP_TYPE__tempuri__AnDanSLTypeGet:
		return ((_tempuri__AnDanSLTypeGet *)ptr)->soap_out(soap, "tempuri:AnDanSLTypeGet", id, "");
	case SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse:
		return ((_tempuri__AnDan2PeoplePresentResponse *)ptr)->soap_out(soap, "tempuri:AnDan2PeoplePresentResponse", id, "");
	case SOAP_TYPE__tempuri__AnDan2PeoplePresent:
		return ((_tempuri__AnDan2PeoplePresent *)ptr)->soap_out(soap, "tempuri:AnDan2PeoplePresent", id, "");
	case SOAP_TYPE__tempuri__AnDan3AddUsersResponse:
		return ((_tempuri__AnDan3AddUsersResponse *)ptr)->soap_out(soap, "tempuri:AnDan3AddUsersResponse", id, "");
	case SOAP_TYPE__tempuri__AnDan3AddUsers:
		return ((_tempuri__AnDan3AddUsers *)ptr)->soap_out(soap, "tempuri:AnDan3AddUsers", id, "");
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse:
		return ((_tempuri__AnDan4UpdPeoplePresentResponse *)ptr)->soap_out(soap, "tempuri:AnDan4UpdPeoplePresentResponse", id, "");
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent:
		return ((_tempuri__AnDan4UpdPeoplePresent *)ptr)->soap_out(soap, "tempuri:AnDan4UpdPeoplePresent", id, "");
	case SOAP_TYPE__tempuri__AnDan1SendResponse:
		return ((_tempuri__AnDan1SendResponse *)ptr)->soap_out(soap, "tempuri:AnDan1SendResponse", id, "");
	case SOAP_TYPE__tempuri__AnDan1Send:
		return ((_tempuri__AnDan1Send *)ptr)->soap_out(soap, "tempuri:AnDan1Send", id, "");
	case SOAP_TYPE__tempuri__LoginResponse:
		return ((_tempuri__LoginResponse *)ptr)->soap_out(soap, "tempuri:LoginResponse", id, "");
	case SOAP_TYPE__tempuri__Login:
		return ((_tempuri__Login *)ptr)->soap_out(soap, "tempuri:Login", id, "");
	case SOAP_TYPE__tempuri__GetPowerResponse:
		return ((_tempuri__GetPowerResponse *)ptr)->soap_out(soap, "tempuri:GetPowerResponse", id, "");
	case SOAP_TYPE__tempuri__GetPower:
		return ((_tempuri__GetPower *)ptr)->soap_out(soap, "tempuri:GetPower", id, "");
	case SOAP_TYPE__tempuri__GetDeptResponse:
		return ((_tempuri__GetDeptResponse *)ptr)->soap_out(soap, "tempuri:GetDeptResponse", id, "");
	case SOAP_TYPE__tempuri__GetDept:
		return ((_tempuri__GetDept *)ptr)->soap_out(soap, "tempuri:GetDept", id, "");
	case SOAP_TYPE__tempuri__DocAddResponse:
		return ((_tempuri__DocAddResponse *)ptr)->soap_out(soap, "tempuri:DocAddResponse", id, "");
	case SOAP_TYPE__tempuri__DocAdd:
		return ((_tempuri__DocAdd *)ptr)->soap_out(soap, "tempuri:DocAdd", id, "");
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		return ((_tempuri__ItemsAddResponse *)ptr)->soap_out(soap, "tempuri:ItemsAddResponse", id, "");
	case SOAP_TYPE__tempuri__ItemsAdd:
		return ((_tempuri__ItemsAdd *)ptr)->soap_out(soap, "tempuri:ItemsAdd", id, "");
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		return ((_tempuri__LineInventoryReturnResponse *)ptr)->soap_out(soap, "tempuri:LineInventoryReturnResponse", id, "");
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		return ((_tempuri__LineInventoryReturn *)ptr)->soap_out(soap, "tempuri:LineInventoryReturn", id, "");
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		return ((_tempuri__LineInventoryUpdateResponse *)ptr)->soap_out(soap, "tempuri:LineInventoryUpdateResponse", id, "");
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		return ((_tempuri__LineInventoryUpdate *)ptr)->soap_out(soap, "tempuri:LineInventoryUpdate", id, "");
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		return ((_tempuri__LineInventoryResponse *)ptr)->soap_out(soap, "tempuri:LineInventoryResponse", id, "");
	case SOAP_TYPE__tempuri__LineInventory:
		return ((_tempuri__LineInventory *)ptr)->soap_out(soap, "tempuri:LineInventory", id, "");
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		return ((_tempuri__WorkOrderResponse *)ptr)->soap_out(soap, "tempuri:WorkOrderResponse", id, "");
	case SOAP_TYPE__tempuri__WorkOrder:
		return ((_tempuri__WorkOrder *)ptr)->soap_out(soap, "tempuri:WorkOrder", id, "");
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		return ((_tempuri__ToolingTimesResponse *)ptr)->soap_out(soap, "tempuri:ToolingTimesResponse", id, "");
	case SOAP_TYPE__tempuri__ToolingTimes:
		return ((_tempuri__ToolingTimes *)ptr)->soap_out(soap, "tempuri:ToolingTimes", id, "");
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		return ((_tempuri__GetDocCodeResponse *)ptr)->soap_out(soap, "tempuri:GetDocCodeResponse", id, "");
	case SOAP_TYPE__tempuri__GetDocCode:
		return ((_tempuri__GetDocCode *)ptr)->soap_out(soap, "tempuri:GetDocCode", id, "");
	case SOAP_TYPE__tempuri__GetDateResponse:
		return ((_tempuri__GetDateResponse *)ptr)->soap_out(soap, "tempuri:GetDateResponse", id, "");
	case SOAP_TYPE__tempuri__GetDate:
		return ((_tempuri__GetDate *)ptr)->soap_out(soap, "tempuri:GetDate", id, "");
	case SOAP_TYPE_PointerTo_tempuri__AnDanSLTypeAdd:
		return soap_out_PointerTo_tempuri__AnDanSLTypeAdd(soap, tag, id, (_tempuri__AnDanSLTypeAdd *const*)ptr, "tempuri:AnDanSLTypeAdd");
	case SOAP_TYPE_PointerTo_tempuri__AnDanSLTypeGet:
		return soap_out_PointerTo_tempuri__AnDanSLTypeGet(soap, tag, id, (_tempuri__AnDanSLTypeGet *const*)ptr, "tempuri:AnDanSLTypeGet");
	case SOAP_TYPE_PointerTo_tempuri__AnDan2PeoplePresent:
		return soap_out_PointerTo_tempuri__AnDan2PeoplePresent(soap, tag, id, (_tempuri__AnDan2PeoplePresent *const*)ptr, "tempuri:AnDan2PeoplePresent");
	case SOAP_TYPE_PointerTo_tempuri__AnDan3AddUsers:
		return soap_out_PointerTo_tempuri__AnDan3AddUsers(soap, tag, id, (_tempuri__AnDan3AddUsers *const*)ptr, "tempuri:AnDan3AddUsers");
	case SOAP_TYPE_PointerTo_tempuri__AnDan4UpdPeoplePresent:
		return soap_out_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, tag, id, (_tempuri__AnDan4UpdPeoplePresent *const*)ptr, "tempuri:AnDan4UpdPeoplePresent");
	case SOAP_TYPE_PointerTo_tempuri__AnDan1Send:
		return soap_out_PointerTo_tempuri__AnDan1Send(soap, tag, id, (_tempuri__AnDan1Send *const*)ptr, "tempuri:AnDan1Send");
	case SOAP_TYPE_PointerTo_tempuri__Login:
		return soap_out_PointerTo_tempuri__Login(soap, tag, id, (_tempuri__Login *const*)ptr, "tempuri:Login");
	case SOAP_TYPE_PointerTo_tempuri__GetPower:
		return soap_out_PointerTo_tempuri__GetPower(soap, tag, id, (_tempuri__GetPower *const*)ptr, "tempuri:GetPower");
	case SOAP_TYPE_PointerTo_tempuri__GetDept:
		return soap_out_PointerTo_tempuri__GetDept(soap, tag, id, (_tempuri__GetDept *const*)ptr, "tempuri:GetDept");
	case SOAP_TYPE_PointerTo_tempuri__DocAdd:
		return soap_out_PointerTo_tempuri__DocAdd(soap, tag, id, (_tempuri__DocAdd *const*)ptr, "tempuri:DocAdd");
	case SOAP_TYPE_PointerTo_tempuri__ItemsAdd:
		return soap_out_PointerTo_tempuri__ItemsAdd(soap, tag, id, (_tempuri__ItemsAdd *const*)ptr, "tempuri:ItemsAdd");
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryReturn:
		return soap_out_PointerTo_tempuri__LineInventoryReturn(soap, tag, id, (_tempuri__LineInventoryReturn *const*)ptr, "tempuri:LineInventoryReturn");
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryUpdate:
		return soap_out_PointerTo_tempuri__LineInventoryUpdate(soap, tag, id, (_tempuri__LineInventoryUpdate *const*)ptr, "tempuri:LineInventoryUpdate");
	case SOAP_TYPE_PointerTo_tempuri__LineInventory:
		return soap_out_PointerTo_tempuri__LineInventory(soap, tag, id, (_tempuri__LineInventory *const*)ptr, "tempuri:LineInventory");
	case SOAP_TYPE_PointerTo_tempuri__WorkOrder:
		return soap_out_PointerTo_tempuri__WorkOrder(soap, tag, id, (_tempuri__WorkOrder *const*)ptr, "tempuri:WorkOrder");
	case SOAP_TYPE_PointerTo_tempuri__ToolingTimes:
		return soap_out_PointerTo_tempuri__ToolingTimes(soap, tag, id, (_tempuri__ToolingTimes *const*)ptr, "tempuri:ToolingTimes");
	case SOAP_TYPE_PointerTo_tempuri__GetDocCode:
		return soap_out_PointerTo_tempuri__GetDocCode(soap, tag, id, (_tempuri__GetDocCode *const*)ptr, "tempuri:GetDocCode");
	case SOAP_TYPE_PointerTo_tempuri__GetDate:
		return soap_out_PointerTo_tempuri__GetDate(soap, tag, id, (_tempuri__GetDate *const*)ptr, "tempuri:GetDate");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeAddResponse:
		((_tempuri__AnDanSLTypeAddResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeAdd:
		((_tempuri__AnDanSLTypeAdd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeGetResponse:
		((_tempuri__AnDanSLTypeGetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeGet:
		((_tempuri__AnDanSLTypeGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse:
		((_tempuri__AnDan2PeoplePresentResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDan2PeoplePresent:
		((_tempuri__AnDan2PeoplePresent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDan3AddUsersResponse:
		((_tempuri__AnDan3AddUsersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDan3AddUsers:
		((_tempuri__AnDan3AddUsers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse:
		((_tempuri__AnDan4UpdPeoplePresentResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent:
		((_tempuri__AnDan4UpdPeoplePresent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDan1SendResponse:
		((_tempuri__AnDan1SendResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDan1Send:
		((_tempuri__AnDan1Send *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LoginResponse:
		((_tempuri__LoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__Login:
		((_tempuri__Login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetPowerResponse:
		((_tempuri__GetPowerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetPower:
		((_tempuri__GetPower *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDeptResponse:
		((_tempuri__GetDeptResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDept:
		((_tempuri__GetDept *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__DocAddResponse:
		((_tempuri__DocAddResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__DocAdd:
		((_tempuri__DocAdd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		((_tempuri__ItemsAddResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ItemsAdd:
		((_tempuri__ItemsAdd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		((_tempuri__LineInventoryReturnResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		((_tempuri__LineInventoryReturn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		((_tempuri__LineInventoryUpdateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		((_tempuri__LineInventoryUpdate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		((_tempuri__LineInventoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventory:
		((_tempuri__LineInventory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		((_tempuri__WorkOrderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__WorkOrder:
		((_tempuri__WorkOrder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		((_tempuri__ToolingTimesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ToolingTimes:
		((_tempuri__ToolingTimes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		((_tempuri__GetDocCodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDocCode:
		((_tempuri__GetDocCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDateResponse:
		((_tempuri__GetDateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__GetDate:
		((_tempuri__GetDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeAdd_:
		soap_serialize___tempuri__AnDanSLTypeAdd_(soap, (const struct __tempuri__AnDanSLTypeAdd_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeGet_:
		soap_serialize___tempuri__AnDanSLTypeGet_(soap, (const struct __tempuri__AnDanSLTypeGet_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDan2PeoplePresent_:
		soap_serialize___tempuri__AnDan2PeoplePresent_(soap, (const struct __tempuri__AnDan2PeoplePresent_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDan3AddUsers_:
		soap_serialize___tempuri__AnDan3AddUsers_(soap, (const struct __tempuri__AnDan3AddUsers_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent_:
		soap_serialize___tempuri__AnDan4UpdPeoplePresent_(soap, (const struct __tempuri__AnDan4UpdPeoplePresent_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDan1Send_:
		soap_serialize___tempuri__AnDan1Send_(soap, (const struct __tempuri__AnDan1Send_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__Login_:
		soap_serialize___tempuri__Login_(soap, (const struct __tempuri__Login_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetPower_:
		soap_serialize___tempuri__GetPower_(soap, (const struct __tempuri__GetPower_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDept_:
		soap_serialize___tempuri__GetDept_(soap, (const struct __tempuri__GetDept_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__DocAdd_:
		soap_serialize___tempuri__DocAdd_(soap, (const struct __tempuri__DocAdd_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__ItemsAdd_:
		soap_serialize___tempuri__ItemsAdd_(soap, (const struct __tempuri__ItemsAdd_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn_:
		soap_serialize___tempuri__LineInventoryReturn_(soap, (const struct __tempuri__LineInventoryReturn_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate_:
		soap_serialize___tempuri__LineInventoryUpdate_(soap, (const struct __tempuri__LineInventoryUpdate_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventory_:
		soap_serialize___tempuri__LineInventory_(soap, (const struct __tempuri__LineInventory_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__WorkOrder_:
		soap_serialize___tempuri__WorkOrder_(soap, (const struct __tempuri__WorkOrder_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__ToolingTimes_:
		soap_serialize___tempuri__ToolingTimes_(soap, (const struct __tempuri__ToolingTimes_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDocCode_:
		soap_serialize___tempuri__GetDocCode_(soap, (const struct __tempuri__GetDocCode_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDate_:
		soap_serialize___tempuri__GetDate_(soap, (const struct __tempuri__GetDate_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeAdd:
		soap_serialize___tempuri__AnDanSLTypeAdd(soap, (const struct __tempuri__AnDanSLTypeAdd *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeGet:
		soap_serialize___tempuri__AnDanSLTypeGet(soap, (const struct __tempuri__AnDanSLTypeGet *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDan2PeoplePresent:
		soap_serialize___tempuri__AnDan2PeoplePresent(soap, (const struct __tempuri__AnDan2PeoplePresent *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDan3AddUsers:
		soap_serialize___tempuri__AnDan3AddUsers(soap, (const struct __tempuri__AnDan3AddUsers *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent:
		soap_serialize___tempuri__AnDan4UpdPeoplePresent(soap, (const struct __tempuri__AnDan4UpdPeoplePresent *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDan1Send:
		soap_serialize___tempuri__AnDan1Send(soap, (const struct __tempuri__AnDan1Send *)ptr);
		break;
	case SOAP_TYPE___tempuri__Login:
		soap_serialize___tempuri__Login(soap, (const struct __tempuri__Login *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetPower:
		soap_serialize___tempuri__GetPower(soap, (const struct __tempuri__GetPower *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDept:
		soap_serialize___tempuri__GetDept(soap, (const struct __tempuri__GetDept *)ptr);
		break;
	case SOAP_TYPE___tempuri__DocAdd:
		soap_serialize___tempuri__DocAdd(soap, (const struct __tempuri__DocAdd *)ptr);
		break;
	case SOAP_TYPE___tempuri__ItemsAdd:
		soap_serialize___tempuri__ItemsAdd(soap, (const struct __tempuri__ItemsAdd *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn:
		soap_serialize___tempuri__LineInventoryReturn(soap, (const struct __tempuri__LineInventoryReturn *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate:
		soap_serialize___tempuri__LineInventoryUpdate(soap, (const struct __tempuri__LineInventoryUpdate *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventory:
		soap_serialize___tempuri__LineInventory(soap, (const struct __tempuri__LineInventory *)ptr);
		break;
	case SOAP_TYPE___tempuri__WorkOrder:
		soap_serialize___tempuri__WorkOrder(soap, (const struct __tempuri__WorkOrder *)ptr);
		break;
	case SOAP_TYPE___tempuri__ToolingTimes:
		soap_serialize___tempuri__ToolingTimes(soap, (const struct __tempuri__ToolingTimes *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDocCode:
		soap_serialize___tempuri__GetDocCode(soap, (const struct __tempuri__GetDocCode *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetDate:
		soap_serialize___tempuri__GetDate(soap, (const struct __tempuri__GetDate *)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDanSLTypeAdd:
		soap_serialize_PointerTo_tempuri__AnDanSLTypeAdd(soap, (_tempuri__AnDanSLTypeAdd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDanSLTypeGet:
		soap_serialize_PointerTo_tempuri__AnDanSLTypeGet(soap, (_tempuri__AnDanSLTypeGet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDan2PeoplePresent:
		soap_serialize_PointerTo_tempuri__AnDan2PeoplePresent(soap, (_tempuri__AnDan2PeoplePresent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDan3AddUsers:
		soap_serialize_PointerTo_tempuri__AnDan3AddUsers(soap, (_tempuri__AnDan3AddUsers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDan4UpdPeoplePresent:
		soap_serialize_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, (_tempuri__AnDan4UpdPeoplePresent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDan1Send:
		soap_serialize_PointerTo_tempuri__AnDan1Send(soap, (_tempuri__AnDan1Send *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__Login:
		soap_serialize_PointerTo_tempuri__Login(soap, (_tempuri__Login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetPower:
		soap_serialize_PointerTo_tempuri__GetPower(soap, (_tempuri__GetPower *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetDept:
		soap_serialize_PointerTo_tempuri__GetDept(soap, (_tempuri__GetDept *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__DocAdd:
		soap_serialize_PointerTo_tempuri__DocAdd(soap, (_tempuri__DocAdd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__ItemsAdd:
		soap_serialize_PointerTo_tempuri__ItemsAdd(soap, (_tempuri__ItemsAdd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryReturn:
		soap_serialize_PointerTo_tempuri__LineInventoryReturn(soap, (_tempuri__LineInventoryReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryUpdate:
		soap_serialize_PointerTo_tempuri__LineInventoryUpdate(soap, (_tempuri__LineInventoryUpdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__LineInventory:
		soap_serialize_PointerTo_tempuri__LineInventory(soap, (_tempuri__LineInventory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__WorkOrder:
		soap_serialize_PointerTo_tempuri__WorkOrder(soap, (_tempuri__WorkOrder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__ToolingTimes:
		soap_serialize_PointerTo_tempuri__ToolingTimes(soap, (_tempuri__ToolingTimes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetDocCode:
		soap_serialize_PointerTo_tempuri__GetDocCode(soap, (_tempuri__GetDocCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__GetDate:
		soap_serialize_PointerTo_tempuri__GetDate(soap, (_tempuri__GetDate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_memdup(soap, ptr, sizeof(char));
	case SOAP_TYPE_int:
		return soap_memdup(soap, ptr, sizeof(int));
	case SOAP_TYPE_bool:
		return soap_memdup(soap, ptr, sizeof(bool));
	case SOAP_TYPE_std__string:
		return (void*)soap_dup_std__string(soap, NULL, (const std::string *)ptr);
	case SOAP_TYPE__tempuri__AnDanSLTypeAddResponse:
		return (void*)((_tempuri__AnDanSLTypeAddResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDanSLTypeAdd:
		return (void*)((_tempuri__AnDanSLTypeAdd *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDanSLTypeGetResponse:
		return (void*)((_tempuri__AnDanSLTypeGetResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDanSLTypeGet:
		return (void*)((_tempuri__AnDanSLTypeGet *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse:
		return (void*)((_tempuri__AnDan2PeoplePresentResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDan2PeoplePresent:
		return (void*)((_tempuri__AnDan2PeoplePresent *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDan3AddUsersResponse:
		return (void*)((_tempuri__AnDan3AddUsersResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDan3AddUsers:
		return (void*)((_tempuri__AnDan3AddUsers *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse:
		return (void*)((_tempuri__AnDan4UpdPeoplePresentResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent:
		return (void*)((_tempuri__AnDan4UpdPeoplePresent *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDan1SendResponse:
		return (void*)((_tempuri__AnDan1SendResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__AnDan1Send:
		return (void*)((_tempuri__AnDan1Send *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__LoginResponse:
		return (void*)((_tempuri__LoginResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__Login:
		return (void*)((_tempuri__Login *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__GetPowerResponse:
		return (void*)((_tempuri__GetPowerResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__GetPower:
		return (void*)((_tempuri__GetPower *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__GetDeptResponse:
		return (void*)((_tempuri__GetDeptResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__GetDept:
		return (void*)((_tempuri__GetDept *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__DocAddResponse:
		return (void*)((_tempuri__DocAddResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__DocAdd:
		return (void*)((_tempuri__DocAdd *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		return (void*)((_tempuri__ItemsAddResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__ItemsAdd:
		return (void*)((_tempuri__ItemsAdd *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		return (void*)((_tempuri__LineInventoryReturnResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		return (void*)((_tempuri__LineInventoryReturn *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		return (void*)((_tempuri__LineInventoryUpdateResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		return (void*)((_tempuri__LineInventoryUpdate *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		return (void*)((_tempuri__LineInventoryResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__LineInventory:
		return (void*)((_tempuri__LineInventory *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		return (void*)((_tempuri__WorkOrderResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__WorkOrder:
		return (void*)((_tempuri__WorkOrder *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		return (void*)((_tempuri__ToolingTimesResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__ToolingTimes:
		return (void*)((_tempuri__ToolingTimes *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		return (void*)((_tempuri__GetDocCodeResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__GetDocCode:
		return (void*)((_tempuri__GetDocCode *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__GetDateResponse:
		return (void*)((_tempuri__GetDateResponse *)ptr)->soap_dup(soap);
	case SOAP_TYPE__tempuri__GetDate:
		return (void*)((_tempuri__GetDate *)ptr)->soap_dup(soap);
	case SOAP_TYPE___tempuri__AnDanSLTypeAdd_:
		return (void*)soap_dup___tempuri__AnDanSLTypeAdd_(soap, NULL, (const struct __tempuri__AnDanSLTypeAdd_ *)ptr);
	case SOAP_TYPE___tempuri__AnDanSLTypeGet_:
		return (void*)soap_dup___tempuri__AnDanSLTypeGet_(soap, NULL, (const struct __tempuri__AnDanSLTypeGet_ *)ptr);
	case SOAP_TYPE___tempuri__AnDan2PeoplePresent_:
		return (void*)soap_dup___tempuri__AnDan2PeoplePresent_(soap, NULL, (const struct __tempuri__AnDan2PeoplePresent_ *)ptr);
	case SOAP_TYPE___tempuri__AnDan3AddUsers_:
		return (void*)soap_dup___tempuri__AnDan3AddUsers_(soap, NULL, (const struct __tempuri__AnDan3AddUsers_ *)ptr);
	case SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent_:
		return (void*)soap_dup___tempuri__AnDan4UpdPeoplePresent_(soap, NULL, (const struct __tempuri__AnDan4UpdPeoplePresent_ *)ptr);
	case SOAP_TYPE___tempuri__AnDan1Send_:
		return (void*)soap_dup___tempuri__AnDan1Send_(soap, NULL, (const struct __tempuri__AnDan1Send_ *)ptr);
	case SOAP_TYPE___tempuri__Login_:
		return (void*)soap_dup___tempuri__Login_(soap, NULL, (const struct __tempuri__Login_ *)ptr);
	case SOAP_TYPE___tempuri__GetPower_:
		return (void*)soap_dup___tempuri__GetPower_(soap, NULL, (const struct __tempuri__GetPower_ *)ptr);
	case SOAP_TYPE___tempuri__GetDept_:
		return (void*)soap_dup___tempuri__GetDept_(soap, NULL, (const struct __tempuri__GetDept_ *)ptr);
	case SOAP_TYPE___tempuri__DocAdd_:
		return (void*)soap_dup___tempuri__DocAdd_(soap, NULL, (const struct __tempuri__DocAdd_ *)ptr);
	case SOAP_TYPE___tempuri__ItemsAdd_:
		return (void*)soap_dup___tempuri__ItemsAdd_(soap, NULL, (const struct __tempuri__ItemsAdd_ *)ptr);
	case SOAP_TYPE___tempuri__LineInventoryReturn_:
		return (void*)soap_dup___tempuri__LineInventoryReturn_(soap, NULL, (const struct __tempuri__LineInventoryReturn_ *)ptr);
	case SOAP_TYPE___tempuri__LineInventoryUpdate_:
		return (void*)soap_dup___tempuri__LineInventoryUpdate_(soap, NULL, (const struct __tempuri__LineInventoryUpdate_ *)ptr);
	case SOAP_TYPE___tempuri__LineInventory_:
		return (void*)soap_dup___tempuri__LineInventory_(soap, NULL, (const struct __tempuri__LineInventory_ *)ptr);
	case SOAP_TYPE___tempuri__WorkOrder_:
		return (void*)soap_dup___tempuri__WorkOrder_(soap, NULL, (const struct __tempuri__WorkOrder_ *)ptr);
	case SOAP_TYPE___tempuri__ToolingTimes_:
		return (void*)soap_dup___tempuri__ToolingTimes_(soap, NULL, (const struct __tempuri__ToolingTimes_ *)ptr);
	case SOAP_TYPE___tempuri__GetDocCode_:
		return (void*)soap_dup___tempuri__GetDocCode_(soap, NULL, (const struct __tempuri__GetDocCode_ *)ptr);
	case SOAP_TYPE___tempuri__GetDate_:
		return (void*)soap_dup___tempuri__GetDate_(soap, NULL, (const struct __tempuri__GetDate_ *)ptr);
	case SOAP_TYPE___tempuri__AnDanSLTypeAdd:
		return (void*)soap_dup___tempuri__AnDanSLTypeAdd(soap, NULL, (const struct __tempuri__AnDanSLTypeAdd *)ptr);
	case SOAP_TYPE___tempuri__AnDanSLTypeGet:
		return (void*)soap_dup___tempuri__AnDanSLTypeGet(soap, NULL, (const struct __tempuri__AnDanSLTypeGet *)ptr);
	case SOAP_TYPE___tempuri__AnDan2PeoplePresent:
		return (void*)soap_dup___tempuri__AnDan2PeoplePresent(soap, NULL, (const struct __tempuri__AnDan2PeoplePresent *)ptr);
	case SOAP_TYPE___tempuri__AnDan3AddUsers:
		return (void*)soap_dup___tempuri__AnDan3AddUsers(soap, NULL, (const struct __tempuri__AnDan3AddUsers *)ptr);
	case SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent:
		return (void*)soap_dup___tempuri__AnDan4UpdPeoplePresent(soap, NULL, (const struct __tempuri__AnDan4UpdPeoplePresent *)ptr);
	case SOAP_TYPE___tempuri__AnDan1Send:
		return (void*)soap_dup___tempuri__AnDan1Send(soap, NULL, (const struct __tempuri__AnDan1Send *)ptr);
	case SOAP_TYPE___tempuri__Login:
		return (void*)soap_dup___tempuri__Login(soap, NULL, (const struct __tempuri__Login *)ptr);
	case SOAP_TYPE___tempuri__GetPower:
		return (void*)soap_dup___tempuri__GetPower(soap, NULL, (const struct __tempuri__GetPower *)ptr);
	case SOAP_TYPE___tempuri__GetDept:
		return (void*)soap_dup___tempuri__GetDept(soap, NULL, (const struct __tempuri__GetDept *)ptr);
	case SOAP_TYPE___tempuri__DocAdd:
		return (void*)soap_dup___tempuri__DocAdd(soap, NULL, (const struct __tempuri__DocAdd *)ptr);
	case SOAP_TYPE___tempuri__ItemsAdd:
		return (void*)soap_dup___tempuri__ItemsAdd(soap, NULL, (const struct __tempuri__ItemsAdd *)ptr);
	case SOAP_TYPE___tempuri__LineInventoryReturn:
		return (void*)soap_dup___tempuri__LineInventoryReturn(soap, NULL, (const struct __tempuri__LineInventoryReturn *)ptr);
	case SOAP_TYPE___tempuri__LineInventoryUpdate:
		return (void*)soap_dup___tempuri__LineInventoryUpdate(soap, NULL, (const struct __tempuri__LineInventoryUpdate *)ptr);
	case SOAP_TYPE___tempuri__LineInventory:
		return (void*)soap_dup___tempuri__LineInventory(soap, NULL, (const struct __tempuri__LineInventory *)ptr);
	case SOAP_TYPE___tempuri__WorkOrder:
		return (void*)soap_dup___tempuri__WorkOrder(soap, NULL, (const struct __tempuri__WorkOrder *)ptr);
	case SOAP_TYPE___tempuri__ToolingTimes:
		return (void*)soap_dup___tempuri__ToolingTimes(soap, NULL, (const struct __tempuri__ToolingTimes *)ptr);
	case SOAP_TYPE___tempuri__GetDocCode:
		return (void*)soap_dup___tempuri__GetDocCode(soap, NULL, (const struct __tempuri__GetDocCode *)ptr);
	case SOAP_TYPE___tempuri__GetDate:
		return (void*)soap_dup___tempuri__GetDate(soap, NULL, (const struct __tempuri__GetDate *)ptr);
	case SOAP_TYPE_PointerTo_tempuri__AnDanSLTypeAdd:
		return (void*)soap_dup_PointerTo_tempuri__AnDanSLTypeAdd(soap, NULL, (_tempuri__AnDanSLTypeAdd *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__AnDanSLTypeGet:
		return (void*)soap_dup_PointerTo_tempuri__AnDanSLTypeGet(soap, NULL, (_tempuri__AnDanSLTypeGet *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__AnDan2PeoplePresent:
		return (void*)soap_dup_PointerTo_tempuri__AnDan2PeoplePresent(soap, NULL, (_tempuri__AnDan2PeoplePresent *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__AnDan3AddUsers:
		return (void*)soap_dup_PointerTo_tempuri__AnDan3AddUsers(soap, NULL, (_tempuri__AnDan3AddUsers *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__AnDan4UpdPeoplePresent:
		return (void*)soap_dup_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, NULL, (_tempuri__AnDan4UpdPeoplePresent *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__AnDan1Send:
		return (void*)soap_dup_PointerTo_tempuri__AnDan1Send(soap, NULL, (_tempuri__AnDan1Send *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__Login:
		return (void*)soap_dup_PointerTo_tempuri__Login(soap, NULL, (_tempuri__Login *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__GetPower:
		return (void*)soap_dup_PointerTo_tempuri__GetPower(soap, NULL, (_tempuri__GetPower *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__GetDept:
		return (void*)soap_dup_PointerTo_tempuri__GetDept(soap, NULL, (_tempuri__GetDept *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__DocAdd:
		return (void*)soap_dup_PointerTo_tempuri__DocAdd(soap, NULL, (_tempuri__DocAdd *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__ItemsAdd:
		return (void*)soap_dup_PointerTo_tempuri__ItemsAdd(soap, NULL, (_tempuri__ItemsAdd *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryReturn:
		return (void*)soap_dup_PointerTo_tempuri__LineInventoryReturn(soap, NULL, (_tempuri__LineInventoryReturn *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__LineInventoryUpdate:
		return (void*)soap_dup_PointerTo_tempuri__LineInventoryUpdate(soap, NULL, (_tempuri__LineInventoryUpdate *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__LineInventory:
		return (void*)soap_dup_PointerTo_tempuri__LineInventory(soap, NULL, (_tempuri__LineInventory *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__WorkOrder:
		return (void*)soap_dup_PointerTo_tempuri__WorkOrder(soap, NULL, (_tempuri__WorkOrder *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__ToolingTimes:
		return (void*)soap_dup_PointerTo_tempuri__ToolingTimes(soap, NULL, (_tempuri__ToolingTimes *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__GetDocCode:
		return (void*)soap_dup_PointerTo_tempuri__GetDocCode(soap, NULL, (_tempuri__GetDocCode *const*)ptr);
	case SOAP_TYPE_PointerTo_tempuri__GetDate:
		return (void*)soap_dup_PointerTo_tempuri__GetDate(soap, NULL, (_tempuri__GetDate *const*)ptr);
	case SOAP_TYPE_PointerTostd__string:
		return (void*)soap_dup_PointerTostd__string(soap, NULL, (std::string *const*)ptr);
	case SOAP_TYPE__QName:
		return (void*)soap_strdup(soap, (const char*)ptr);
	case SOAP_TYPE_string:
		return (void*)soap_strdup(soap, (const char*)ptr);
	}
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE__tempuri__GetDate:
		return (void*)soap_instantiate__tempuri__GetDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetDateResponse:
		return (void*)soap_instantiate__tempuri__GetDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetDocCode:
		return (void*)soap_instantiate__tempuri__GetDocCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		return (void*)soap_instantiate__tempuri__GetDocCodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ToolingTimes:
		return (void*)soap_instantiate__tempuri__ToolingTimes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		return (void*)soap_instantiate__tempuri__ToolingTimesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__WorkOrder:
		return (void*)soap_instantiate__tempuri__WorkOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		return (void*)soap_instantiate__tempuri__WorkOrderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventory:
		return (void*)soap_instantiate__tempuri__LineInventory(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		return (void*)soap_instantiate__tempuri__LineInventoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		return (void*)soap_instantiate__tempuri__LineInventoryUpdate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		return (void*)soap_instantiate__tempuri__LineInventoryUpdateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		return (void*)soap_instantiate__tempuri__LineInventoryReturn(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		return (void*)soap_instantiate__tempuri__LineInventoryReturnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ItemsAdd:
		return (void*)soap_instantiate__tempuri__ItemsAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		return (void*)soap_instantiate__tempuri__ItemsAddResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__DocAdd:
		return (void*)soap_instantiate__tempuri__DocAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__DocAddResponse:
		return (void*)soap_instantiate__tempuri__DocAddResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetDept:
		return (void*)soap_instantiate__tempuri__GetDept(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetDeptResponse:
		return (void*)soap_instantiate__tempuri__GetDeptResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetPower:
		return (void*)soap_instantiate__tempuri__GetPower(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__GetPowerResponse:
		return (void*)soap_instantiate__tempuri__GetPowerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__Login:
		return (void*)soap_instantiate__tempuri__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LoginResponse:
		return (void*)soap_instantiate__tempuri__LoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDan1Send:
		return (void*)soap_instantiate__tempuri__AnDan1Send(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDan1SendResponse:
		return (void*)soap_instantiate__tempuri__AnDan1SendResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent:
		return (void*)soap_instantiate__tempuri__AnDan4UpdPeoplePresent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse:
		return (void*)soap_instantiate__tempuri__AnDan4UpdPeoplePresentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDan3AddUsers:
		return (void*)soap_instantiate__tempuri__AnDan3AddUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDan3AddUsersResponse:
		return (void*)soap_instantiate__tempuri__AnDan3AddUsersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDan2PeoplePresent:
		return (void*)soap_instantiate__tempuri__AnDan2PeoplePresent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse:
		return (void*)soap_instantiate__tempuri__AnDan2PeoplePresentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDanSLTypeGet:
		return (void*)soap_instantiate__tempuri__AnDanSLTypeGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDanSLTypeGetResponse:
		return (void*)soap_instantiate__tempuri__AnDanSLTypeGetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDanSLTypeAdd:
		return (void*)soap_instantiate__tempuri__AnDanSLTypeAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDanSLTypeAddResponse:
		return (void*)soap_instantiate__tempuri__AnDanSLTypeAddResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDate:
		return (void*)soap_instantiate___tempuri__GetDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDocCode:
		return (void*)soap_instantiate___tempuri__GetDocCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__ToolingTimes:
		return (void*)soap_instantiate___tempuri__ToolingTimes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__WorkOrder:
		return (void*)soap_instantiate___tempuri__WorkOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventory:
		return (void*)soap_instantiate___tempuri__LineInventory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventoryUpdate:
		return (void*)soap_instantiate___tempuri__LineInventoryUpdate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventoryReturn:
		return (void*)soap_instantiate___tempuri__LineInventoryReturn(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__ItemsAdd:
		return (void*)soap_instantiate___tempuri__ItemsAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__DocAdd:
		return (void*)soap_instantiate___tempuri__DocAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDept:
		return (void*)soap_instantiate___tempuri__GetDept(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetPower:
		return (void*)soap_instantiate___tempuri__GetPower(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__Login:
		return (void*)soap_instantiate___tempuri__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDan1Send:
		return (void*)soap_instantiate___tempuri__AnDan1Send(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent:
		return (void*)soap_instantiate___tempuri__AnDan4UpdPeoplePresent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDan3AddUsers:
		return (void*)soap_instantiate___tempuri__AnDan3AddUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDan2PeoplePresent:
		return (void*)soap_instantiate___tempuri__AnDan2PeoplePresent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDanSLTypeGet:
		return (void*)soap_instantiate___tempuri__AnDanSLTypeGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDanSLTypeAdd:
		return (void*)soap_instantiate___tempuri__AnDanSLTypeAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDate_:
		return (void*)soap_instantiate___tempuri__GetDate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDocCode_:
		return (void*)soap_instantiate___tempuri__GetDocCode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__ToolingTimes_:
		return (void*)soap_instantiate___tempuri__ToolingTimes_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__WorkOrder_:
		return (void*)soap_instantiate___tempuri__WorkOrder_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventory_:
		return (void*)soap_instantiate___tempuri__LineInventory_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventoryUpdate_:
		return (void*)soap_instantiate___tempuri__LineInventoryUpdate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventoryReturn_:
		return (void*)soap_instantiate___tempuri__LineInventoryReturn_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__ItemsAdd_:
		return (void*)soap_instantiate___tempuri__ItemsAdd_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__DocAdd_:
		return (void*)soap_instantiate___tempuri__DocAdd_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetDept_:
		return (void*)soap_instantiate___tempuri__GetDept_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetPower_:
		return (void*)soap_instantiate___tempuri__GetPower_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__Login_:
		return (void*)soap_instantiate___tempuri__Login_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDan1Send_:
		return (void*)soap_instantiate___tempuri__AnDan1Send_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent_:
		return (void*)soap_instantiate___tempuri__AnDan4UpdPeoplePresent_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDan3AddUsers_:
		return (void*)soap_instantiate___tempuri__AnDan3AddUsers_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDan2PeoplePresent_:
		return (void*)soap_instantiate___tempuri__AnDan2PeoplePresent_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDanSLTypeGet_:
		return (void*)soap_instantiate___tempuri__AnDanSLTypeGet_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDanSLTypeAdd_:
		return (void*)soap_instantiate___tempuri__AnDanSLTypeAdd_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE__tempuri__GetDate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetDate*>(p->ptr), _tempuri__GetDate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetDate*>(p->ptr), _tempuri__GetDate);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__tempuri__GetDateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetDateResponse*>(p->ptr), _tempuri__GetDateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetDateResponse*>(p->ptr), _tempuri__GetDateResponse);
		break;
	case SOAP_TYPE__tempuri__GetDocCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetDocCode*>(p->ptr), _tempuri__GetDocCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetDocCode*>(p->ptr), _tempuri__GetDocCode);
		break;
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetDocCodeResponse*>(p->ptr), _tempuri__GetDocCodeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetDocCodeResponse*>(p->ptr), _tempuri__GetDocCodeResponse);
		break;
	case SOAP_TYPE__tempuri__ToolingTimes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__ToolingTimes*>(p->ptr), _tempuri__ToolingTimes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__ToolingTimes*>(p->ptr), _tempuri__ToolingTimes);
		break;
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__ToolingTimesResponse*>(p->ptr), _tempuri__ToolingTimesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__ToolingTimesResponse*>(p->ptr), _tempuri__ToolingTimesResponse);
		break;
	case SOAP_TYPE__tempuri__WorkOrder:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__WorkOrder*>(p->ptr), _tempuri__WorkOrder);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__WorkOrder*>(p->ptr), _tempuri__WorkOrder);
		break;
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__WorkOrderResponse*>(p->ptr), _tempuri__WorkOrderResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__WorkOrderResponse*>(p->ptr), _tempuri__WorkOrderResponse);
		break;
	case SOAP_TYPE__tempuri__LineInventory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__LineInventory*>(p->ptr), _tempuri__LineInventory);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__LineInventory*>(p->ptr), _tempuri__LineInventory);
		break;
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__LineInventoryResponse*>(p->ptr), _tempuri__LineInventoryResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__LineInventoryResponse*>(p->ptr), _tempuri__LineInventoryResponse);
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__LineInventoryUpdate*>(p->ptr), _tempuri__LineInventoryUpdate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__LineInventoryUpdate*>(p->ptr), _tempuri__LineInventoryUpdate);
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__LineInventoryUpdateResponse*>(p->ptr), _tempuri__LineInventoryUpdateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__LineInventoryUpdateResponse*>(p->ptr), _tempuri__LineInventoryUpdateResponse);
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__LineInventoryReturn*>(p->ptr), _tempuri__LineInventoryReturn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__LineInventoryReturn*>(p->ptr), _tempuri__LineInventoryReturn);
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__LineInventoryReturnResponse*>(p->ptr), _tempuri__LineInventoryReturnResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__LineInventoryReturnResponse*>(p->ptr), _tempuri__LineInventoryReturnResponse);
		break;
	case SOAP_TYPE__tempuri__ItemsAdd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__ItemsAdd*>(p->ptr), _tempuri__ItemsAdd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__ItemsAdd*>(p->ptr), _tempuri__ItemsAdd);
		break;
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__ItemsAddResponse*>(p->ptr), _tempuri__ItemsAddResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__ItemsAddResponse*>(p->ptr), _tempuri__ItemsAddResponse);
		break;
	case SOAP_TYPE__tempuri__DocAdd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__DocAdd*>(p->ptr), _tempuri__DocAdd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__DocAdd*>(p->ptr), _tempuri__DocAdd);
		break;
	case SOAP_TYPE__tempuri__DocAddResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__DocAddResponse*>(p->ptr), _tempuri__DocAddResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__DocAddResponse*>(p->ptr), _tempuri__DocAddResponse);
		break;
	case SOAP_TYPE__tempuri__GetDept:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetDept*>(p->ptr), _tempuri__GetDept);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetDept*>(p->ptr), _tempuri__GetDept);
		break;
	case SOAP_TYPE__tempuri__GetDeptResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetDeptResponse*>(p->ptr), _tempuri__GetDeptResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetDeptResponse*>(p->ptr), _tempuri__GetDeptResponse);
		break;
	case SOAP_TYPE__tempuri__GetPower:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetPower*>(p->ptr), _tempuri__GetPower);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetPower*>(p->ptr), _tempuri__GetPower);
		break;
	case SOAP_TYPE__tempuri__GetPowerResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__GetPowerResponse*>(p->ptr), _tempuri__GetPowerResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__GetPowerResponse*>(p->ptr), _tempuri__GetPowerResponse);
		break;
	case SOAP_TYPE__tempuri__Login:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__Login*>(p->ptr), _tempuri__Login);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__Login*>(p->ptr), _tempuri__Login);
		break;
	case SOAP_TYPE__tempuri__LoginResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__LoginResponse*>(p->ptr), _tempuri__LoginResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__LoginResponse*>(p->ptr), _tempuri__LoginResponse);
		break;
	case SOAP_TYPE__tempuri__AnDan1Send:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDan1Send*>(p->ptr), _tempuri__AnDan1Send);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDan1Send*>(p->ptr), _tempuri__AnDan1Send);
		break;
	case SOAP_TYPE__tempuri__AnDan1SendResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDan1SendResponse*>(p->ptr), _tempuri__AnDan1SendResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDan1SendResponse*>(p->ptr), _tempuri__AnDan1SendResponse);
		break;
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDan4UpdPeoplePresent*>(p->ptr), _tempuri__AnDan4UpdPeoplePresent);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDan4UpdPeoplePresent*>(p->ptr), _tempuri__AnDan4UpdPeoplePresent);
		break;
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDan4UpdPeoplePresentResponse*>(p->ptr), _tempuri__AnDan4UpdPeoplePresentResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDan4UpdPeoplePresentResponse*>(p->ptr), _tempuri__AnDan4UpdPeoplePresentResponse);
		break;
	case SOAP_TYPE__tempuri__AnDan3AddUsers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDan3AddUsers*>(p->ptr), _tempuri__AnDan3AddUsers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDan3AddUsers*>(p->ptr), _tempuri__AnDan3AddUsers);
		break;
	case SOAP_TYPE__tempuri__AnDan3AddUsersResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDan3AddUsersResponse*>(p->ptr), _tempuri__AnDan3AddUsersResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDan3AddUsersResponse*>(p->ptr), _tempuri__AnDan3AddUsersResponse);
		break;
	case SOAP_TYPE__tempuri__AnDan2PeoplePresent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDan2PeoplePresent*>(p->ptr), _tempuri__AnDan2PeoplePresent);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDan2PeoplePresent*>(p->ptr), _tempuri__AnDan2PeoplePresent);
		break;
	case SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDan2PeoplePresentResponse*>(p->ptr), _tempuri__AnDan2PeoplePresentResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDan2PeoplePresentResponse*>(p->ptr), _tempuri__AnDan2PeoplePresentResponse);
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeGet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDanSLTypeGet*>(p->ptr), _tempuri__AnDanSLTypeGet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDanSLTypeGet*>(p->ptr), _tempuri__AnDanSLTypeGet);
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeGetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDanSLTypeGetResponse*>(p->ptr), _tempuri__AnDanSLTypeGetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDanSLTypeGetResponse*>(p->ptr), _tempuri__AnDanSLTypeGetResponse);
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeAdd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDanSLTypeAdd*>(p->ptr), _tempuri__AnDanSLTypeAdd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDanSLTypeAdd*>(p->ptr), _tempuri__AnDanSLTypeAdd);
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeAddResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tempuri__AnDanSLTypeAddResponse*>(p->ptr), _tempuri__AnDanSLTypeAddResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tempuri__AnDanSLTypeAddResponse*>(p->ptr), _tempuri__AnDanSLTypeAddResponse);
		break;
	case SOAP_TYPE___tempuri__GetDate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetDate*>(p->ptr), struct __tempuri__GetDate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetDate*>(p->ptr), struct __tempuri__GetDate);
		break;
	case SOAP_TYPE___tempuri__GetDocCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetDocCode*>(p->ptr), struct __tempuri__GetDocCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetDocCode*>(p->ptr), struct __tempuri__GetDocCode);
		break;
	case SOAP_TYPE___tempuri__ToolingTimes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__ToolingTimes*>(p->ptr), struct __tempuri__ToolingTimes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__ToolingTimes*>(p->ptr), struct __tempuri__ToolingTimes);
		break;
	case SOAP_TYPE___tempuri__WorkOrder:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__WorkOrder*>(p->ptr), struct __tempuri__WorkOrder);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__WorkOrder*>(p->ptr), struct __tempuri__WorkOrder);
		break;
	case SOAP_TYPE___tempuri__LineInventory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__LineInventory*>(p->ptr), struct __tempuri__LineInventory);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__LineInventory*>(p->ptr), struct __tempuri__LineInventory);
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__LineInventoryUpdate*>(p->ptr), struct __tempuri__LineInventoryUpdate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__LineInventoryUpdate*>(p->ptr), struct __tempuri__LineInventoryUpdate);
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__LineInventoryReturn*>(p->ptr), struct __tempuri__LineInventoryReturn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__LineInventoryReturn*>(p->ptr), struct __tempuri__LineInventoryReturn);
		break;
	case SOAP_TYPE___tempuri__ItemsAdd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__ItemsAdd*>(p->ptr), struct __tempuri__ItemsAdd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__ItemsAdd*>(p->ptr), struct __tempuri__ItemsAdd);
		break;
	case SOAP_TYPE___tempuri__DocAdd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__DocAdd*>(p->ptr), struct __tempuri__DocAdd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__DocAdd*>(p->ptr), struct __tempuri__DocAdd);
		break;
	case SOAP_TYPE___tempuri__GetDept:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetDept*>(p->ptr), struct __tempuri__GetDept);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetDept*>(p->ptr), struct __tempuri__GetDept);
		break;
	case SOAP_TYPE___tempuri__GetPower:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetPower*>(p->ptr), struct __tempuri__GetPower);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetPower*>(p->ptr), struct __tempuri__GetPower);
		break;
	case SOAP_TYPE___tempuri__Login:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__Login*>(p->ptr), struct __tempuri__Login);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__Login*>(p->ptr), struct __tempuri__Login);
		break;
	case SOAP_TYPE___tempuri__AnDan1Send:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDan1Send*>(p->ptr), struct __tempuri__AnDan1Send);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDan1Send*>(p->ptr), struct __tempuri__AnDan1Send);
		break;
	case SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDan4UpdPeoplePresent*>(p->ptr), struct __tempuri__AnDan4UpdPeoplePresent);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDan4UpdPeoplePresent*>(p->ptr), struct __tempuri__AnDan4UpdPeoplePresent);
		break;
	case SOAP_TYPE___tempuri__AnDan3AddUsers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDan3AddUsers*>(p->ptr), struct __tempuri__AnDan3AddUsers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDan3AddUsers*>(p->ptr), struct __tempuri__AnDan3AddUsers);
		break;
	case SOAP_TYPE___tempuri__AnDan2PeoplePresent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDan2PeoplePresent*>(p->ptr), struct __tempuri__AnDan2PeoplePresent);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDan2PeoplePresent*>(p->ptr), struct __tempuri__AnDan2PeoplePresent);
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeGet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDanSLTypeGet*>(p->ptr), struct __tempuri__AnDanSLTypeGet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDanSLTypeGet*>(p->ptr), struct __tempuri__AnDanSLTypeGet);
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeAdd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDanSLTypeAdd*>(p->ptr), struct __tempuri__AnDanSLTypeAdd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDanSLTypeAdd*>(p->ptr), struct __tempuri__AnDanSLTypeAdd);
		break;
	case SOAP_TYPE___tempuri__GetDate_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetDate_*>(p->ptr), struct __tempuri__GetDate_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetDate_*>(p->ptr), struct __tempuri__GetDate_);
		break;
	case SOAP_TYPE___tempuri__GetDocCode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetDocCode_*>(p->ptr), struct __tempuri__GetDocCode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetDocCode_*>(p->ptr), struct __tempuri__GetDocCode_);
		break;
	case SOAP_TYPE___tempuri__ToolingTimes_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__ToolingTimes_*>(p->ptr), struct __tempuri__ToolingTimes_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__ToolingTimes_*>(p->ptr), struct __tempuri__ToolingTimes_);
		break;
	case SOAP_TYPE___tempuri__WorkOrder_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__WorkOrder_*>(p->ptr), struct __tempuri__WorkOrder_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__WorkOrder_*>(p->ptr), struct __tempuri__WorkOrder_);
		break;
	case SOAP_TYPE___tempuri__LineInventory_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__LineInventory_*>(p->ptr), struct __tempuri__LineInventory_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__LineInventory_*>(p->ptr), struct __tempuri__LineInventory_);
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__LineInventoryUpdate_*>(p->ptr), struct __tempuri__LineInventoryUpdate_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__LineInventoryUpdate_*>(p->ptr), struct __tempuri__LineInventoryUpdate_);
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__LineInventoryReturn_*>(p->ptr), struct __tempuri__LineInventoryReturn_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__LineInventoryReturn_*>(p->ptr), struct __tempuri__LineInventoryReturn_);
		break;
	case SOAP_TYPE___tempuri__ItemsAdd_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__ItemsAdd_*>(p->ptr), struct __tempuri__ItemsAdd_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__ItemsAdd_*>(p->ptr), struct __tempuri__ItemsAdd_);
		break;
	case SOAP_TYPE___tempuri__DocAdd_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__DocAdd_*>(p->ptr), struct __tempuri__DocAdd_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__DocAdd_*>(p->ptr), struct __tempuri__DocAdd_);
		break;
	case SOAP_TYPE___tempuri__GetDept_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetDept_*>(p->ptr), struct __tempuri__GetDept_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetDept_*>(p->ptr), struct __tempuri__GetDept_);
		break;
	case SOAP_TYPE___tempuri__GetPower_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetPower_*>(p->ptr), struct __tempuri__GetPower_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetPower_*>(p->ptr), struct __tempuri__GetPower_);
		break;
	case SOAP_TYPE___tempuri__Login_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__Login_*>(p->ptr), struct __tempuri__Login_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__Login_*>(p->ptr), struct __tempuri__Login_);
		break;
	case SOAP_TYPE___tempuri__AnDan1Send_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDan1Send_*>(p->ptr), struct __tempuri__AnDan1Send_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDan1Send_*>(p->ptr), struct __tempuri__AnDan1Send_);
		break;
	case SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDan4UpdPeoplePresent_*>(p->ptr), struct __tempuri__AnDan4UpdPeoplePresent_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDan4UpdPeoplePresent_*>(p->ptr), struct __tempuri__AnDan4UpdPeoplePresent_);
		break;
	case SOAP_TYPE___tempuri__AnDan3AddUsers_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDan3AddUsers_*>(p->ptr), struct __tempuri__AnDan3AddUsers_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDan3AddUsers_*>(p->ptr), struct __tempuri__AnDan3AddUsers_);
		break;
	case SOAP_TYPE___tempuri__AnDan2PeoplePresent_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDan2PeoplePresent_*>(p->ptr), struct __tempuri__AnDan2PeoplePresent_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDan2PeoplePresent_*>(p->ptr), struct __tempuri__AnDan2PeoplePresent_);
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeGet_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDanSLTypeGet_*>(p->ptr), struct __tempuri__AnDanSLTypeGet_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDanSLTypeGet_*>(p->ptr), struct __tempuri__AnDanSLTypeGet_);
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeAdd_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AnDanSLTypeAdd_*>(p->ptr), struct __tempuri__AnDanSLTypeAdd_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AnDanSLTypeAdd_*>(p->ptr), struct __tempuri__AnDanSLTypeAdd_);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE__tempuri__GetDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDate type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDate*)p = *(_tempuri__GetDate*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__tempuri__GetDateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDateResponse*)p = *(_tempuri__GetDateResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetDocCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDocCode type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDocCode*)p = *(_tempuri__GetDocCode*)q;
		break;
	case SOAP_TYPE__tempuri__GetDocCodeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDocCodeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDocCodeResponse*)p = *(_tempuri__GetDocCodeResponse*)q;
		break;
	case SOAP_TYPE__tempuri__ToolingTimes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ToolingTimes type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ToolingTimes*)p = *(_tempuri__ToolingTimes*)q;
		break;
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ToolingTimesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ToolingTimesResponse*)p = *(_tempuri__ToolingTimesResponse*)q;
		break;
	case SOAP_TYPE__tempuri__WorkOrder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__WorkOrder type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__WorkOrder*)p = *(_tempuri__WorkOrder*)q;
		break;
	case SOAP_TYPE__tempuri__WorkOrderResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__WorkOrderResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__WorkOrderResponse*)p = *(_tempuri__WorkOrderResponse*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventory type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventory*)p = *(_tempuri__LineInventory*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryResponse*)p = *(_tempuri__LineInventoryResponse*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryUpdate type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryUpdate*)p = *(_tempuri__LineInventoryUpdate*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryUpdateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryUpdateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryUpdateResponse*)p = *(_tempuri__LineInventoryUpdateResponse*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryReturn type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryReturn*)p = *(_tempuri__LineInventoryReturn*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryReturnResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryReturnResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryReturnResponse*)p = *(_tempuri__LineInventoryReturnResponse*)q;
		break;
	case SOAP_TYPE__tempuri__ItemsAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ItemsAdd type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ItemsAdd*)p = *(_tempuri__ItemsAdd*)q;
		break;
	case SOAP_TYPE__tempuri__ItemsAddResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ItemsAddResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ItemsAddResponse*)p = *(_tempuri__ItemsAddResponse*)q;
		break;
	case SOAP_TYPE__tempuri__DocAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__DocAdd type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__DocAdd*)p = *(_tempuri__DocAdd*)q;
		break;
	case SOAP_TYPE__tempuri__DocAddResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__DocAddResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__DocAddResponse*)p = *(_tempuri__DocAddResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetDept:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDept type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDept*)p = *(_tempuri__GetDept*)q;
		break;
	case SOAP_TYPE__tempuri__GetDeptResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetDeptResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetDeptResponse*)p = *(_tempuri__GetDeptResponse*)q;
		break;
	case SOAP_TYPE__tempuri__GetPower:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetPower type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetPower*)p = *(_tempuri__GetPower*)q;
		break;
	case SOAP_TYPE__tempuri__GetPowerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__GetPowerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__GetPowerResponse*)p = *(_tempuri__GetPowerResponse*)q;
		break;
	case SOAP_TYPE__tempuri__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__Login type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__Login*)p = *(_tempuri__Login*)q;
		break;
	case SOAP_TYPE__tempuri__LoginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LoginResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LoginResponse*)p = *(_tempuri__LoginResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDan1Send:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDan1Send type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDan1Send*)p = *(_tempuri__AnDan1Send*)q;
		break;
	case SOAP_TYPE__tempuri__AnDan1SendResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDan1SendResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDan1SendResponse*)p = *(_tempuri__AnDan1SendResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDan4UpdPeoplePresent type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDan4UpdPeoplePresent*)p = *(_tempuri__AnDan4UpdPeoplePresent*)q;
		break;
	case SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDan4UpdPeoplePresentResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDan4UpdPeoplePresentResponse*)p = *(_tempuri__AnDan4UpdPeoplePresentResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDan3AddUsers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDan3AddUsers type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDan3AddUsers*)p = *(_tempuri__AnDan3AddUsers*)q;
		break;
	case SOAP_TYPE__tempuri__AnDan3AddUsersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDan3AddUsersResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDan3AddUsersResponse*)p = *(_tempuri__AnDan3AddUsersResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDan2PeoplePresent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDan2PeoplePresent type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDan2PeoplePresent*)p = *(_tempuri__AnDan2PeoplePresent*)q;
		break;
	case SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDan2PeoplePresentResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDan2PeoplePresentResponse*)p = *(_tempuri__AnDan2PeoplePresentResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDanSLTypeGet type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDanSLTypeGet*)p = *(_tempuri__AnDanSLTypeGet*)q;
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeGetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDanSLTypeGetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDanSLTypeGetResponse*)p = *(_tempuri__AnDanSLTypeGetResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDanSLTypeAdd type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDanSLTypeAdd*)p = *(_tempuri__AnDanSLTypeAdd*)q;
		break;
	case SOAP_TYPE__tempuri__AnDanSLTypeAddResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDanSLTypeAddResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDanSLTypeAddResponse*)p = *(_tempuri__AnDanSLTypeAddResponse*)q;
		break;
	case SOAP_TYPE___tempuri__GetDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDate type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDate*)p = *(struct __tempuri__GetDate*)q;
		break;
	case SOAP_TYPE___tempuri__GetDocCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDocCode type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDocCode*)p = *(struct __tempuri__GetDocCode*)q;
		break;
	case SOAP_TYPE___tempuri__ToolingTimes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__ToolingTimes type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__ToolingTimes*)p = *(struct __tempuri__ToolingTimes*)q;
		break;
	case SOAP_TYPE___tempuri__WorkOrder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__WorkOrder type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__WorkOrder*)p = *(struct __tempuri__WorkOrder*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventory type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventory*)p = *(struct __tempuri__LineInventory*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventoryUpdate type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventoryUpdate*)p = *(struct __tempuri__LineInventoryUpdate*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventoryReturn type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventoryReturn*)p = *(struct __tempuri__LineInventoryReturn*)q;
		break;
	case SOAP_TYPE___tempuri__ItemsAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__ItemsAdd type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__ItemsAdd*)p = *(struct __tempuri__ItemsAdd*)q;
		break;
	case SOAP_TYPE___tempuri__DocAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__DocAdd type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__DocAdd*)p = *(struct __tempuri__DocAdd*)q;
		break;
	case SOAP_TYPE___tempuri__GetDept:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDept type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDept*)p = *(struct __tempuri__GetDept*)q;
		break;
	case SOAP_TYPE___tempuri__GetPower:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetPower type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetPower*)p = *(struct __tempuri__GetPower*)q;
		break;
	case SOAP_TYPE___tempuri__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__Login type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__Login*)p = *(struct __tempuri__Login*)q;
		break;
	case SOAP_TYPE___tempuri__AnDan1Send:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDan1Send type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDan1Send*)p = *(struct __tempuri__AnDan1Send*)q;
		break;
	case SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDan4UpdPeoplePresent type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDan4UpdPeoplePresent*)p = *(struct __tempuri__AnDan4UpdPeoplePresent*)q;
		break;
	case SOAP_TYPE___tempuri__AnDan3AddUsers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDan3AddUsers type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDan3AddUsers*)p = *(struct __tempuri__AnDan3AddUsers*)q;
		break;
	case SOAP_TYPE___tempuri__AnDan2PeoplePresent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDan2PeoplePresent type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDan2PeoplePresent*)p = *(struct __tempuri__AnDan2PeoplePresent*)q;
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDanSLTypeGet type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDanSLTypeGet*)p = *(struct __tempuri__AnDanSLTypeGet*)q;
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDanSLTypeAdd type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDanSLTypeAdd*)p = *(struct __tempuri__AnDanSLTypeAdd*)q;
		break;
	case SOAP_TYPE___tempuri__GetDate_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDate_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDate_*)p = *(struct __tempuri__GetDate_*)q;
		break;
	case SOAP_TYPE___tempuri__GetDocCode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDocCode_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDocCode_*)p = *(struct __tempuri__GetDocCode_*)q;
		break;
	case SOAP_TYPE___tempuri__ToolingTimes_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__ToolingTimes_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__ToolingTimes_*)p = *(struct __tempuri__ToolingTimes_*)q;
		break;
	case SOAP_TYPE___tempuri__WorkOrder_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__WorkOrder_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__WorkOrder_*)p = *(struct __tempuri__WorkOrder_*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventory_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventory_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventory_*)p = *(struct __tempuri__LineInventory_*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventoryUpdate_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventoryUpdate_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventoryUpdate_*)p = *(struct __tempuri__LineInventoryUpdate_*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventoryReturn_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventoryReturn_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventoryReturn_*)p = *(struct __tempuri__LineInventoryReturn_*)q;
		break;
	case SOAP_TYPE___tempuri__ItemsAdd_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__ItemsAdd_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__ItemsAdd_*)p = *(struct __tempuri__ItemsAdd_*)q;
		break;
	case SOAP_TYPE___tempuri__DocAdd_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__DocAdd_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__DocAdd_*)p = *(struct __tempuri__DocAdd_*)q;
		break;
	case SOAP_TYPE___tempuri__GetDept_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetDept_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetDept_*)p = *(struct __tempuri__GetDept_*)q;
		break;
	case SOAP_TYPE___tempuri__GetPower_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetPower_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetPower_*)p = *(struct __tempuri__GetPower_*)q;
		break;
	case SOAP_TYPE___tempuri__Login_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__Login_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__Login_*)p = *(struct __tempuri__Login_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDan1Send_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDan1Send_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDan1Send_*)p = *(struct __tempuri__AnDan1Send_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDan4UpdPeoplePresent_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDan4UpdPeoplePresent_*)p = *(struct __tempuri__AnDan4UpdPeoplePresent_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDan3AddUsers_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDan3AddUsers_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDan3AddUsers_*)p = *(struct __tempuri__AnDan3AddUsers_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDan2PeoplePresent_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDan2PeoplePresent_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDan2PeoplePresent_*)p = *(struct __tempuri__AnDan2PeoplePresent_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeGet_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDanSLTypeGet_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDanSLTypeGet_*)p = *(struct __tempuri__AnDanSLTypeGet_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDanSLTypeAdd_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDanSLTypeAdd_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDanSLTypeAdd_*)p = *(struct __tempuri__AnDanSLTypeAdd_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_dup_std__string(struct soap *soap, std::string *d, std::string const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (std::string*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_std__string, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_std__string(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	*d = *a;
	return d;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDanSLTypeAddResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDanSLTypeAddResponse::AnDanSLTypeAddResult = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDanSLTypeAddResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDanSLTypeAddResponse::AnDanSLTypeAddResult);
#endif
}

int _tempuri__AnDanSLTypeAddResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDanSLTypeAddResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDanSLTypeAddResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDanSLTypeAddResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDanSLTypeAddResponse), type))
		return soap->error;
	if (a->AnDanSLTypeAddResult)
		soap_element_result(soap, "tempuri:AnDanSLTypeAddResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:AnDanSLTypeAddResult", -1, &a->_tempuri__AnDanSLTypeAddResponse::AnDanSLTypeAddResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDanSLTypeAddResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDanSLTypeAddResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeAddResponse * SOAP_FMAC4 soap_in__tempuri__AnDanSLTypeAddResponse(struct soap *soap, const char *tag, _tempuri__AnDanSLTypeAddResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDanSLTypeAddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDanSLTypeAddResponse, sizeof(_tempuri__AnDanSLTypeAddResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDanSLTypeAddResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDanSLTypeAddResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDanSLTypeAddResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDanSLTypeAddResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:AnDanSLTypeAddResult", &a->_tempuri__AnDanSLTypeAddResponse::AnDanSLTypeAddResult, "xsd:string"))
				{	soap_flag_AnDanSLTypeAddResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDanSLTypeAddResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDanSLTypeAddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDanSLTypeAddResponse, SOAP_TYPE__tempuri__AnDanSLTypeAddResponse, sizeof(_tempuri__AnDanSLTypeAddResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDanSLTypeAddResponse * SOAP_FMAC2 soap_dup__tempuri__AnDanSLTypeAddResponse(struct soap *soap, _tempuri__AnDanSLTypeAddResponse *d, _tempuri__AnDanSLTypeAddResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDanSLTypeAddResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDanSLTypeAddResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDanSLTypeAddResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDanSLTypeAddResponse::AnDanSLTypeAddResult, &a->_tempuri__AnDanSLTypeAddResponse::AnDanSLTypeAddResult);
	d->_tempuri__AnDanSLTypeAddResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDanSLTypeAddResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDanSLTypeAddResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDanSLTypeAddResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDanSLTypeAddResponse *p;
	size_t k = sizeof(_tempuri__AnDanSLTypeAddResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDanSLTypeAddResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDanSLTypeAddResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDanSLTypeAddResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDanSLTypeAddResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDanSLTypeAddResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDanSLTypeAddResponse(soap, tag ? tag : "tempuri:AnDanSLTypeAddResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDanSLTypeAddResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDanSLTypeAddResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeAddResponse * SOAP_FMAC4 soap_get__tempuri__AnDanSLTypeAddResponse(struct soap *soap, _tempuri__AnDanSLTypeAddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDanSLTypeAddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDanSLTypeAdd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDanSLTypeAdd::XML_ = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDanSLTypeAdd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDanSLTypeAdd::XML_);
#endif
}

int _tempuri__AnDanSLTypeAdd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDanSLTypeAdd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDanSLTypeAdd(struct soap *soap, const char *tag, int id, const _tempuri__AnDanSLTypeAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDanSLTypeAdd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:XML", -1, &a->_tempuri__AnDanSLTypeAdd::XML_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDanSLTypeAdd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDanSLTypeAdd(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeAdd * SOAP_FMAC4 soap_in__tempuri__AnDanSLTypeAdd(struct soap *soap, const char *tag, _tempuri__AnDanSLTypeAdd *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDanSLTypeAdd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDanSLTypeAdd, sizeof(_tempuri__AnDanSLTypeAdd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDanSLTypeAdd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDanSLTypeAdd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XML_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XML_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:XML", &a->_tempuri__AnDanSLTypeAdd::XML_, "xsd:string"))
				{	soap_flag_XML_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDanSLTypeAdd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDanSLTypeAdd, SOAP_TYPE__tempuri__AnDanSLTypeAdd, sizeof(_tempuri__AnDanSLTypeAdd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDanSLTypeAdd * SOAP_FMAC2 soap_dup__tempuri__AnDanSLTypeAdd(struct soap *soap, _tempuri__AnDanSLTypeAdd *d, _tempuri__AnDanSLTypeAdd const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDanSLTypeAdd*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDanSLTypeAdd, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDanSLTypeAdd(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDanSLTypeAdd::XML_, &a->_tempuri__AnDanSLTypeAdd::XML_);
	d->_tempuri__AnDanSLTypeAdd::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDanSLTypeAdd * SOAP_FMAC2 soap_instantiate__tempuri__AnDanSLTypeAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDanSLTypeAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDanSLTypeAdd *p;
	size_t k = sizeof(_tempuri__AnDanSLTypeAdd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDanSLTypeAdd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDanSLTypeAdd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDanSLTypeAdd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDanSLTypeAdd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDanSLTypeAdd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDanSLTypeAdd(soap, tag ? tag : "tempuri:AnDanSLTypeAdd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDanSLTypeAdd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDanSLTypeAdd(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeAdd * SOAP_FMAC4 soap_get__tempuri__AnDanSLTypeAdd(struct soap *soap, _tempuri__AnDanSLTypeAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDanSLTypeAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDanSLTypeGetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDanSLTypeGetResponse::AnDanSLTypeGetResult = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDanSLTypeGetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDanSLTypeGetResponse::AnDanSLTypeGetResult);
#endif
}

int _tempuri__AnDanSLTypeGetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDanSLTypeGetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDanSLTypeGetResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDanSLTypeGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDanSLTypeGetResponse), type))
		return soap->error;
	if (a->AnDanSLTypeGetResult)
		soap_element_result(soap, "tempuri:AnDanSLTypeGetResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:AnDanSLTypeGetResult", -1, &a->_tempuri__AnDanSLTypeGetResponse::AnDanSLTypeGetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDanSLTypeGetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDanSLTypeGetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeGetResponse * SOAP_FMAC4 soap_in__tempuri__AnDanSLTypeGetResponse(struct soap *soap, const char *tag, _tempuri__AnDanSLTypeGetResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDanSLTypeGetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDanSLTypeGetResponse, sizeof(_tempuri__AnDanSLTypeGetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDanSLTypeGetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDanSLTypeGetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDanSLTypeGetResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDanSLTypeGetResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:AnDanSLTypeGetResult", &a->_tempuri__AnDanSLTypeGetResponse::AnDanSLTypeGetResult, "xsd:string"))
				{	soap_flag_AnDanSLTypeGetResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDanSLTypeGetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDanSLTypeGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDanSLTypeGetResponse, SOAP_TYPE__tempuri__AnDanSLTypeGetResponse, sizeof(_tempuri__AnDanSLTypeGetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDanSLTypeGetResponse * SOAP_FMAC2 soap_dup__tempuri__AnDanSLTypeGetResponse(struct soap *soap, _tempuri__AnDanSLTypeGetResponse *d, _tempuri__AnDanSLTypeGetResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDanSLTypeGetResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDanSLTypeGetResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDanSLTypeGetResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDanSLTypeGetResponse::AnDanSLTypeGetResult, &a->_tempuri__AnDanSLTypeGetResponse::AnDanSLTypeGetResult);
	d->_tempuri__AnDanSLTypeGetResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDanSLTypeGetResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDanSLTypeGetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDanSLTypeGetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDanSLTypeGetResponse *p;
	size_t k = sizeof(_tempuri__AnDanSLTypeGetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDanSLTypeGetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDanSLTypeGetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDanSLTypeGetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDanSLTypeGetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDanSLTypeGetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDanSLTypeGetResponse(soap, tag ? tag : "tempuri:AnDanSLTypeGetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDanSLTypeGetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDanSLTypeGetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeGetResponse * SOAP_FMAC4 soap_get__tempuri__AnDanSLTypeGetResponse(struct soap *soap, _tempuri__AnDanSLTypeGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDanSLTypeGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDanSLTypeGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDanSLTypeGet::ADMCode = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDanSLTypeGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDanSLTypeGet::ADMCode);
#endif
}

int _tempuri__AnDanSLTypeGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDanSLTypeGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDanSLTypeGet(struct soap *soap, const char *tag, int id, const _tempuri__AnDanSLTypeGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDanSLTypeGet), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:ADMCode", -1, &a->_tempuri__AnDanSLTypeGet::ADMCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDanSLTypeGet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDanSLTypeGet(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeGet * SOAP_FMAC4 soap_in__tempuri__AnDanSLTypeGet(struct soap *soap, const char *tag, _tempuri__AnDanSLTypeGet *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDanSLTypeGet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDanSLTypeGet, sizeof(_tempuri__AnDanSLTypeGet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDanSLTypeGet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDanSLTypeGet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ADMCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ADMCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:ADMCode", &a->_tempuri__AnDanSLTypeGet::ADMCode, "xsd:string"))
				{	soap_flag_ADMCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDanSLTypeGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDanSLTypeGet, SOAP_TYPE__tempuri__AnDanSLTypeGet, sizeof(_tempuri__AnDanSLTypeGet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDanSLTypeGet * SOAP_FMAC2 soap_dup__tempuri__AnDanSLTypeGet(struct soap *soap, _tempuri__AnDanSLTypeGet *d, _tempuri__AnDanSLTypeGet const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDanSLTypeGet*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDanSLTypeGet, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDanSLTypeGet(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDanSLTypeGet::ADMCode, &a->_tempuri__AnDanSLTypeGet::ADMCode);
	d->_tempuri__AnDanSLTypeGet::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDanSLTypeGet * SOAP_FMAC2 soap_instantiate__tempuri__AnDanSLTypeGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDanSLTypeGet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDanSLTypeGet *p;
	size_t k = sizeof(_tempuri__AnDanSLTypeGet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDanSLTypeGet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDanSLTypeGet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDanSLTypeGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDanSLTypeGet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDanSLTypeGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDanSLTypeGet(soap, tag ? tag : "tempuri:AnDanSLTypeGet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDanSLTypeGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDanSLTypeGet(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeGet * SOAP_FMAC4 soap_get__tempuri__AnDanSLTypeGet(struct soap *soap, _tempuri__AnDanSLTypeGet *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDanSLTypeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDan2PeoplePresentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDan2PeoplePresentResponse::AnDan2PeoplePresentResult = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDan2PeoplePresentResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDan2PeoplePresentResponse::AnDan2PeoplePresentResult);
#endif
}

int _tempuri__AnDan2PeoplePresentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDan2PeoplePresentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDan2PeoplePresentResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDan2PeoplePresentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse), type))
		return soap->error;
	if (a->AnDan2PeoplePresentResult)
		soap_element_result(soap, "tempuri:AnDan2PeoplePresentResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:AnDan2PeoplePresentResult", -1, &a->_tempuri__AnDan2PeoplePresentResponse::AnDan2PeoplePresentResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDan2PeoplePresentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDan2PeoplePresentResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDan2PeoplePresentResponse * SOAP_FMAC4 soap_in__tempuri__AnDan2PeoplePresentResponse(struct soap *soap, const char *tag, _tempuri__AnDan2PeoplePresentResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDan2PeoplePresentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse, sizeof(_tempuri__AnDan2PeoplePresentResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDan2PeoplePresentResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDan2PeoplePresentResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDan2PeoplePresentResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:AnDan2PeoplePresentResult", &a->_tempuri__AnDan2PeoplePresentResponse::AnDan2PeoplePresentResult, "xsd:string"))
				{	soap_flag_AnDan2PeoplePresentResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDan2PeoplePresentResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDan2PeoplePresentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse, SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse, sizeof(_tempuri__AnDan2PeoplePresentResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan2PeoplePresentResponse * SOAP_FMAC2 soap_dup__tempuri__AnDan2PeoplePresentResponse(struct soap *soap, _tempuri__AnDan2PeoplePresentResponse *d, _tempuri__AnDan2PeoplePresentResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDan2PeoplePresentResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDan2PeoplePresentResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDan2PeoplePresentResponse::AnDan2PeoplePresentResult, &a->_tempuri__AnDan2PeoplePresentResponse::AnDan2PeoplePresentResult);
	d->_tempuri__AnDan2PeoplePresentResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDan2PeoplePresentResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDan2PeoplePresentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDan2PeoplePresentResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDan2PeoplePresentResponse *p;
	size_t k = sizeof(_tempuri__AnDan2PeoplePresentResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDan2PeoplePresentResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDan2PeoplePresentResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDan2PeoplePresentResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDan2PeoplePresentResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDan2PeoplePresentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDan2PeoplePresentResponse(soap, tag ? tag : "tempuri:AnDan2PeoplePresentResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDan2PeoplePresentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDan2PeoplePresentResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDan2PeoplePresentResponse * SOAP_FMAC4 soap_get__tempuri__AnDan2PeoplePresentResponse(struct soap *soap, _tempuri__AnDan2PeoplePresentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDan2PeoplePresentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDan2PeoplePresent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDan2PeoplePresent::ADMCode = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDan2PeoplePresent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDan2PeoplePresent::ADMCode);
#endif
}

int _tempuri__AnDan2PeoplePresent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDan2PeoplePresent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDan2PeoplePresent(struct soap *soap, const char *tag, int id, const _tempuri__AnDan2PeoplePresent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDan2PeoplePresent), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:ADMCode", -1, &a->_tempuri__AnDan2PeoplePresent::ADMCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDan2PeoplePresent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDan2PeoplePresent(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDan2PeoplePresent * SOAP_FMAC4 soap_in__tempuri__AnDan2PeoplePresent(struct soap *soap, const char *tag, _tempuri__AnDan2PeoplePresent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDan2PeoplePresent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDan2PeoplePresent, sizeof(_tempuri__AnDan2PeoplePresent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDan2PeoplePresent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDan2PeoplePresent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ADMCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ADMCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:ADMCode", &a->_tempuri__AnDan2PeoplePresent::ADMCode, "xsd:string"))
				{	soap_flag_ADMCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDan2PeoplePresent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDan2PeoplePresent, SOAP_TYPE__tempuri__AnDan2PeoplePresent, sizeof(_tempuri__AnDan2PeoplePresent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan2PeoplePresent * SOAP_FMAC2 soap_dup__tempuri__AnDan2PeoplePresent(struct soap *soap, _tempuri__AnDan2PeoplePresent *d, _tempuri__AnDan2PeoplePresent const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDan2PeoplePresent*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDan2PeoplePresent, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDan2PeoplePresent(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDan2PeoplePresent::ADMCode, &a->_tempuri__AnDan2PeoplePresent::ADMCode);
	d->_tempuri__AnDan2PeoplePresent::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDan2PeoplePresent * SOAP_FMAC2 soap_instantiate__tempuri__AnDan2PeoplePresent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDan2PeoplePresent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDan2PeoplePresent *p;
	size_t k = sizeof(_tempuri__AnDan2PeoplePresent);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDan2PeoplePresent, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDan2PeoplePresent);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDan2PeoplePresent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDan2PeoplePresent location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDan2PeoplePresent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDan2PeoplePresent(soap, tag ? tag : "tempuri:AnDan2PeoplePresent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDan2PeoplePresent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDan2PeoplePresent(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDan2PeoplePresent * SOAP_FMAC4 soap_get__tempuri__AnDan2PeoplePresent(struct soap *soap, _tempuri__AnDan2PeoplePresent *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDan2PeoplePresent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDan3AddUsersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDan3AddUsersResponse::AnDan3AddUsersResult = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDan3AddUsersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDan3AddUsersResponse::AnDan3AddUsersResult);
#endif
}

int _tempuri__AnDan3AddUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDan3AddUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDan3AddUsersResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDan3AddUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDan3AddUsersResponse), type))
		return soap->error;
	if (a->AnDan3AddUsersResult)
		soap_element_result(soap, "tempuri:AnDan3AddUsersResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:AnDan3AddUsersResult", -1, &a->_tempuri__AnDan3AddUsersResponse::AnDan3AddUsersResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDan3AddUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDan3AddUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDan3AddUsersResponse * SOAP_FMAC4 soap_in__tempuri__AnDan3AddUsersResponse(struct soap *soap, const char *tag, _tempuri__AnDan3AddUsersResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDan3AddUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDan3AddUsersResponse, sizeof(_tempuri__AnDan3AddUsersResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDan3AddUsersResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDan3AddUsersResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDan3AddUsersResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDan3AddUsersResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:AnDan3AddUsersResult", &a->_tempuri__AnDan3AddUsersResponse::AnDan3AddUsersResult, "xsd:string"))
				{	soap_flag_AnDan3AddUsersResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDan3AddUsersResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDan3AddUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDan3AddUsersResponse, SOAP_TYPE__tempuri__AnDan3AddUsersResponse, sizeof(_tempuri__AnDan3AddUsersResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan3AddUsersResponse * SOAP_FMAC2 soap_dup__tempuri__AnDan3AddUsersResponse(struct soap *soap, _tempuri__AnDan3AddUsersResponse *d, _tempuri__AnDan3AddUsersResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDan3AddUsersResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDan3AddUsersResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDan3AddUsersResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDan3AddUsersResponse::AnDan3AddUsersResult, &a->_tempuri__AnDan3AddUsersResponse::AnDan3AddUsersResult);
	d->_tempuri__AnDan3AddUsersResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDan3AddUsersResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDan3AddUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDan3AddUsersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDan3AddUsersResponse *p;
	size_t k = sizeof(_tempuri__AnDan3AddUsersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDan3AddUsersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDan3AddUsersResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDan3AddUsersResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDan3AddUsersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDan3AddUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDan3AddUsersResponse(soap, tag ? tag : "tempuri:AnDan3AddUsersResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDan3AddUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDan3AddUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDan3AddUsersResponse * SOAP_FMAC4 soap_get__tempuri__AnDan3AddUsersResponse(struct soap *soap, _tempuri__AnDan3AddUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDan3AddUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDan3AddUsers::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDan3AddUsers::XML_ = NULL;
	this->_tempuri__AnDan3AddUsers::TS_USCOREOPERATORS = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDan3AddUsers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDan3AddUsers::XML_);
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDan3AddUsers::TS_USCOREOPERATORS);
#endif
}

int _tempuri__AnDan3AddUsers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDan3AddUsers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDan3AddUsers(struct soap *soap, const char *tag, int id, const _tempuri__AnDan3AddUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDan3AddUsers), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:XML", -1, &a->_tempuri__AnDan3AddUsers::XML_, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:TS_OPERATORS", -1, &a->_tempuri__AnDan3AddUsers::TS_USCOREOPERATORS, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDan3AddUsers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDan3AddUsers(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDan3AddUsers * SOAP_FMAC4 soap_in__tempuri__AnDan3AddUsers(struct soap *soap, const char *tag, _tempuri__AnDan3AddUsers *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDan3AddUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDan3AddUsers, sizeof(_tempuri__AnDan3AddUsers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDan3AddUsers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDan3AddUsers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XML_1 = 1;
	size_t soap_flag_TS_USCOREOPERATORS1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XML_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:XML", &a->_tempuri__AnDan3AddUsers::XML_, "xsd:string"))
				{	soap_flag_XML_1--;
					continue;
				}
			}
			if (soap_flag_TS_USCOREOPERATORS1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:TS_OPERATORS", &a->_tempuri__AnDan3AddUsers::TS_USCOREOPERATORS, "xsd:string"))
				{	soap_flag_TS_USCOREOPERATORS1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDan3AddUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDan3AddUsers, SOAP_TYPE__tempuri__AnDan3AddUsers, sizeof(_tempuri__AnDan3AddUsers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan3AddUsers * SOAP_FMAC2 soap_dup__tempuri__AnDan3AddUsers(struct soap *soap, _tempuri__AnDan3AddUsers *d, _tempuri__AnDan3AddUsers const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDan3AddUsers*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDan3AddUsers, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDan3AddUsers(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDan3AddUsers::XML_, &a->_tempuri__AnDan3AddUsers::XML_);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDan3AddUsers::TS_USCOREOPERATORS, &a->_tempuri__AnDan3AddUsers::TS_USCOREOPERATORS);
	d->_tempuri__AnDan3AddUsers::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDan3AddUsers * SOAP_FMAC2 soap_instantiate__tempuri__AnDan3AddUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDan3AddUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDan3AddUsers *p;
	size_t k = sizeof(_tempuri__AnDan3AddUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDan3AddUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDan3AddUsers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDan3AddUsers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDan3AddUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDan3AddUsers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDan3AddUsers(soap, tag ? tag : "tempuri:AnDan3AddUsers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDan3AddUsers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDan3AddUsers(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDan3AddUsers * SOAP_FMAC4 soap_get__tempuri__AnDan3AddUsers(struct soap *soap, _tempuri__AnDan3AddUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDan3AddUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDan4UpdPeoplePresentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDan4UpdPeoplePresentResponse::AnDan4UpdPeoplePresentResult = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDan4UpdPeoplePresentResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDan4UpdPeoplePresentResponse::AnDan4UpdPeoplePresentResult);
#endif
}

int _tempuri__AnDan4UpdPeoplePresentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDan4UpdPeoplePresentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDan4UpdPeoplePresentResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDan4UpdPeoplePresentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse), type))
		return soap->error;
	if (a->AnDan4UpdPeoplePresentResult)
		soap_element_result(soap, "tempuri:AnDan4UpdPeoplePresentResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:AnDan4UpdPeoplePresentResult", -1, &a->_tempuri__AnDan4UpdPeoplePresentResponse::AnDan4UpdPeoplePresentResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDan4UpdPeoplePresentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDan4UpdPeoplePresentResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDan4UpdPeoplePresentResponse * SOAP_FMAC4 soap_in__tempuri__AnDan4UpdPeoplePresentResponse(struct soap *soap, const char *tag, _tempuri__AnDan4UpdPeoplePresentResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDan4UpdPeoplePresentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse, sizeof(_tempuri__AnDan4UpdPeoplePresentResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDan4UpdPeoplePresentResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDan4UpdPeoplePresentResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDan4UpdPeoplePresentResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:AnDan4UpdPeoplePresentResult", &a->_tempuri__AnDan4UpdPeoplePresentResponse::AnDan4UpdPeoplePresentResult, "xsd:string"))
				{	soap_flag_AnDan4UpdPeoplePresentResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDan4UpdPeoplePresentResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDan4UpdPeoplePresentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse, sizeof(_tempuri__AnDan4UpdPeoplePresentResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan4UpdPeoplePresentResponse * SOAP_FMAC2 soap_dup__tempuri__AnDan4UpdPeoplePresentResponse(struct soap *soap, _tempuri__AnDan4UpdPeoplePresentResponse *d, _tempuri__AnDan4UpdPeoplePresentResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDan4UpdPeoplePresentResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDan4UpdPeoplePresentResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDan4UpdPeoplePresentResponse::AnDan4UpdPeoplePresentResult, &a->_tempuri__AnDan4UpdPeoplePresentResponse::AnDan4UpdPeoplePresentResult);
	d->_tempuri__AnDan4UpdPeoplePresentResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDan4UpdPeoplePresentResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDan4UpdPeoplePresentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDan4UpdPeoplePresentResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDan4UpdPeoplePresentResponse *p;
	size_t k = sizeof(_tempuri__AnDan4UpdPeoplePresentResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresentResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDan4UpdPeoplePresentResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDan4UpdPeoplePresentResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDan4UpdPeoplePresentResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDan4UpdPeoplePresentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDan4UpdPeoplePresentResponse(soap, tag ? tag : "tempuri:AnDan4UpdPeoplePresentResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDan4UpdPeoplePresentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDan4UpdPeoplePresentResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDan4UpdPeoplePresentResponse * SOAP_FMAC4 soap_get__tempuri__AnDan4UpdPeoplePresentResponse(struct soap *soap, _tempuri__AnDan4UpdPeoplePresentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDan4UpdPeoplePresentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDan4UpdPeoplePresent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDan4UpdPeoplePresent::Presens = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDan4UpdPeoplePresent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDan4UpdPeoplePresent::Presens);
#endif
}

int _tempuri__AnDan4UpdPeoplePresent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDan4UpdPeoplePresent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDan4UpdPeoplePresent(struct soap *soap, const char *tag, int id, const _tempuri__AnDan4UpdPeoplePresent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:Presens", -1, &a->_tempuri__AnDan4UpdPeoplePresent::Presens, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDan4UpdPeoplePresent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDan4UpdPeoplePresent(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDan4UpdPeoplePresent * SOAP_FMAC4 soap_in__tempuri__AnDan4UpdPeoplePresent(struct soap *soap, const char *tag, _tempuri__AnDan4UpdPeoplePresent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDan4UpdPeoplePresent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent, sizeof(_tempuri__AnDan4UpdPeoplePresent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDan4UpdPeoplePresent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Presens1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Presens1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:Presens", &a->_tempuri__AnDan4UpdPeoplePresent::Presens, "xsd:string"))
				{	soap_flag_Presens1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDan4UpdPeoplePresent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent, sizeof(_tempuri__AnDan4UpdPeoplePresent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan4UpdPeoplePresent * SOAP_FMAC2 soap_dup__tempuri__AnDan4UpdPeoplePresent(struct soap *soap, _tempuri__AnDan4UpdPeoplePresent *d, _tempuri__AnDan4UpdPeoplePresent const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDan4UpdPeoplePresent*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDan4UpdPeoplePresent(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDan4UpdPeoplePresent::Presens, &a->_tempuri__AnDan4UpdPeoplePresent::Presens);
	d->_tempuri__AnDan4UpdPeoplePresent::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDan4UpdPeoplePresent * SOAP_FMAC2 soap_instantiate__tempuri__AnDan4UpdPeoplePresent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDan4UpdPeoplePresent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDan4UpdPeoplePresent *p;
	size_t k = sizeof(_tempuri__AnDan4UpdPeoplePresent);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDan4UpdPeoplePresent);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDan4UpdPeoplePresent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDan4UpdPeoplePresent location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDan4UpdPeoplePresent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDan4UpdPeoplePresent(soap, tag ? tag : "tempuri:AnDan4UpdPeoplePresent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDan4UpdPeoplePresent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDan4UpdPeoplePresent(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDan4UpdPeoplePresent * SOAP_FMAC4 soap_get__tempuri__AnDan4UpdPeoplePresent(struct soap *soap, _tempuri__AnDan4UpdPeoplePresent *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDan4UpdPeoplePresent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDan1SendResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__AnDan1SendResponse::AnDan1SendResult = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDan1SendResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDan1SendResponse::AnDan1SendResult);
#endif
}

int _tempuri__AnDan1SendResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDan1SendResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDan1SendResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDan1SendResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDan1SendResponse), type))
		return soap->error;
	if (a->AnDan1SendResult)
		soap_element_result(soap, "tempuri:AnDan1SendResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:AnDan1SendResult", -1, &a->_tempuri__AnDan1SendResponse::AnDan1SendResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDan1SendResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDan1SendResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDan1SendResponse * SOAP_FMAC4 soap_in__tempuri__AnDan1SendResponse(struct soap *soap, const char *tag, _tempuri__AnDan1SendResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDan1SendResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDan1SendResponse, sizeof(_tempuri__AnDan1SendResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDan1SendResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDan1SendResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDan1SendResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDan1SendResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:AnDan1SendResult", &a->_tempuri__AnDan1SendResponse::AnDan1SendResult, "xsd:string"))
				{	soap_flag_AnDan1SendResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDan1SendResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDan1SendResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDan1SendResponse, SOAP_TYPE__tempuri__AnDan1SendResponse, sizeof(_tempuri__AnDan1SendResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan1SendResponse * SOAP_FMAC2 soap_dup__tempuri__AnDan1SendResponse(struct soap *soap, _tempuri__AnDan1SendResponse *d, _tempuri__AnDan1SendResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDan1SendResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDan1SendResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDan1SendResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDan1SendResponse::AnDan1SendResult, &a->_tempuri__AnDan1SendResponse::AnDan1SendResult);
	d->_tempuri__AnDan1SendResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDan1SendResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDan1SendResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDan1SendResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDan1SendResponse *p;
	size_t k = sizeof(_tempuri__AnDan1SendResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDan1SendResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDan1SendResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDan1SendResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDan1SendResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDan1SendResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDan1SendResponse(soap, tag ? tag : "tempuri:AnDan1SendResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDan1SendResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDan1SendResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDan1SendResponse * SOAP_FMAC4 soap_get__tempuri__AnDan1SendResponse(struct soap *soap, _tempuri__AnDan1SendResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDan1SendResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDan1Send::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tempuri__AnDan1Send::flag);
	this->_tempuri__AnDan1Send::XML_ = NULL;
	/* transient soap skipped */
}

void _tempuri__AnDan1Send::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__AnDan1Send::XML_);
#endif
}

int _tempuri__AnDan1Send::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDan1Send(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDan1Send(struct soap *soap, const char *tag, int id, const _tempuri__AnDan1Send *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDan1Send), type))
		return soap->error;
	if (soap_out_bool(soap, "tempuri:flag", -1, &a->_tempuri__AnDan1Send::flag, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:XML", -1, &a->_tempuri__AnDan1Send::XML_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDan1Send::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDan1Send(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDan1Send * SOAP_FMAC4 soap_in__tempuri__AnDan1Send(struct soap *soap, const char *tag, _tempuri__AnDan1Send *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDan1Send *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDan1Send, sizeof(_tempuri__AnDan1Send), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDan1Send)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDan1Send *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_flag1 = 1;
	size_t soap_flag_XML_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_flag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tempuri:flag", &a->_tempuri__AnDan1Send::flag, "xsd:boolean"))
				{	soap_flag_flag1--;
					continue;
				}
			}
			if (soap_flag_XML_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:XML", &a->_tempuri__AnDan1Send::XML_, "xsd:string"))
				{	soap_flag_XML_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_flag1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tempuri__AnDan1Send *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDan1Send, SOAP_TYPE__tempuri__AnDan1Send, sizeof(_tempuri__AnDan1Send), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan1Send * SOAP_FMAC2 soap_dup__tempuri__AnDan1Send(struct soap *soap, _tempuri__AnDan1Send *d, _tempuri__AnDan1Send const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__AnDan1Send*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__AnDan1Send, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__AnDan1Send(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tempuri__AnDan1Send::flag = a->_tempuri__AnDan1Send::flag;
	soap_dup_PointerTostd__string(soap, &d->_tempuri__AnDan1Send::XML_, &a->_tempuri__AnDan1Send::XML_);
	d->_tempuri__AnDan1Send::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__AnDan1Send * SOAP_FMAC2 soap_instantiate__tempuri__AnDan1Send(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDan1Send(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDan1Send *p;
	size_t k = sizeof(_tempuri__AnDan1Send);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__AnDan1Send, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__AnDan1Send);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__AnDan1Send, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDan1Send location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__AnDan1Send::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDan1Send(soap, tag ? tag : "tempuri:AnDan1Send", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDan1Send::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDan1Send(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDan1Send * SOAP_FMAC4 soap_get__tempuri__AnDan1Send(struct soap *soap, _tempuri__AnDan1Send *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDan1Send(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__LoginResponse::LoginResult = NULL;
	/* transient soap skipped */
}

void _tempuri__LoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__LoginResponse::LoginResult);
#endif
}

int _tempuri__LoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LoginResponse(struct soap *soap, const char *tag, int id, const _tempuri__LoginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LoginResponse), type))
		return soap->error;
	if (a->LoginResult)
		soap_element_result(soap, "tempuri:LoginResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:LoginResult", -1, &a->_tempuri__LoginResponse::LoginResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LoginResponse * SOAP_FMAC4 soap_in__tempuri__LoginResponse(struct soap *soap, const char *tag, _tempuri__LoginResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LoginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LoginResponse, sizeof(_tempuri__LoginResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LoginResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LoginResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LoginResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LoginResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:LoginResult", &a->_tempuri__LoginResponse::LoginResult, "xsd:string"))
				{	soap_flag_LoginResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:LoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LoginResponse, SOAP_TYPE__tempuri__LoginResponse, sizeof(_tempuri__LoginResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LoginResponse * SOAP_FMAC2 soap_dup__tempuri__LoginResponse(struct soap *soap, _tempuri__LoginResponse *d, _tempuri__LoginResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__LoginResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__LoginResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__LoginResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__LoginResponse::LoginResult, &a->_tempuri__LoginResponse::LoginResult);
	d->_tempuri__LoginResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__LoginResponse * SOAP_FMAC2 soap_instantiate__tempuri__LoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LoginResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LoginResponse *p;
	size_t k = sizeof(_tempuri__LoginResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__LoginResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__LoginResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__LoginResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LoginResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__LoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LoginResponse(soap, tag ? tag : "tempuri:LoginResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LoginResponse * SOAP_FMAC4 soap_get__tempuri__LoginResponse(struct soap *soap, _tempuri__LoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__Login::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__Login::Role = NULL;
	this->_tempuri__Login::UserName = NULL;
	this->_tempuri__Login::UserPwd = NULL;
	/* transient soap skipped */
}

void _tempuri__Login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__Login::Role);
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__Login::UserName);
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__Login::UserPwd);
#endif
}

int _tempuri__Login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__Login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__Login(struct soap *soap, const char *tag, int id, const _tempuri__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__Login), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:Role", -1, &a->_tempuri__Login::Role, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:UserName", -1, &a->_tempuri__Login::UserName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:UserPwd", -1, &a->_tempuri__Login::UserPwd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__Login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__Login(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__Login * SOAP_FMAC4 soap_in__tempuri__Login(struct soap *soap, const char *tag, _tempuri__Login *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__Login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__Login, sizeof(_tempuri__Login), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__Login)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__Login *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Role1 = 1;
	size_t soap_flag_UserName1 = 1;
	size_t soap_flag_UserPwd1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Role1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:Role", &a->_tempuri__Login::Role, "xsd:string"))
				{	soap_flag_Role1--;
					continue;
				}
			}
			if (soap_flag_UserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:UserName", &a->_tempuri__Login::UserName, "xsd:string"))
				{	soap_flag_UserName1--;
					continue;
				}
			}
			if (soap_flag_UserPwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:UserPwd", &a->_tempuri__Login::UserPwd, "xsd:string"))
				{	soap_flag_UserPwd1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__Login, SOAP_TYPE__tempuri__Login, sizeof(_tempuri__Login), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__Login * SOAP_FMAC2 soap_dup__tempuri__Login(struct soap *soap, _tempuri__Login *d, _tempuri__Login const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__Login*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__Login, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__Login(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__Login::Role, &a->_tempuri__Login::Role);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__Login::UserName, &a->_tempuri__Login::UserName);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__Login::UserPwd, &a->_tempuri__Login::UserPwd);
	d->_tempuri__Login::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__Login * SOAP_FMAC2 soap_instantiate__tempuri__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__Login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__Login *p;
	size_t k = sizeof(_tempuri__Login);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__Login, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__Login);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__Login, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__Login location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__Login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__Login(soap, tag ? tag : "tempuri:Login", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__Login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__Login(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__Login * SOAP_FMAC4 soap_get__tempuri__Login(struct soap *soap, _tempuri__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetPowerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetPowerResponse::GetPowerResult = NULL;
	/* transient soap skipped */
}

void _tempuri__GetPowerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetPowerResponse::GetPowerResult);
#endif
}

int _tempuri__GetPowerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetPowerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetPowerResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetPowerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetPowerResponse), type))
		return soap->error;
	if (a->GetPowerResult)
		soap_element_result(soap, "tempuri:GetPowerResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetPowerResult", -1, &a->_tempuri__GetPowerResponse::GetPowerResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetPowerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetPowerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetPowerResponse * SOAP_FMAC4 soap_in__tempuri__GetPowerResponse(struct soap *soap, const char *tag, _tempuri__GetPowerResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetPowerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetPowerResponse, sizeof(_tempuri__GetPowerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetPowerResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetPowerResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetPowerResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPowerResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetPowerResult", &a->_tempuri__GetPowerResponse::GetPowerResult, "xsd:string"))
				{	soap_flag_GetPowerResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetPowerResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetPowerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetPowerResponse, SOAP_TYPE__tempuri__GetPowerResponse, sizeof(_tempuri__GetPowerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetPowerResponse * SOAP_FMAC2 soap_dup__tempuri__GetPowerResponse(struct soap *soap, _tempuri__GetPowerResponse *d, _tempuri__GetPowerResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__GetPowerResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__GetPowerResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__GetPowerResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__GetPowerResponse::GetPowerResult, &a->_tempuri__GetPowerResponse::GetPowerResult);
	d->_tempuri__GetPowerResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__GetPowerResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetPowerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetPowerResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetPowerResponse *p;
	size_t k = sizeof(_tempuri__GetPowerResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetPowerResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetPowerResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetPowerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetPowerResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetPowerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetPowerResponse(soap, tag ? tag : "tempuri:GetPowerResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetPowerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetPowerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetPowerResponse * SOAP_FMAC4 soap_get__tempuri__GetPowerResponse(struct soap *soap, _tempuri__GetPowerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetPowerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetPower::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetPower::DeptID = NULL;
	/* transient soap skipped */
}

void _tempuri__GetPower::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetPower::DeptID);
#endif
}

int _tempuri__GetPower::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetPower(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetPower(struct soap *soap, const char *tag, int id, const _tempuri__GetPower *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetPower), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:DeptID", -1, &a->_tempuri__GetPower::DeptID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetPower::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetPower(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetPower * SOAP_FMAC4 soap_in__tempuri__GetPower(struct soap *soap, const char *tag, _tempuri__GetPower *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetPower *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetPower, sizeof(_tempuri__GetPower), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetPower)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetPower *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DeptID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeptID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:DeptID", &a->_tempuri__GetPower::DeptID, "xsd:string"))
				{	soap_flag_DeptID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetPower *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetPower, SOAP_TYPE__tempuri__GetPower, sizeof(_tempuri__GetPower), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetPower * SOAP_FMAC2 soap_dup__tempuri__GetPower(struct soap *soap, _tempuri__GetPower *d, _tempuri__GetPower const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__GetPower*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__GetPower, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__GetPower(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__GetPower::DeptID, &a->_tempuri__GetPower::DeptID);
	d->_tempuri__GetPower::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__GetPower * SOAP_FMAC2 soap_instantiate__tempuri__GetPower(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetPower(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetPower *p;
	size_t k = sizeof(_tempuri__GetPower);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetPower, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetPower);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetPower, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetPower location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetPower::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetPower(soap, tag ? tag : "tempuri:GetPower", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetPower::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetPower(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetPower * SOAP_FMAC4 soap_get__tempuri__GetPower(struct soap *soap, _tempuri__GetPower *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetPower(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDeptResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetDeptResponse::GetDeptResult = NULL;
	/* transient soap skipped */
}

void _tempuri__GetDeptResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetDeptResponse::GetDeptResult);
#endif
}

int _tempuri__GetDeptResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDeptResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDeptResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetDeptResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDeptResponse), type))
		return soap->error;
	if (a->GetDeptResult)
		soap_element_result(soap, "tempuri:GetDeptResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetDeptResult", -1, &a->_tempuri__GetDeptResponse::GetDeptResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDeptResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDeptResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDeptResponse * SOAP_FMAC4 soap_in__tempuri__GetDeptResponse(struct soap *soap, const char *tag, _tempuri__GetDeptResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDeptResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDeptResponse, sizeof(_tempuri__GetDeptResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDeptResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDeptResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDeptResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDeptResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetDeptResult", &a->_tempuri__GetDeptResponse::GetDeptResult, "xsd:string"))
				{	soap_flag_GetDeptResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetDeptResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDeptResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDeptResponse, SOAP_TYPE__tempuri__GetDeptResponse, sizeof(_tempuri__GetDeptResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDeptResponse * SOAP_FMAC2 soap_dup__tempuri__GetDeptResponse(struct soap *soap, _tempuri__GetDeptResponse *d, _tempuri__GetDeptResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__GetDeptResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__GetDeptResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__GetDeptResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__GetDeptResponse::GetDeptResult, &a->_tempuri__GetDeptResponse::GetDeptResult);
	d->_tempuri__GetDeptResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__GetDeptResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetDeptResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDeptResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDeptResponse *p;
	size_t k = sizeof(_tempuri__GetDeptResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetDeptResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetDeptResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetDeptResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDeptResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetDeptResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDeptResponse(soap, tag ? tag : "tempuri:GetDeptResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDeptResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDeptResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDeptResponse * SOAP_FMAC4 soap_get__tempuri__GetDeptResponse(struct soap *soap, _tempuri__GetDeptResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDeptResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDept::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tempuri__GetDept::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetDept::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDept(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDept(struct soap *soap, const char *tag, int id, const _tempuri__GetDept *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDept), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDept::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDept(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDept * SOAP_FMAC4 soap_in__tempuri__GetDept(struct soap *soap, const char *tag, _tempuri__GetDept *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDept *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDept, sizeof(_tempuri__GetDept), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDept)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDept *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDept *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDept, SOAP_TYPE__tempuri__GetDept, sizeof(_tempuri__GetDept), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDept * SOAP_FMAC2 soap_dup__tempuri__GetDept(struct soap *soap, _tempuri__GetDept *d, _tempuri__GetDept const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__GetDept*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__GetDept, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__GetDept(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tempuri__GetDept::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__GetDept * SOAP_FMAC2 soap_instantiate__tempuri__GetDept(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDept(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDept *p;
	size_t k = sizeof(_tempuri__GetDept);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetDept, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetDept);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetDept, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDept location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetDept::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDept(soap, tag ? tag : "tempuri:GetDept", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDept::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDept(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDept * SOAP_FMAC4 soap_get__tempuri__GetDept(struct soap *soap, _tempuri__GetDept *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDept(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__DocAddResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__DocAddResponse::DocAddResult = NULL;
	/* transient soap skipped */
}

void _tempuri__DocAddResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__DocAddResponse::DocAddResult);
#endif
}

int _tempuri__DocAddResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__DocAddResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__DocAddResponse(struct soap *soap, const char *tag, int id, const _tempuri__DocAddResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__DocAddResponse), type))
		return soap->error;
	if (a->DocAddResult)
		soap_element_result(soap, "tempuri:DocAddResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:DocAddResult", -1, &a->_tempuri__DocAddResponse::DocAddResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__DocAddResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__DocAddResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__DocAddResponse * SOAP_FMAC4 soap_in__tempuri__DocAddResponse(struct soap *soap, const char *tag, _tempuri__DocAddResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__DocAddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__DocAddResponse, sizeof(_tempuri__DocAddResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__DocAddResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__DocAddResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DocAddResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocAddResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:DocAddResult", &a->_tempuri__DocAddResponse::DocAddResult, "xsd:string"))
				{	soap_flag_DocAddResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:DocAddResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__DocAddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__DocAddResponse, SOAP_TYPE__tempuri__DocAddResponse, sizeof(_tempuri__DocAddResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__DocAddResponse * SOAP_FMAC2 soap_dup__tempuri__DocAddResponse(struct soap *soap, _tempuri__DocAddResponse *d, _tempuri__DocAddResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__DocAddResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__DocAddResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__DocAddResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__DocAddResponse::DocAddResult, &a->_tempuri__DocAddResponse::DocAddResult);
	d->_tempuri__DocAddResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__DocAddResponse * SOAP_FMAC2 soap_instantiate__tempuri__DocAddResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__DocAddResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__DocAddResponse *p;
	size_t k = sizeof(_tempuri__DocAddResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__DocAddResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__DocAddResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__DocAddResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__DocAddResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__DocAddResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__DocAddResponse(soap, tag ? tag : "tempuri:DocAddResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__DocAddResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__DocAddResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__DocAddResponse * SOAP_FMAC4 soap_get__tempuri__DocAddResponse(struct soap *soap, _tempuri__DocAddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__DocAddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__DocAdd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__DocAdd::DocTypeCode = NULL;
	this->_tempuri__DocAdd::DocXmlMaster = NULL;
	this->_tempuri__DocAdd::DocXmlItems = NULL;
	/* transient soap skipped */
}

void _tempuri__DocAdd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__DocAdd::DocTypeCode);
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__DocAdd::DocXmlMaster);
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__DocAdd::DocXmlItems);
#endif
}

int _tempuri__DocAdd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__DocAdd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__DocAdd(struct soap *soap, const char *tag, int id, const _tempuri__DocAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__DocAdd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:DocTypeCode", -1, &a->_tempuri__DocAdd::DocTypeCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:DocXmlMaster", -1, &a->_tempuri__DocAdd::DocXmlMaster, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:DocXmlItems", -1, &a->_tempuri__DocAdd::DocXmlItems, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__DocAdd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__DocAdd(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__DocAdd * SOAP_FMAC4 soap_in__tempuri__DocAdd(struct soap *soap, const char *tag, _tempuri__DocAdd *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__DocAdd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__DocAdd, sizeof(_tempuri__DocAdd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__DocAdd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__DocAdd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DocTypeCode1 = 1;
	size_t soap_flag_DocXmlMaster1 = 1;
	size_t soap_flag_DocXmlItems1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocTypeCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:DocTypeCode", &a->_tempuri__DocAdd::DocTypeCode, "xsd:string"))
				{	soap_flag_DocTypeCode1--;
					continue;
				}
			}
			if (soap_flag_DocXmlMaster1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:DocXmlMaster", &a->_tempuri__DocAdd::DocXmlMaster, "xsd:string"))
				{	soap_flag_DocXmlMaster1--;
					continue;
				}
			}
			if (soap_flag_DocXmlItems1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:DocXmlItems", &a->_tempuri__DocAdd::DocXmlItems, "xsd:string"))
				{	soap_flag_DocXmlItems1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__DocAdd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__DocAdd, SOAP_TYPE__tempuri__DocAdd, sizeof(_tempuri__DocAdd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__DocAdd * SOAP_FMAC2 soap_dup__tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd *d, _tempuri__DocAdd const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__DocAdd*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__DocAdd, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__DocAdd(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__DocAdd::DocTypeCode, &a->_tempuri__DocAdd::DocTypeCode);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__DocAdd::DocXmlMaster, &a->_tempuri__DocAdd::DocXmlMaster);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__DocAdd::DocXmlItems, &a->_tempuri__DocAdd::DocXmlItems);
	d->_tempuri__DocAdd::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__DocAdd * SOAP_FMAC2 soap_instantiate__tempuri__DocAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__DocAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__DocAdd *p;
	size_t k = sizeof(_tempuri__DocAdd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__DocAdd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__DocAdd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__DocAdd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__DocAdd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__DocAdd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__DocAdd(soap, tag ? tag : "tempuri:DocAdd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__DocAdd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__DocAdd(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__DocAdd * SOAP_FMAC4 soap_get__tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__DocAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ItemsAddResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__ItemsAddResponse::ItemsAddResult = NULL;
	/* transient soap skipped */
}

void _tempuri__ItemsAddResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__ItemsAddResponse::ItemsAddResult);
#endif
}

int _tempuri__ItemsAddResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ItemsAddResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ItemsAddResponse(struct soap *soap, const char *tag, int id, const _tempuri__ItemsAddResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ItemsAddResponse), type))
		return soap->error;
	if (a->ItemsAddResult)
		soap_element_result(soap, "tempuri:ItemsAddResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:ItemsAddResult", -1, &a->_tempuri__ItemsAddResponse::ItemsAddResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ItemsAddResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__ItemsAddResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ItemsAddResponse * SOAP_FMAC4 soap_in__tempuri__ItemsAddResponse(struct soap *soap, const char *tag, _tempuri__ItemsAddResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ItemsAddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ItemsAddResponse, sizeof(_tempuri__ItemsAddResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ItemsAddResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ItemsAddResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ItemsAddResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ItemsAddResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:ItemsAddResult", &a->_tempuri__ItemsAddResponse::ItemsAddResult, "xsd:string"))
				{	soap_flag_ItemsAddResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:ItemsAddResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ItemsAddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ItemsAddResponse, SOAP_TYPE__tempuri__ItemsAddResponse, sizeof(_tempuri__ItemsAddResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ItemsAddResponse * SOAP_FMAC2 soap_dup__tempuri__ItemsAddResponse(struct soap *soap, _tempuri__ItemsAddResponse *d, _tempuri__ItemsAddResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__ItemsAddResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__ItemsAddResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__ItemsAddResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__ItemsAddResponse::ItemsAddResult, &a->_tempuri__ItemsAddResponse::ItemsAddResult);
	d->_tempuri__ItemsAddResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__ItemsAddResponse * SOAP_FMAC2 soap_instantiate__tempuri__ItemsAddResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ItemsAddResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ItemsAddResponse *p;
	size_t k = sizeof(_tempuri__ItemsAddResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__ItemsAddResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__ItemsAddResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__ItemsAddResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ItemsAddResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__ItemsAddResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ItemsAddResponse(soap, tag ? tag : "tempuri:ItemsAddResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ItemsAddResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ItemsAddResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ItemsAddResponse * SOAP_FMAC4 soap_get__tempuri__ItemsAddResponse(struct soap *soap, _tempuri__ItemsAddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ItemsAddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ItemsAdd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__ItemsAdd::itemDocXml = NULL;
	/* transient soap skipped */
}

void _tempuri__ItemsAdd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__ItemsAdd::itemDocXml);
#endif
}

int _tempuri__ItemsAdd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ItemsAdd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ItemsAdd(struct soap *soap, const char *tag, int id, const _tempuri__ItemsAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ItemsAdd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:itemDocXml", -1, &a->_tempuri__ItemsAdd::itemDocXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ItemsAdd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__ItemsAdd(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ItemsAdd * SOAP_FMAC4 soap_in__tempuri__ItemsAdd(struct soap *soap, const char *tag, _tempuri__ItemsAdd *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ItemsAdd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ItemsAdd, sizeof(_tempuri__ItemsAdd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ItemsAdd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ItemsAdd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_itemDocXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_itemDocXml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:itemDocXml", &a->_tempuri__ItemsAdd::itemDocXml, "xsd:string"))
				{	soap_flag_itemDocXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ItemsAdd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ItemsAdd, SOAP_TYPE__tempuri__ItemsAdd, sizeof(_tempuri__ItemsAdd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ItemsAdd * SOAP_FMAC2 soap_dup__tempuri__ItemsAdd(struct soap *soap, _tempuri__ItemsAdd *d, _tempuri__ItemsAdd const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__ItemsAdd*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__ItemsAdd, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__ItemsAdd(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__ItemsAdd::itemDocXml, &a->_tempuri__ItemsAdd::itemDocXml);
	d->_tempuri__ItemsAdd::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__ItemsAdd * SOAP_FMAC2 soap_instantiate__tempuri__ItemsAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ItemsAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ItemsAdd *p;
	size_t k = sizeof(_tempuri__ItemsAdd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__ItemsAdd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__ItemsAdd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__ItemsAdd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ItemsAdd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__ItemsAdd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ItemsAdd(soap, tag ? tag : "tempuri:ItemsAdd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ItemsAdd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ItemsAdd(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ItemsAdd * SOAP_FMAC4 soap_get__tempuri__ItemsAdd(struct soap *soap, _tempuri__ItemsAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ItemsAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryReturnResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__LineInventoryReturnResponse::LineInventoryReturnResult = NULL;
	/* transient soap skipped */
}

void _tempuri__LineInventoryReturnResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__LineInventoryReturnResponse::LineInventoryReturnResult);
#endif
}

int _tempuri__LineInventoryReturnResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryReturnResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryReturnResponse(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryReturnResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryReturnResponse), type))
		return soap->error;
	if (a->LineInventoryReturnResult)
		soap_element_result(soap, "tempuri:LineInventoryReturnResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:LineInventoryReturnResult", -1, &a->_tempuri__LineInventoryReturnResponse::LineInventoryReturnResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryReturnResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryReturnResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryReturnResponse * SOAP_FMAC4 soap_in__tempuri__LineInventoryReturnResponse(struct soap *soap, const char *tag, _tempuri__LineInventoryReturnResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryReturnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryReturnResponse, sizeof(_tempuri__LineInventoryReturnResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryReturnResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryReturnResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LineInventoryReturnResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineInventoryReturnResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:LineInventoryReturnResult", &a->_tempuri__LineInventoryReturnResponse::LineInventoryReturnResult, "xsd:string"))
				{	soap_flag_LineInventoryReturnResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:LineInventoryReturnResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryReturnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryReturnResponse, SOAP_TYPE__tempuri__LineInventoryReturnResponse, sizeof(_tempuri__LineInventoryReturnResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryReturnResponse * SOAP_FMAC2 soap_dup__tempuri__LineInventoryReturnResponse(struct soap *soap, _tempuri__LineInventoryReturnResponse *d, _tempuri__LineInventoryReturnResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__LineInventoryReturnResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__LineInventoryReturnResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__LineInventoryReturnResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__LineInventoryReturnResponse::LineInventoryReturnResult, &a->_tempuri__LineInventoryReturnResponse::LineInventoryReturnResult);
	d->_tempuri__LineInventoryReturnResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__LineInventoryReturnResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryReturnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryReturnResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryReturnResponse *p;
	size_t k = sizeof(_tempuri__LineInventoryReturnResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__LineInventoryReturnResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__LineInventoryReturnResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__LineInventoryReturnResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryReturnResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__LineInventoryReturnResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryReturnResponse(soap, tag ? tag : "tempuri:LineInventoryReturnResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryReturnResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryReturnResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryReturnResponse * SOAP_FMAC4 soap_get__tempuri__LineInventoryReturnResponse(struct soap *soap, _tempuri__LineInventoryReturnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryReturnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryReturn::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__LineInventoryReturn::LRXml = NULL;
	/* transient soap skipped */
}

void _tempuri__LineInventoryReturn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__LineInventoryReturn::LRXml);
#endif
}

int _tempuri__LineInventoryReturn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryReturn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryReturn(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryReturn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryReturn), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:LRXml", -1, &a->_tempuri__LineInventoryReturn::LRXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryReturn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryReturn(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryReturn * SOAP_FMAC4 soap_in__tempuri__LineInventoryReturn(struct soap *soap, const char *tag, _tempuri__LineInventoryReturn *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryReturn, sizeof(_tempuri__LineInventoryReturn), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryReturn)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryReturn *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LRXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LRXml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:LRXml", &a->_tempuri__LineInventoryReturn::LRXml, "xsd:string"))
				{	soap_flag_LRXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryReturn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryReturn, SOAP_TYPE__tempuri__LineInventoryReturn, sizeof(_tempuri__LineInventoryReturn), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryReturn * SOAP_FMAC2 soap_dup__tempuri__LineInventoryReturn(struct soap *soap, _tempuri__LineInventoryReturn *d, _tempuri__LineInventoryReturn const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__LineInventoryReturn*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__LineInventoryReturn, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__LineInventoryReturn(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__LineInventoryReturn::LRXml, &a->_tempuri__LineInventoryReturn::LRXml);
	d->_tempuri__LineInventoryReturn::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__LineInventoryReturn * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryReturn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryReturn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryReturn *p;
	size_t k = sizeof(_tempuri__LineInventoryReturn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__LineInventoryReturn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__LineInventoryReturn);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__LineInventoryReturn, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryReturn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__LineInventoryReturn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryReturn(soap, tag ? tag : "tempuri:LineInventoryReturn", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryReturn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryReturn(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryReturn * SOAP_FMAC4 soap_get__tempuri__LineInventoryReturn(struct soap *soap, _tempuri__LineInventoryReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryUpdateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__LineInventoryUpdateResponse::LineInventoryUpdateResult = NULL;
	/* transient soap skipped */
}

void _tempuri__LineInventoryUpdateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__LineInventoryUpdateResponse::LineInventoryUpdateResult);
#endif
}

int _tempuri__LineInventoryUpdateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryUpdateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryUpdateResponse(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryUpdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryUpdateResponse), type))
		return soap->error;
	if (a->LineInventoryUpdateResult)
		soap_element_result(soap, "tempuri:LineInventoryUpdateResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:LineInventoryUpdateResult", -1, &a->_tempuri__LineInventoryUpdateResponse::LineInventoryUpdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryUpdateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryUpdateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdateResponse * SOAP_FMAC4 soap_in__tempuri__LineInventoryUpdateResponse(struct soap *soap, const char *tag, _tempuri__LineInventoryUpdateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryUpdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryUpdateResponse, sizeof(_tempuri__LineInventoryUpdateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryUpdateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryUpdateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LineInventoryUpdateResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineInventoryUpdateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:LineInventoryUpdateResult", &a->_tempuri__LineInventoryUpdateResponse::LineInventoryUpdateResult, "xsd:string"))
				{	soap_flag_LineInventoryUpdateResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:LineInventoryUpdateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryUpdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryUpdateResponse, SOAP_TYPE__tempuri__LineInventoryUpdateResponse, sizeof(_tempuri__LineInventoryUpdateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryUpdateResponse * SOAP_FMAC2 soap_dup__tempuri__LineInventoryUpdateResponse(struct soap *soap, _tempuri__LineInventoryUpdateResponse *d, _tempuri__LineInventoryUpdateResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__LineInventoryUpdateResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__LineInventoryUpdateResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__LineInventoryUpdateResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__LineInventoryUpdateResponse::LineInventoryUpdateResult, &a->_tempuri__LineInventoryUpdateResponse::LineInventoryUpdateResult);
	d->_tempuri__LineInventoryUpdateResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__LineInventoryUpdateResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryUpdateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryUpdateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryUpdateResponse *p;
	size_t k = sizeof(_tempuri__LineInventoryUpdateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__LineInventoryUpdateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__LineInventoryUpdateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__LineInventoryUpdateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryUpdateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__LineInventoryUpdateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryUpdateResponse(soap, tag ? tag : "tempuri:LineInventoryUpdateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryUpdateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryUpdateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdateResponse * SOAP_FMAC4 soap_get__tempuri__LineInventoryUpdateResponse(struct soap *soap, _tempuri__LineInventoryUpdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryUpdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryUpdate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__LineInventoryUpdate::LIXml = NULL;
	/* transient soap skipped */
}

void _tempuri__LineInventoryUpdate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__LineInventoryUpdate::LIXml);
#endif
}

int _tempuri__LineInventoryUpdate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryUpdate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryUpdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryUpdate), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:LIXml", -1, &a->_tempuri__LineInventoryUpdate::LIXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryUpdate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryUpdate(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdate * SOAP_FMAC4 soap_in__tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, _tempuri__LineInventoryUpdate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryUpdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryUpdate, sizeof(_tempuri__LineInventoryUpdate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryUpdate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryUpdate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LIXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LIXml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:LIXml", &a->_tempuri__LineInventoryUpdate::LIXml, "xsd:string"))
				{	soap_flag_LIXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryUpdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryUpdate, SOAP_TYPE__tempuri__LineInventoryUpdate, sizeof(_tempuri__LineInventoryUpdate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryUpdate * SOAP_FMAC2 soap_dup__tempuri__LineInventoryUpdate(struct soap *soap, _tempuri__LineInventoryUpdate *d, _tempuri__LineInventoryUpdate const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__LineInventoryUpdate*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__LineInventoryUpdate, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__LineInventoryUpdate(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__LineInventoryUpdate::LIXml, &a->_tempuri__LineInventoryUpdate::LIXml);
	d->_tempuri__LineInventoryUpdate::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__LineInventoryUpdate * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryUpdate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryUpdate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryUpdate *p;
	size_t k = sizeof(_tempuri__LineInventoryUpdate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__LineInventoryUpdate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__LineInventoryUpdate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__LineInventoryUpdate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryUpdate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__LineInventoryUpdate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryUpdate(soap, tag ? tag : "tempuri:LineInventoryUpdate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryUpdate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryUpdate(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdate * SOAP_FMAC4 soap_get__tempuri__LineInventoryUpdate(struct soap *soap, _tempuri__LineInventoryUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__LineInventoryResponse::LineInventoryResult = NULL;
	/* transient soap skipped */
}

void _tempuri__LineInventoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__LineInventoryResponse::LineInventoryResult);
#endif
}

int _tempuri__LineInventoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryResponse(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryResponse), type))
		return soap->error;
	if (a->LineInventoryResult)
		soap_element_result(soap, "tempuri:LineInventoryResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:LineInventoryResult", -1, &a->_tempuri__LineInventoryResponse::LineInventoryResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryResponse * SOAP_FMAC4 soap_in__tempuri__LineInventoryResponse(struct soap *soap, const char *tag, _tempuri__LineInventoryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryResponse, sizeof(_tempuri__LineInventoryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LineInventoryResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineInventoryResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:LineInventoryResult", &a->_tempuri__LineInventoryResponse::LineInventoryResult, "xsd:string"))
				{	soap_flag_LineInventoryResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:LineInventoryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryResponse, SOAP_TYPE__tempuri__LineInventoryResponse, sizeof(_tempuri__LineInventoryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryResponse * SOAP_FMAC2 soap_dup__tempuri__LineInventoryResponse(struct soap *soap, _tempuri__LineInventoryResponse *d, _tempuri__LineInventoryResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__LineInventoryResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__LineInventoryResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__LineInventoryResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__LineInventoryResponse::LineInventoryResult, &a->_tempuri__LineInventoryResponse::LineInventoryResult);
	d->_tempuri__LineInventoryResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__LineInventoryResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryResponse *p;
	size_t k = sizeof(_tempuri__LineInventoryResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__LineInventoryResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__LineInventoryResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__LineInventoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__LineInventoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryResponse(soap, tag ? tag : "tempuri:LineInventoryResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryResponse * SOAP_FMAC4 soap_get__tempuri__LineInventoryResponse(struct soap *soap, _tempuri__LineInventoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventory::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__LineInventory::WorkLineCode = NULL;
	this->_tempuri__LineInventory::MCode = NULL;
	this->_tempuri__LineInventory::BatchNo = NULL;
	this->_tempuri__LineInventory::BarCode = NULL;
	/* transient soap skipped */
}

void _tempuri__LineInventory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__LineInventory::WorkLineCode);
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__LineInventory::MCode);
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__LineInventory::BatchNo);
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__LineInventory::BarCode);
#endif
}

int _tempuri__LineInventory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventory(struct soap *soap, const char *tag, int id, const _tempuri__LineInventory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventory), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:WorkLineCode", -1, &a->_tempuri__LineInventory::WorkLineCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:MCode", -1, &a->_tempuri__LineInventory::MCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:BatchNo", -1, &a->_tempuri__LineInventory::BatchNo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:BarCode", -1, &a->_tempuri__LineInventory::BarCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventory(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventory * SOAP_FMAC4 soap_in__tempuri__LineInventory(struct soap *soap, const char *tag, _tempuri__LineInventory *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventory, sizeof(_tempuri__LineInventory), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventory)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventory *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WorkLineCode1 = 1;
	size_t soap_flag_MCode1 = 1;
	size_t soap_flag_BatchNo1 = 1;
	size_t soap_flag_BarCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WorkLineCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:WorkLineCode", &a->_tempuri__LineInventory::WorkLineCode, "xsd:string"))
				{	soap_flag_WorkLineCode1--;
					continue;
				}
			}
			if (soap_flag_MCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:MCode", &a->_tempuri__LineInventory::MCode, "xsd:string"))
				{	soap_flag_MCode1--;
					continue;
				}
			}
			if (soap_flag_BatchNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:BatchNo", &a->_tempuri__LineInventory::BatchNo, "xsd:string"))
				{	soap_flag_BatchNo1--;
					continue;
				}
			}
			if (soap_flag_BarCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:BarCode", &a->_tempuri__LineInventory::BarCode, "xsd:string"))
				{	soap_flag_BarCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventory, SOAP_TYPE__tempuri__LineInventory, sizeof(_tempuri__LineInventory), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventory * SOAP_FMAC2 soap_dup__tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory *d, _tempuri__LineInventory const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__LineInventory*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__LineInventory, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__LineInventory(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__LineInventory::WorkLineCode, &a->_tempuri__LineInventory::WorkLineCode);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__LineInventory::MCode, &a->_tempuri__LineInventory::MCode);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__LineInventory::BatchNo, &a->_tempuri__LineInventory::BatchNo);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__LineInventory::BarCode, &a->_tempuri__LineInventory::BarCode);
	d->_tempuri__LineInventory::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__LineInventory * SOAP_FMAC2 soap_instantiate__tempuri__LineInventory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventory *p;
	size_t k = sizeof(_tempuri__LineInventory);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__LineInventory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__LineInventory);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__LineInventory, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventory location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__LineInventory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventory(soap, tag ? tag : "tempuri:LineInventory", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventory(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventory * SOAP_FMAC4 soap_get__tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__WorkOrderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__WorkOrderResponse::WorkOrderResult = NULL;
	/* transient soap skipped */
}

void _tempuri__WorkOrderResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__WorkOrderResponse::WorkOrderResult);
#endif
}

int _tempuri__WorkOrderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__WorkOrderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__WorkOrderResponse(struct soap *soap, const char *tag, int id, const _tempuri__WorkOrderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__WorkOrderResponse), type))
		return soap->error;
	if (a->WorkOrderResult)
		soap_element_result(soap, "tempuri:WorkOrderResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:WorkOrderResult", -1, &a->_tempuri__WorkOrderResponse::WorkOrderResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__WorkOrderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__WorkOrderResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__WorkOrderResponse * SOAP_FMAC4 soap_in__tempuri__WorkOrderResponse(struct soap *soap, const char *tag, _tempuri__WorkOrderResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__WorkOrderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__WorkOrderResponse, sizeof(_tempuri__WorkOrderResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__WorkOrderResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__WorkOrderResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WorkOrderResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WorkOrderResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:WorkOrderResult", &a->_tempuri__WorkOrderResponse::WorkOrderResult, "xsd:string"))
				{	soap_flag_WorkOrderResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:WorkOrderResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__WorkOrderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__WorkOrderResponse, SOAP_TYPE__tempuri__WorkOrderResponse, sizeof(_tempuri__WorkOrderResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__WorkOrderResponse * SOAP_FMAC2 soap_dup__tempuri__WorkOrderResponse(struct soap *soap, _tempuri__WorkOrderResponse *d, _tempuri__WorkOrderResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__WorkOrderResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__WorkOrderResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__WorkOrderResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__WorkOrderResponse::WorkOrderResult, &a->_tempuri__WorkOrderResponse::WorkOrderResult);
	d->_tempuri__WorkOrderResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__WorkOrderResponse * SOAP_FMAC2 soap_instantiate__tempuri__WorkOrderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__WorkOrderResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__WorkOrderResponse *p;
	size_t k = sizeof(_tempuri__WorkOrderResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__WorkOrderResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__WorkOrderResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__WorkOrderResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__WorkOrderResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__WorkOrderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__WorkOrderResponse(soap, tag ? tag : "tempuri:WorkOrderResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__WorkOrderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__WorkOrderResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__WorkOrderResponse * SOAP_FMAC4 soap_get__tempuri__WorkOrderResponse(struct soap *soap, _tempuri__WorkOrderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__WorkOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__WorkOrder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__WorkOrder::WorkOrderXml = NULL;
	/* transient soap skipped */
}

void _tempuri__WorkOrder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__WorkOrder::WorkOrderXml);
#endif
}

int _tempuri__WorkOrder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__WorkOrder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__WorkOrder(struct soap *soap, const char *tag, int id, const _tempuri__WorkOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__WorkOrder), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:WorkOrderXml", -1, &a->_tempuri__WorkOrder::WorkOrderXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__WorkOrder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__WorkOrder(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__WorkOrder * SOAP_FMAC4 soap_in__tempuri__WorkOrder(struct soap *soap, const char *tag, _tempuri__WorkOrder *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__WorkOrder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__WorkOrder, sizeof(_tempuri__WorkOrder), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__WorkOrder)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__WorkOrder *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WorkOrderXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WorkOrderXml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:WorkOrderXml", &a->_tempuri__WorkOrder::WorkOrderXml, "xsd:string"))
				{	soap_flag_WorkOrderXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__WorkOrder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__WorkOrder, SOAP_TYPE__tempuri__WorkOrder, sizeof(_tempuri__WorkOrder), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__WorkOrder * SOAP_FMAC2 soap_dup__tempuri__WorkOrder(struct soap *soap, _tempuri__WorkOrder *d, _tempuri__WorkOrder const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__WorkOrder*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__WorkOrder, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__WorkOrder(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__WorkOrder::WorkOrderXml, &a->_tempuri__WorkOrder::WorkOrderXml);
	d->_tempuri__WorkOrder::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__WorkOrder * SOAP_FMAC2 soap_instantiate__tempuri__WorkOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__WorkOrder(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__WorkOrder *p;
	size_t k = sizeof(_tempuri__WorkOrder);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__WorkOrder, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__WorkOrder);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__WorkOrder, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__WorkOrder location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__WorkOrder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__WorkOrder(soap, tag ? tag : "tempuri:WorkOrder", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__WorkOrder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__WorkOrder(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__WorkOrder * SOAP_FMAC4 soap_get__tempuri__WorkOrder(struct soap *soap, _tempuri__WorkOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__WorkOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ToolingTimesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__ToolingTimesResponse::ToolingTimesResult = NULL;
	/* transient soap skipped */
}

void _tempuri__ToolingTimesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__ToolingTimesResponse::ToolingTimesResult);
#endif
}

int _tempuri__ToolingTimesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ToolingTimesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ToolingTimesResponse(struct soap *soap, const char *tag, int id, const _tempuri__ToolingTimesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ToolingTimesResponse), type))
		return soap->error;
	if (a->ToolingTimesResult)
		soap_element_result(soap, "tempuri:ToolingTimesResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:ToolingTimesResult", -1, &a->_tempuri__ToolingTimesResponse::ToolingTimesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ToolingTimesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__ToolingTimesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ToolingTimesResponse * SOAP_FMAC4 soap_in__tempuri__ToolingTimesResponse(struct soap *soap, const char *tag, _tempuri__ToolingTimesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ToolingTimesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ToolingTimesResponse, sizeof(_tempuri__ToolingTimesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ToolingTimesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ToolingTimesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ToolingTimesResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToolingTimesResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:ToolingTimesResult", &a->_tempuri__ToolingTimesResponse::ToolingTimesResult, "xsd:string"))
				{	soap_flag_ToolingTimesResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:ToolingTimesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ToolingTimesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ToolingTimesResponse, SOAP_TYPE__tempuri__ToolingTimesResponse, sizeof(_tempuri__ToolingTimesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ToolingTimesResponse * SOAP_FMAC2 soap_dup__tempuri__ToolingTimesResponse(struct soap *soap, _tempuri__ToolingTimesResponse *d, _tempuri__ToolingTimesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__ToolingTimesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__ToolingTimesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__ToolingTimesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__ToolingTimesResponse::ToolingTimesResult, &a->_tempuri__ToolingTimesResponse::ToolingTimesResult);
	d->_tempuri__ToolingTimesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__ToolingTimesResponse * SOAP_FMAC2 soap_instantiate__tempuri__ToolingTimesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ToolingTimesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ToolingTimesResponse *p;
	size_t k = sizeof(_tempuri__ToolingTimesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__ToolingTimesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__ToolingTimesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__ToolingTimesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ToolingTimesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__ToolingTimesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ToolingTimesResponse(soap, tag ? tag : "tempuri:ToolingTimesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ToolingTimesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ToolingTimesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ToolingTimesResponse * SOAP_FMAC4 soap_get__tempuri__ToolingTimesResponse(struct soap *soap, _tempuri__ToolingTimesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ToolingTimesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ToolingTimes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__ToolingTimes::BillCode = NULL;
	this->_tempuri__ToolingTimes::DeviceCode = NULL;
	soap_default_int(soap, &this->_tempuri__ToolingTimes::Times);
	/* transient soap skipped */
}

void _tempuri__ToolingTimes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__ToolingTimes::BillCode);
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__ToolingTimes::DeviceCode);
#endif
}

int _tempuri__ToolingTimes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ToolingTimes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ToolingTimes(struct soap *soap, const char *tag, int id, const _tempuri__ToolingTimes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ToolingTimes), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:BillCode", -1, &a->_tempuri__ToolingTimes::BillCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tempuri:DeviceCode", -1, &a->_tempuri__ToolingTimes::DeviceCode, ""))
		return soap->error;
	if (soap_out_int(soap, "tempuri:Times", -1, &a->_tempuri__ToolingTimes::Times, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ToolingTimes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__ToolingTimes(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ToolingTimes * SOAP_FMAC4 soap_in__tempuri__ToolingTimes(struct soap *soap, const char *tag, _tempuri__ToolingTimes *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ToolingTimes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ToolingTimes, sizeof(_tempuri__ToolingTimes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ToolingTimes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ToolingTimes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BillCode1 = 1;
	size_t soap_flag_DeviceCode1 = 1;
	size_t soap_flag_Times1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BillCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:BillCode", &a->_tempuri__ToolingTimes::BillCode, "xsd:string"))
				{	soap_flag_BillCode1--;
					continue;
				}
			}
			if (soap_flag_DeviceCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:DeviceCode", &a->_tempuri__ToolingTimes::DeviceCode, "xsd:string"))
				{	soap_flag_DeviceCode1--;
					continue;
				}
			}
			if (soap_flag_Times1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tempuri:Times", &a->_tempuri__ToolingTimes::Times, "xsd:int"))
				{	soap_flag_Times1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Times1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tempuri__ToolingTimes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ToolingTimes, SOAP_TYPE__tempuri__ToolingTimes, sizeof(_tempuri__ToolingTimes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ToolingTimes * SOAP_FMAC2 soap_dup__tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes *d, _tempuri__ToolingTimes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__ToolingTimes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__ToolingTimes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__ToolingTimes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__ToolingTimes::BillCode, &a->_tempuri__ToolingTimes::BillCode);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__ToolingTimes::DeviceCode, &a->_tempuri__ToolingTimes::DeviceCode);
	d->_tempuri__ToolingTimes::Times = a->_tempuri__ToolingTimes::Times;
	d->_tempuri__ToolingTimes::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__ToolingTimes * SOAP_FMAC2 soap_instantiate__tempuri__ToolingTimes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ToolingTimes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ToolingTimes *p;
	size_t k = sizeof(_tempuri__ToolingTimes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__ToolingTimes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__ToolingTimes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__ToolingTimes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ToolingTimes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__ToolingTimes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ToolingTimes(soap, tag ? tag : "tempuri:ToolingTimes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ToolingTimes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ToolingTimes(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ToolingTimes * SOAP_FMAC4 soap_get__tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ToolingTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDocCodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetDocCodeResponse::GetDocCodeResult = NULL;
	/* transient soap skipped */
}

void _tempuri__GetDocCodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetDocCodeResponse::GetDocCodeResult);
#endif
}

int _tempuri__GetDocCodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDocCodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDocCodeResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetDocCodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDocCodeResponse), type))
		return soap->error;
	if (a->GetDocCodeResult)
		soap_element_result(soap, "tempuri:GetDocCodeResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetDocCodeResult", -1, &a->_tempuri__GetDocCodeResponse::GetDocCodeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDocCodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDocCodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDocCodeResponse * SOAP_FMAC4 soap_in__tempuri__GetDocCodeResponse(struct soap *soap, const char *tag, _tempuri__GetDocCodeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDocCodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDocCodeResponse, sizeof(_tempuri__GetDocCodeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDocCodeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDocCodeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDocCodeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDocCodeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetDocCodeResult", &a->_tempuri__GetDocCodeResponse::GetDocCodeResult, "xsd:string"))
				{	soap_flag_GetDocCodeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetDocCodeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDocCodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDocCodeResponse, SOAP_TYPE__tempuri__GetDocCodeResponse, sizeof(_tempuri__GetDocCodeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDocCodeResponse * SOAP_FMAC2 soap_dup__tempuri__GetDocCodeResponse(struct soap *soap, _tempuri__GetDocCodeResponse *d, _tempuri__GetDocCodeResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__GetDocCodeResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__GetDocCodeResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__GetDocCodeResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__GetDocCodeResponse::GetDocCodeResult, &a->_tempuri__GetDocCodeResponse::GetDocCodeResult);
	d->_tempuri__GetDocCodeResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__GetDocCodeResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetDocCodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDocCodeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDocCodeResponse *p;
	size_t k = sizeof(_tempuri__GetDocCodeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetDocCodeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetDocCodeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetDocCodeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDocCodeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetDocCodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDocCodeResponse(soap, tag ? tag : "tempuri:GetDocCodeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDocCodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDocCodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDocCodeResponse * SOAP_FMAC4 soap_get__tempuri__GetDocCodeResponse(struct soap *soap, _tempuri__GetDocCodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDocCodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDocCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_tempuri__GetDocCode::DocValue);
	/* transient soap skipped */
}

void _tempuri__GetDocCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetDocCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDocCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDocCode(struct soap *soap, const char *tag, int id, const _tempuri__GetDocCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDocCode), type))
		return soap->error;
	if (soap_out_int(soap, "tempuri:DocValue", -1, &a->_tempuri__GetDocCode::DocValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDocCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDocCode(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDocCode * SOAP_FMAC4 soap_in__tempuri__GetDocCode(struct soap *soap, const char *tag, _tempuri__GetDocCode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDocCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDocCode, sizeof(_tempuri__GetDocCode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDocCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDocCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DocValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocValue1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tempuri:DocValue", &a->_tempuri__GetDocCode::DocValue, "xsd:int"))
				{	soap_flag_DocValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DocValue1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tempuri__GetDocCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDocCode, SOAP_TYPE__tempuri__GetDocCode, sizeof(_tempuri__GetDocCode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDocCode * SOAP_FMAC2 soap_dup__tempuri__GetDocCode(struct soap *soap, _tempuri__GetDocCode *d, _tempuri__GetDocCode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__GetDocCode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__GetDocCode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__GetDocCode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tempuri__GetDocCode::DocValue = a->_tempuri__GetDocCode::DocValue;
	d->_tempuri__GetDocCode::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__GetDocCode * SOAP_FMAC2 soap_instantiate__tempuri__GetDocCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDocCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDocCode *p;
	size_t k = sizeof(_tempuri__GetDocCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetDocCode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetDocCode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetDocCode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDocCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetDocCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDocCode(soap, tag ? tag : "tempuri:GetDocCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDocCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDocCode(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDocCode * SOAP_FMAC4 soap_get__tempuri__GetDocCode(struct soap *soap, _tempuri__GetDocCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDocCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tempuri__GetDateResponse::GetDateResult = NULL;
	/* transient soap skipped */
}

void _tempuri__GetDateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tempuri__GetDateResponse::GetDateResult);
#endif
}

int _tempuri__GetDateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDateResponse(struct soap *soap, const char *tag, int id, const _tempuri__GetDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDateResponse), type))
		return soap->error;
	if (a->GetDateResult)
		soap_element_result(soap, "tempuri:GetDateResult");
	if (soap_out_PointerTostd__string(soap, "tempuri:GetDateResult", -1, &a->_tempuri__GetDateResponse::GetDateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDateResponse * SOAP_FMAC4 soap_in__tempuri__GetDateResponse(struct soap *soap, const char *tag, _tempuri__GetDateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDateResponse, sizeof(_tempuri__GetDateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDateResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tempuri:GetDateResult", &a->_tempuri__GetDateResponse::GetDateResult, "xsd:string"))
				{	soap_flag_GetDateResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:GetDateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDateResponse, SOAP_TYPE__tempuri__GetDateResponse, sizeof(_tempuri__GetDateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDateResponse * SOAP_FMAC2 soap_dup__tempuri__GetDateResponse(struct soap *soap, _tempuri__GetDateResponse *d, _tempuri__GetDateResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__GetDateResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__GetDateResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__GetDateResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tempuri__GetDateResponse::GetDateResult, &a->_tempuri__GetDateResponse::GetDateResult);
	d->_tempuri__GetDateResponse::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__GetDateResponse * SOAP_FMAC2 soap_instantiate__tempuri__GetDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDateResponse *p;
	size_t k = sizeof(_tempuri__GetDateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetDateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetDateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetDateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetDateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDateResponse(soap, tag ? tag : "tempuri:GetDateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDateResponse * SOAP_FMAC4 soap_get__tempuri__GetDateResponse(struct soap *soap, _tempuri__GetDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__GetDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tempuri__GetDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__GetDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__GetDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__GetDate(struct soap *soap, const char *tag, int id, const _tempuri__GetDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__GetDate), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__GetDate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__GetDate(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__GetDate * SOAP_FMAC4 soap_in__tempuri__GetDate(struct soap *soap, const char *tag, _tempuri__GetDate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__GetDate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__GetDate, sizeof(_tempuri__GetDate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__GetDate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__GetDate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__GetDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__GetDate, SOAP_TYPE__tempuri__GetDate, sizeof(_tempuri__GetDate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDate * SOAP_FMAC2 soap_dup__tempuri__GetDate(struct soap *soap, _tempuri__GetDate *d, _tempuri__GetDate const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tempuri__GetDate*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tempuri__GetDate, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tempuri__GetDate(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tempuri__GetDate::soap = soap;
	return d;
}

SOAP_FMAC1 _tempuri__GetDate * SOAP_FMAC2 soap_instantiate__tempuri__GetDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__GetDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__GetDate *p;
	size_t k = sizeof(_tempuri__GetDate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tempuri__GetDate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tempuri__GetDate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tempuri__GetDate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__GetDate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tempuri__GetDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__GetDate(soap, tag ? tag : "tempuri:GetDate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__GetDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__GetDate(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__GetDate * SOAP_FMAC4 soap_get__tempuri__GetDate(struct soap *soap, _tempuri__GetDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__GetDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_dup_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *d, struct SOAP_ENV__Fault const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct SOAP_ENV__Fault*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Fault, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Fault(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup__QName(soap, &d->faultcode, &a->faultcode);
	soap_dup_string(soap, &d->faultstring, &a->faultstring);
	soap_dup_string(soap, &d->faultactor, &a->faultactor);
	soap_dup_PointerToSOAP_ENV__Detail(soap, &d->detail, &a->detail);
	soap_dup_PointerToSOAP_ENV__Code(soap, &d->SOAP_ENV__Code, &a->SOAP_ENV__Code);
	soap_dup_PointerToSOAP_ENV__Reason(soap, &d->SOAP_ENV__Reason, &a->SOAP_ENV__Reason);
	soap_dup_string(soap, &d->SOAP_ENV__Node, &a->SOAP_ENV__Node);
	soap_dup_string(soap, &d->SOAP_ENV__Role, &a->SOAP_ENV__Role);
	soap_dup_PointerToSOAP_ENV__Detail(soap, &d->SOAP_ENV__Detail, &a->SOAP_ENV__Detail);
	return d;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_dup_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *d, struct SOAP_ENV__Reason const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct SOAP_ENV__Reason*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Reason, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Reason(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_string(soap, &d->SOAP_ENV__Text, &a->SOAP_ENV__Text);
	return d;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_dup_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *d, struct SOAP_ENV__Detail const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct SOAP_ENV__Detail*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Detail, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Detail(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->__any = soap_strdup(soap, (char*)a->__any);
	d->fault = a->fault ? soap_dupelement(soap, a->fault, d->__type = a->__type) : NULL;
	return d;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_dup_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *d, struct SOAP_ENV__Code const*a)
{
	struct soap_plist *pp = NULL;
	char *mark = NULL;
	if (!a)
		return NULL;
	if (!d && ((d = (struct SOAP_ENV__Code*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Code, &pp, &mark)) || soap_mark_cycle(soap, pp)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Code(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup__QName(soap, &d->SOAP_ENV__Value, &a->SOAP_ENV__Value);
	soap_dup_PointerToSOAP_ENV__Code(soap, &d->SOAP_ENV__Subcode, &a->SOAP_ENV__Subcode);
	soap_unmark(soap, mark);
	return d;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_dup_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *d, struct SOAP_ENV__Header const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct SOAP_ENV__Header*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Header, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Header(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	return d;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDanSLTypeAdd_(struct soap *soap, struct __tempuri__AnDanSLTypeAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDanSLTypeAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDanSLTypeAdd_(struct soap *soap, const struct __tempuri__AnDanSLTypeAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDanSLTypeAdd(soap, &a->tempuri__AnDanSLTypeAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDanSLTypeAdd_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDanSLTypeAdd_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDanSLTypeAdd(soap, "tempuri:AnDanSLTypeAdd", -1, &a->tempuri__AnDanSLTypeAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDanSLTypeAdd_ * SOAP_FMAC4 soap_in___tempuri__AnDanSLTypeAdd_(struct soap *soap, const char *tag, struct __tempuri__AnDanSLTypeAdd_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDanSLTypeAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDanSLTypeAdd_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDanSLTypeAdd_, sizeof(struct __tempuri__AnDanSLTypeAdd_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDanSLTypeAdd_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDanSLTypeAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDanSLTypeAdd(soap, "tempuri:AnDanSLTypeAdd", &a->tempuri__AnDanSLTypeAdd, ""))
				{	soap_flag_tempuri__AnDanSLTypeAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDanSLTypeAdd_ * SOAP_FMAC2 soap_dup___tempuri__AnDanSLTypeAdd_(struct soap *soap, struct __tempuri__AnDanSLTypeAdd_ *d, struct __tempuri__AnDanSLTypeAdd_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDanSLTypeAdd_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDanSLTypeAdd_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDanSLTypeAdd_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDanSLTypeAdd(soap, &d->tempuri__AnDanSLTypeAdd, &a->tempuri__AnDanSLTypeAdd);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDanSLTypeAdd_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDanSLTypeAdd_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDanSLTypeAdd_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDanSLTypeAdd_ *p;
	size_t k = sizeof(struct __tempuri__AnDanSLTypeAdd_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDanSLTypeAdd_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDanSLTypeAdd_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDanSLTypeAdd_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDanSLTypeAdd_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDanSLTypeAdd_(struct soap *soap, const struct __tempuri__AnDanSLTypeAdd_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDanSLTypeAdd_(soap, tag ? tag : "-tempuri:AnDanSLTypeAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDanSLTypeAdd_ * SOAP_FMAC4 soap_get___tempuri__AnDanSLTypeAdd_(struct soap *soap, struct __tempuri__AnDanSLTypeAdd_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDanSLTypeAdd_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDanSLTypeGet_(struct soap *soap, struct __tempuri__AnDanSLTypeGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDanSLTypeGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDanSLTypeGet_(struct soap *soap, const struct __tempuri__AnDanSLTypeGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDanSLTypeGet(soap, &a->tempuri__AnDanSLTypeGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDanSLTypeGet_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDanSLTypeGet_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDanSLTypeGet(soap, "tempuri:AnDanSLTypeGet", -1, &a->tempuri__AnDanSLTypeGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDanSLTypeGet_ * SOAP_FMAC4 soap_in___tempuri__AnDanSLTypeGet_(struct soap *soap, const char *tag, struct __tempuri__AnDanSLTypeGet_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDanSLTypeGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDanSLTypeGet_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDanSLTypeGet_, sizeof(struct __tempuri__AnDanSLTypeGet_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDanSLTypeGet_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDanSLTypeGet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDanSLTypeGet(soap, "tempuri:AnDanSLTypeGet", &a->tempuri__AnDanSLTypeGet, ""))
				{	soap_flag_tempuri__AnDanSLTypeGet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDanSLTypeGet_ * SOAP_FMAC2 soap_dup___tempuri__AnDanSLTypeGet_(struct soap *soap, struct __tempuri__AnDanSLTypeGet_ *d, struct __tempuri__AnDanSLTypeGet_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDanSLTypeGet_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDanSLTypeGet_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDanSLTypeGet_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDanSLTypeGet(soap, &d->tempuri__AnDanSLTypeGet, &a->tempuri__AnDanSLTypeGet);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDanSLTypeGet_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDanSLTypeGet_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDanSLTypeGet_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDanSLTypeGet_ *p;
	size_t k = sizeof(struct __tempuri__AnDanSLTypeGet_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDanSLTypeGet_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDanSLTypeGet_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDanSLTypeGet_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDanSLTypeGet_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDanSLTypeGet_(struct soap *soap, const struct __tempuri__AnDanSLTypeGet_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDanSLTypeGet_(soap, tag ? tag : "-tempuri:AnDanSLTypeGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDanSLTypeGet_ * SOAP_FMAC4 soap_get___tempuri__AnDanSLTypeGet_(struct soap *soap, struct __tempuri__AnDanSLTypeGet_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDanSLTypeGet_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDan2PeoplePresent_(struct soap *soap, struct __tempuri__AnDan2PeoplePresent_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDan2PeoplePresent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDan2PeoplePresent_(struct soap *soap, const struct __tempuri__AnDan2PeoplePresent_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDan2PeoplePresent(soap, &a->tempuri__AnDan2PeoplePresent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDan2PeoplePresent_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDan2PeoplePresent_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDan2PeoplePresent(soap, "tempuri:AnDan2PeoplePresent", -1, &a->tempuri__AnDan2PeoplePresent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan2PeoplePresent_ * SOAP_FMAC4 soap_in___tempuri__AnDan2PeoplePresent_(struct soap *soap, const char *tag, struct __tempuri__AnDan2PeoplePresent_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDan2PeoplePresent = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDan2PeoplePresent_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDan2PeoplePresent_, sizeof(struct __tempuri__AnDan2PeoplePresent_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDan2PeoplePresent_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDan2PeoplePresent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDan2PeoplePresent(soap, "tempuri:AnDan2PeoplePresent", &a->tempuri__AnDan2PeoplePresent, ""))
				{	soap_flag_tempuri__AnDan2PeoplePresent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDan2PeoplePresent_ * SOAP_FMAC2 soap_dup___tempuri__AnDan2PeoplePresent_(struct soap *soap, struct __tempuri__AnDan2PeoplePresent_ *d, struct __tempuri__AnDan2PeoplePresent_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDan2PeoplePresent_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDan2PeoplePresent_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDan2PeoplePresent_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDan2PeoplePresent(soap, &d->tempuri__AnDan2PeoplePresent, &a->tempuri__AnDan2PeoplePresent);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDan2PeoplePresent_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDan2PeoplePresent_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDan2PeoplePresent_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDan2PeoplePresent_ *p;
	size_t k = sizeof(struct __tempuri__AnDan2PeoplePresent_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDan2PeoplePresent_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDan2PeoplePresent_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDan2PeoplePresent_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDan2PeoplePresent_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDan2PeoplePresent_(struct soap *soap, const struct __tempuri__AnDan2PeoplePresent_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDan2PeoplePresent_(soap, tag ? tag : "-tempuri:AnDan2PeoplePresent", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan2PeoplePresent_ * SOAP_FMAC4 soap_get___tempuri__AnDan2PeoplePresent_(struct soap *soap, struct __tempuri__AnDan2PeoplePresent_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDan2PeoplePresent_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDan3AddUsers_(struct soap *soap, struct __tempuri__AnDan3AddUsers_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDan3AddUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDan3AddUsers_(struct soap *soap, const struct __tempuri__AnDan3AddUsers_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDan3AddUsers(soap, &a->tempuri__AnDan3AddUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDan3AddUsers_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDan3AddUsers_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDan3AddUsers(soap, "tempuri:AnDan3AddUsers", -1, &a->tempuri__AnDan3AddUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan3AddUsers_ * SOAP_FMAC4 soap_in___tempuri__AnDan3AddUsers_(struct soap *soap, const char *tag, struct __tempuri__AnDan3AddUsers_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDan3AddUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDan3AddUsers_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDan3AddUsers_, sizeof(struct __tempuri__AnDan3AddUsers_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDan3AddUsers_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDan3AddUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDan3AddUsers(soap, "tempuri:AnDan3AddUsers", &a->tempuri__AnDan3AddUsers, ""))
				{	soap_flag_tempuri__AnDan3AddUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDan3AddUsers_ * SOAP_FMAC2 soap_dup___tempuri__AnDan3AddUsers_(struct soap *soap, struct __tempuri__AnDan3AddUsers_ *d, struct __tempuri__AnDan3AddUsers_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDan3AddUsers_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDan3AddUsers_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDan3AddUsers_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDan3AddUsers(soap, &d->tempuri__AnDan3AddUsers, &a->tempuri__AnDan3AddUsers);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDan3AddUsers_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDan3AddUsers_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDan3AddUsers_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDan3AddUsers_ *p;
	size_t k = sizeof(struct __tempuri__AnDan3AddUsers_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDan3AddUsers_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDan3AddUsers_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDan3AddUsers_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDan3AddUsers_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDan3AddUsers_(struct soap *soap, const struct __tempuri__AnDan3AddUsers_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDan3AddUsers_(soap, tag ? tag : "-tempuri:AnDan3AddUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan3AddUsers_ * SOAP_FMAC4 soap_get___tempuri__AnDan3AddUsers_(struct soap *soap, struct __tempuri__AnDan3AddUsers_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDan3AddUsers_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDan4UpdPeoplePresent_(struct soap *soap, struct __tempuri__AnDan4UpdPeoplePresent_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDan4UpdPeoplePresent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDan4UpdPeoplePresent_(struct soap *soap, const struct __tempuri__AnDan4UpdPeoplePresent_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, &a->tempuri__AnDan4UpdPeoplePresent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDan4UpdPeoplePresent_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDan4UpdPeoplePresent_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, "tempuri:AnDan4UpdPeoplePresent", -1, &a->tempuri__AnDan4UpdPeoplePresent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan4UpdPeoplePresent_ * SOAP_FMAC4 soap_in___tempuri__AnDan4UpdPeoplePresent_(struct soap *soap, const char *tag, struct __tempuri__AnDan4UpdPeoplePresent_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDan4UpdPeoplePresent = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDan4UpdPeoplePresent_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent_, sizeof(struct __tempuri__AnDan4UpdPeoplePresent_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDan4UpdPeoplePresent_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDan4UpdPeoplePresent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, "tempuri:AnDan4UpdPeoplePresent", &a->tempuri__AnDan4UpdPeoplePresent, ""))
				{	soap_flag_tempuri__AnDan4UpdPeoplePresent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDan4UpdPeoplePresent_ * SOAP_FMAC2 soap_dup___tempuri__AnDan4UpdPeoplePresent_(struct soap *soap, struct __tempuri__AnDan4UpdPeoplePresent_ *d, struct __tempuri__AnDan4UpdPeoplePresent_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDan4UpdPeoplePresent_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDan4UpdPeoplePresent_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, &d->tempuri__AnDan4UpdPeoplePresent, &a->tempuri__AnDan4UpdPeoplePresent);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDan4UpdPeoplePresent_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDan4UpdPeoplePresent_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDan4UpdPeoplePresent_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDan4UpdPeoplePresent_ *p;
	size_t k = sizeof(struct __tempuri__AnDan4UpdPeoplePresent_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDan4UpdPeoplePresent_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDan4UpdPeoplePresent_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDan4UpdPeoplePresent_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDan4UpdPeoplePresent_(struct soap *soap, const struct __tempuri__AnDan4UpdPeoplePresent_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDan4UpdPeoplePresent_(soap, tag ? tag : "-tempuri:AnDan4UpdPeoplePresent", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan4UpdPeoplePresent_ * SOAP_FMAC4 soap_get___tempuri__AnDan4UpdPeoplePresent_(struct soap *soap, struct __tempuri__AnDan4UpdPeoplePresent_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDan4UpdPeoplePresent_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDan1Send_(struct soap *soap, struct __tempuri__AnDan1Send_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDan1Send = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDan1Send_(struct soap *soap, const struct __tempuri__AnDan1Send_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDan1Send(soap, &a->tempuri__AnDan1Send);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDan1Send_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDan1Send_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDan1Send(soap, "tempuri:AnDan1Send", -1, &a->tempuri__AnDan1Send, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan1Send_ * SOAP_FMAC4 soap_in___tempuri__AnDan1Send_(struct soap *soap, const char *tag, struct __tempuri__AnDan1Send_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDan1Send = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDan1Send_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDan1Send_, sizeof(struct __tempuri__AnDan1Send_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDan1Send_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDan1Send && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDan1Send(soap, "tempuri:AnDan1Send", &a->tempuri__AnDan1Send, ""))
				{	soap_flag_tempuri__AnDan1Send--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDan1Send_ * SOAP_FMAC2 soap_dup___tempuri__AnDan1Send_(struct soap *soap, struct __tempuri__AnDan1Send_ *d, struct __tempuri__AnDan1Send_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDan1Send_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDan1Send_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDan1Send_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDan1Send(soap, &d->tempuri__AnDan1Send, &a->tempuri__AnDan1Send);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDan1Send_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDan1Send_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDan1Send_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDan1Send_ *p;
	size_t k = sizeof(struct __tempuri__AnDan1Send_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDan1Send_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDan1Send_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDan1Send_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDan1Send_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDan1Send_(struct soap *soap, const struct __tempuri__AnDan1Send_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDan1Send_(soap, tag ? tag : "-tempuri:AnDan1Send", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan1Send_ * SOAP_FMAC4 soap_get___tempuri__AnDan1Send_(struct soap *soap, struct __tempuri__AnDan1Send_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDan1Send_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__Login_(struct soap *soap, struct __tempuri__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__Login_(struct soap *soap, const struct __tempuri__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__Login(soap, &a->tempuri__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__Login_(struct soap *soap, const char *tag, int id, const struct __tempuri__Login_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__Login(soap, "tempuri:Login", -1, &a->tempuri__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__Login_ * SOAP_FMAC4 soap_in___tempuri__Login_(struct soap *soap, const char *tag, struct __tempuri__Login_ *a, const char *type)
{
	size_t soap_flag_tempuri__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__Login_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__Login_, sizeof(struct __tempuri__Login_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__Login_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__Login && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__Login(soap, "tempuri:Login", &a->tempuri__Login, ""))
				{	soap_flag_tempuri__Login--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__Login_ * SOAP_FMAC2 soap_dup___tempuri__Login_(struct soap *soap, struct __tempuri__Login_ *d, struct __tempuri__Login_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__Login_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__Login_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__Login_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__Login(soap, &d->tempuri__Login, &a->tempuri__Login);
	return d;
}

SOAP_FMAC1 struct __tempuri__Login_ * SOAP_FMAC2 soap_instantiate___tempuri__Login_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__Login_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__Login_ *p;
	size_t k = sizeof(struct __tempuri__Login_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__Login_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__Login_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__Login_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__Login_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__Login_(struct soap *soap, const struct __tempuri__Login_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__Login_(soap, tag ? tag : "-tempuri:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__Login_ * SOAP_FMAC4 soap_get___tempuri__Login_(struct soap *soap, struct __tempuri__Login_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__Login_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetPower_(struct soap *soap, struct __tempuri__GetPower_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetPower = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetPower_(struct soap *soap, const struct __tempuri__GetPower_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetPower(soap, &a->tempuri__GetPower);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetPower_(struct soap *soap, const char *tag, int id, const struct __tempuri__GetPower_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetPower(soap, "tempuri:GetPower", -1, &a->tempuri__GetPower, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetPower_ * SOAP_FMAC4 soap_in___tempuri__GetPower_(struct soap *soap, const char *tag, struct __tempuri__GetPower_ *a, const char *type)
{
	size_t soap_flag_tempuri__GetPower = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetPower_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetPower_, sizeof(struct __tempuri__GetPower_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetPower_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetPower && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetPower(soap, "tempuri:GetPower", &a->tempuri__GetPower, ""))
				{	soap_flag_tempuri__GetPower--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetPower_ * SOAP_FMAC2 soap_dup___tempuri__GetPower_(struct soap *soap, struct __tempuri__GetPower_ *d, struct __tempuri__GetPower_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__GetPower_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__GetPower_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__GetPower_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__GetPower(soap, &d->tempuri__GetPower, &a->tempuri__GetPower);
	return d;
}

SOAP_FMAC1 struct __tempuri__GetPower_ * SOAP_FMAC2 soap_instantiate___tempuri__GetPower_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetPower_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetPower_ *p;
	size_t k = sizeof(struct __tempuri__GetPower_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetPower_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetPower_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetPower_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetPower_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetPower_(struct soap *soap, const struct __tempuri__GetPower_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetPower_(soap, tag ? tag : "-tempuri:GetPower", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetPower_ * SOAP_FMAC4 soap_get___tempuri__GetPower_(struct soap *soap, struct __tempuri__GetPower_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetPower_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDept_(struct soap *soap, struct __tempuri__GetDept_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDept = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDept_(struct soap *soap, const struct __tempuri__GetDept_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDept(soap, &a->tempuri__GetDept);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDept_(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDept_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDept(soap, "tempuri:GetDept", -1, &a->tempuri__GetDept, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDept_ * SOAP_FMAC4 soap_in___tempuri__GetDept_(struct soap *soap, const char *tag, struct __tempuri__GetDept_ *a, const char *type)
{
	size_t soap_flag_tempuri__GetDept = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDept_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDept_, sizeof(struct __tempuri__GetDept_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDept_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDept && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDept(soap, "tempuri:GetDept", &a->tempuri__GetDept, ""))
				{	soap_flag_tempuri__GetDept--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDept_ * SOAP_FMAC2 soap_dup___tempuri__GetDept_(struct soap *soap, struct __tempuri__GetDept_ *d, struct __tempuri__GetDept_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__GetDept_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__GetDept_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__GetDept_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__GetDept(soap, &d->tempuri__GetDept, &a->tempuri__GetDept);
	return d;
}

SOAP_FMAC1 struct __tempuri__GetDept_ * SOAP_FMAC2 soap_instantiate___tempuri__GetDept_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDept_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDept_ *p;
	size_t k = sizeof(struct __tempuri__GetDept_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetDept_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetDept_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetDept_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDept_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDept_(struct soap *soap, const struct __tempuri__GetDept_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDept_(soap, tag ? tag : "-tempuri:GetDept", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDept_ * SOAP_FMAC4 soap_get___tempuri__GetDept_(struct soap *soap, struct __tempuri__GetDept_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDept_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__DocAdd_(struct soap *soap, struct __tempuri__DocAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__DocAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__DocAdd_(struct soap *soap, const struct __tempuri__DocAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__DocAdd(soap, &a->tempuri__DocAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__DocAdd_(struct soap *soap, const char *tag, int id, const struct __tempuri__DocAdd_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", -1, &a->tempuri__DocAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd_ * SOAP_FMAC4 soap_in___tempuri__DocAdd_(struct soap *soap, const char *tag, struct __tempuri__DocAdd_ *a, const char *type)
{
	size_t soap_flag_tempuri__DocAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__DocAdd_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__DocAdd_, sizeof(struct __tempuri__DocAdd_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__DocAdd_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__DocAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", &a->tempuri__DocAdd, ""))
				{	soap_flag_tempuri__DocAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__DocAdd_ * SOAP_FMAC2 soap_dup___tempuri__DocAdd_(struct soap *soap, struct __tempuri__DocAdd_ *d, struct __tempuri__DocAdd_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__DocAdd_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__DocAdd_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__DocAdd_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__DocAdd(soap, &d->tempuri__DocAdd, &a->tempuri__DocAdd);
	return d;
}

SOAP_FMAC1 struct __tempuri__DocAdd_ * SOAP_FMAC2 soap_instantiate___tempuri__DocAdd_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__DocAdd_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__DocAdd_ *p;
	size_t k = sizeof(struct __tempuri__DocAdd_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__DocAdd_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__DocAdd_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__DocAdd_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__DocAdd_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__DocAdd_(struct soap *soap, const struct __tempuri__DocAdd_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__DocAdd_(soap, tag ? tag : "-tempuri:DocAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd_ * SOAP_FMAC4 soap_get___tempuri__DocAdd_(struct soap *soap, struct __tempuri__DocAdd_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__DocAdd_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__ItemsAdd_(struct soap *soap, struct __tempuri__ItemsAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ItemsAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__ItemsAdd_(struct soap *soap, const struct __tempuri__ItemsAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ItemsAdd(soap, &a->tempuri__ItemsAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__ItemsAdd_(struct soap *soap, const char *tag, int id, const struct __tempuri__ItemsAdd_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ItemsAdd(soap, "tempuri:ItemsAdd", -1, &a->tempuri__ItemsAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ItemsAdd_ * SOAP_FMAC4 soap_in___tempuri__ItemsAdd_(struct soap *soap, const char *tag, struct __tempuri__ItemsAdd_ *a, const char *type)
{
	size_t soap_flag_tempuri__ItemsAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__ItemsAdd_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__ItemsAdd_, sizeof(struct __tempuri__ItemsAdd_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__ItemsAdd_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ItemsAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ItemsAdd(soap, "tempuri:ItemsAdd", &a->tempuri__ItemsAdd, ""))
				{	soap_flag_tempuri__ItemsAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__ItemsAdd_ * SOAP_FMAC2 soap_dup___tempuri__ItemsAdd_(struct soap *soap, struct __tempuri__ItemsAdd_ *d, struct __tempuri__ItemsAdd_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__ItemsAdd_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__ItemsAdd_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__ItemsAdd_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__ItemsAdd(soap, &d->tempuri__ItemsAdd, &a->tempuri__ItemsAdd);
	return d;
}

SOAP_FMAC1 struct __tempuri__ItemsAdd_ * SOAP_FMAC2 soap_instantiate___tempuri__ItemsAdd_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__ItemsAdd_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__ItemsAdd_ *p;
	size_t k = sizeof(struct __tempuri__ItemsAdd_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__ItemsAdd_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__ItemsAdd_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__ItemsAdd_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__ItemsAdd_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__ItemsAdd_(struct soap *soap, const struct __tempuri__ItemsAdd_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__ItemsAdd_(soap, tag ? tag : "-tempuri:ItemsAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ItemsAdd_ * SOAP_FMAC4 soap_get___tempuri__ItemsAdd_(struct soap *soap, struct __tempuri__ItemsAdd_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__ItemsAdd_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventoryReturn_(struct soap *soap, struct __tempuri__LineInventoryReturn_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventoryReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventoryReturn_(struct soap *soap, const struct __tempuri__LineInventoryReturn_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventoryReturn(soap, &a->tempuri__LineInventoryReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventoryReturn_(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventoryReturn_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventoryReturn(soap, "tempuri:LineInventoryReturn", -1, &a->tempuri__LineInventoryReturn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryReturn_ * SOAP_FMAC4 soap_in___tempuri__LineInventoryReturn_(struct soap *soap, const char *tag, struct __tempuri__LineInventoryReturn_ *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventoryReturn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventoryReturn_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventoryReturn_, sizeof(struct __tempuri__LineInventoryReturn_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventoryReturn_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventoryReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventoryReturn(soap, "tempuri:LineInventoryReturn", &a->tempuri__LineInventoryReturn, ""))
				{	soap_flag_tempuri__LineInventoryReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventoryReturn_ * SOAP_FMAC2 soap_dup___tempuri__LineInventoryReturn_(struct soap *soap, struct __tempuri__LineInventoryReturn_ *d, struct __tempuri__LineInventoryReturn_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__LineInventoryReturn_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__LineInventoryReturn_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__LineInventoryReturn_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__LineInventoryReturn(soap, &d->tempuri__LineInventoryReturn, &a->tempuri__LineInventoryReturn);
	return d;
}

SOAP_FMAC1 struct __tempuri__LineInventoryReturn_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryReturn_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventoryReturn_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventoryReturn_ *p;
	size_t k = sizeof(struct __tempuri__LineInventoryReturn_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__LineInventoryReturn_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__LineInventoryReturn_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__LineInventoryReturn_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventoryReturn_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventoryReturn_(struct soap *soap, const struct __tempuri__LineInventoryReturn_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventoryReturn_(soap, tag ? tag : "-tempuri:LineInventoryReturn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryReturn_ * SOAP_FMAC4 soap_get___tempuri__LineInventoryReturn_(struct soap *soap, struct __tempuri__LineInventoryReturn_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventoryReturn_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventoryUpdate_(struct soap *soap, struct __tempuri__LineInventoryUpdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventoryUpdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventoryUpdate_(struct soap *soap, const struct __tempuri__LineInventoryUpdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventoryUpdate(soap, &a->tempuri__LineInventoryUpdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventoryUpdate_(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventoryUpdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventoryUpdate(soap, "tempuri:LineInventoryUpdate", -1, &a->tempuri__LineInventoryUpdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryUpdate_ * SOAP_FMAC4 soap_in___tempuri__LineInventoryUpdate_(struct soap *soap, const char *tag, struct __tempuri__LineInventoryUpdate_ *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventoryUpdate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventoryUpdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventoryUpdate_, sizeof(struct __tempuri__LineInventoryUpdate_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventoryUpdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventoryUpdate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventoryUpdate(soap, "tempuri:LineInventoryUpdate", &a->tempuri__LineInventoryUpdate, ""))
				{	soap_flag_tempuri__LineInventoryUpdate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventoryUpdate_ * SOAP_FMAC2 soap_dup___tempuri__LineInventoryUpdate_(struct soap *soap, struct __tempuri__LineInventoryUpdate_ *d, struct __tempuri__LineInventoryUpdate_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__LineInventoryUpdate_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__LineInventoryUpdate_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__LineInventoryUpdate_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__LineInventoryUpdate(soap, &d->tempuri__LineInventoryUpdate, &a->tempuri__LineInventoryUpdate);
	return d;
}

SOAP_FMAC1 struct __tempuri__LineInventoryUpdate_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryUpdate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventoryUpdate_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventoryUpdate_ *p;
	size_t k = sizeof(struct __tempuri__LineInventoryUpdate_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__LineInventoryUpdate_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__LineInventoryUpdate_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__LineInventoryUpdate_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventoryUpdate_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventoryUpdate_(struct soap *soap, const struct __tempuri__LineInventoryUpdate_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventoryUpdate_(soap, tag ? tag : "-tempuri:LineInventoryUpdate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryUpdate_ * SOAP_FMAC4 soap_get___tempuri__LineInventoryUpdate_(struct soap *soap, struct __tempuri__LineInventoryUpdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventoryUpdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventory_(struct soap *soap, struct __tempuri__LineInventory_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventory_(struct soap *soap, const struct __tempuri__LineInventory_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventory(soap, &a->tempuri__LineInventory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventory_(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventory_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", -1, &a->tempuri__LineInventory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory_ * SOAP_FMAC4 soap_in___tempuri__LineInventory_(struct soap *soap, const char *tag, struct __tempuri__LineInventory_ *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventory = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventory_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventory_, sizeof(struct __tempuri__LineInventory_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventory_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventory && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", &a->tempuri__LineInventory, ""))
				{	soap_flag_tempuri__LineInventory--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventory_ * SOAP_FMAC2 soap_dup___tempuri__LineInventory_(struct soap *soap, struct __tempuri__LineInventory_ *d, struct __tempuri__LineInventory_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__LineInventory_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__LineInventory_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__LineInventory_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__LineInventory(soap, &d->tempuri__LineInventory, &a->tempuri__LineInventory);
	return d;
}

SOAP_FMAC1 struct __tempuri__LineInventory_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventory_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventory_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventory_ *p;
	size_t k = sizeof(struct __tempuri__LineInventory_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__LineInventory_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__LineInventory_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__LineInventory_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventory_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventory_(struct soap *soap, const struct __tempuri__LineInventory_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventory_(soap, tag ? tag : "-tempuri:LineInventory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory_ * SOAP_FMAC4 soap_get___tempuri__LineInventory_(struct soap *soap, struct __tempuri__LineInventory_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventory_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__WorkOrder_(struct soap *soap, struct __tempuri__WorkOrder_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__WorkOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__WorkOrder_(struct soap *soap, const struct __tempuri__WorkOrder_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__WorkOrder(soap, &a->tempuri__WorkOrder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__WorkOrder_(struct soap *soap, const char *tag, int id, const struct __tempuri__WorkOrder_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__WorkOrder(soap, "tempuri:WorkOrder", -1, &a->tempuri__WorkOrder, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__WorkOrder_ * SOAP_FMAC4 soap_in___tempuri__WorkOrder_(struct soap *soap, const char *tag, struct __tempuri__WorkOrder_ *a, const char *type)
{
	size_t soap_flag_tempuri__WorkOrder = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__WorkOrder_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__WorkOrder_, sizeof(struct __tempuri__WorkOrder_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__WorkOrder_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__WorkOrder && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__WorkOrder(soap, "tempuri:WorkOrder", &a->tempuri__WorkOrder, ""))
				{	soap_flag_tempuri__WorkOrder--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__WorkOrder_ * SOAP_FMAC2 soap_dup___tempuri__WorkOrder_(struct soap *soap, struct __tempuri__WorkOrder_ *d, struct __tempuri__WorkOrder_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__WorkOrder_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__WorkOrder_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__WorkOrder_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__WorkOrder(soap, &d->tempuri__WorkOrder, &a->tempuri__WorkOrder);
	return d;
}

SOAP_FMAC1 struct __tempuri__WorkOrder_ * SOAP_FMAC2 soap_instantiate___tempuri__WorkOrder_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__WorkOrder_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__WorkOrder_ *p;
	size_t k = sizeof(struct __tempuri__WorkOrder_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__WorkOrder_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__WorkOrder_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__WorkOrder_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__WorkOrder_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__WorkOrder_(struct soap *soap, const struct __tempuri__WorkOrder_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__WorkOrder_(soap, tag ? tag : "-tempuri:WorkOrder", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__WorkOrder_ * SOAP_FMAC4 soap_get___tempuri__WorkOrder_(struct soap *soap, struct __tempuri__WorkOrder_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__WorkOrder_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__ToolingTimes_(struct soap *soap, struct __tempuri__ToolingTimes_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ToolingTimes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__ToolingTimes_(struct soap *soap, const struct __tempuri__ToolingTimes_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ToolingTimes(soap, &a->tempuri__ToolingTimes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__ToolingTimes_(struct soap *soap, const char *tag, int id, const struct __tempuri__ToolingTimes_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", -1, &a->tempuri__ToolingTimes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes_ * SOAP_FMAC4 soap_in___tempuri__ToolingTimes_(struct soap *soap, const char *tag, struct __tempuri__ToolingTimes_ *a, const char *type)
{
	size_t soap_flag_tempuri__ToolingTimes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__ToolingTimes_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__ToolingTimes_, sizeof(struct __tempuri__ToolingTimes_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__ToolingTimes_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ToolingTimes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", &a->tempuri__ToolingTimes, ""))
				{	soap_flag_tempuri__ToolingTimes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__ToolingTimes_ * SOAP_FMAC2 soap_dup___tempuri__ToolingTimes_(struct soap *soap, struct __tempuri__ToolingTimes_ *d, struct __tempuri__ToolingTimes_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__ToolingTimes_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__ToolingTimes_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__ToolingTimes_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__ToolingTimes(soap, &d->tempuri__ToolingTimes, &a->tempuri__ToolingTimes);
	return d;
}

SOAP_FMAC1 struct __tempuri__ToolingTimes_ * SOAP_FMAC2 soap_instantiate___tempuri__ToolingTimes_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__ToolingTimes_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__ToolingTimes_ *p;
	size_t k = sizeof(struct __tempuri__ToolingTimes_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__ToolingTimes_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__ToolingTimes_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__ToolingTimes_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__ToolingTimes_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__ToolingTimes_(struct soap *soap, const struct __tempuri__ToolingTimes_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__ToolingTimes_(soap, tag ? tag : "-tempuri:ToolingTimes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes_ * SOAP_FMAC4 soap_get___tempuri__ToolingTimes_(struct soap *soap, struct __tempuri__ToolingTimes_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__ToolingTimes_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDocCode_(struct soap *soap, struct __tempuri__GetDocCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDocCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDocCode_(struct soap *soap, const struct __tempuri__GetDocCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDocCode(soap, &a->tempuri__GetDocCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDocCode_(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDocCode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDocCode(soap, "tempuri:GetDocCode", -1, &a->tempuri__GetDocCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDocCode_ * SOAP_FMAC4 soap_in___tempuri__GetDocCode_(struct soap *soap, const char *tag, struct __tempuri__GetDocCode_ *a, const char *type)
{
	size_t soap_flag_tempuri__GetDocCode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDocCode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDocCode_, sizeof(struct __tempuri__GetDocCode_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDocCode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDocCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDocCode(soap, "tempuri:GetDocCode", &a->tempuri__GetDocCode, ""))
				{	soap_flag_tempuri__GetDocCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDocCode_ * SOAP_FMAC2 soap_dup___tempuri__GetDocCode_(struct soap *soap, struct __tempuri__GetDocCode_ *d, struct __tempuri__GetDocCode_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__GetDocCode_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__GetDocCode_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__GetDocCode_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__GetDocCode(soap, &d->tempuri__GetDocCode, &a->tempuri__GetDocCode);
	return d;
}

SOAP_FMAC1 struct __tempuri__GetDocCode_ * SOAP_FMAC2 soap_instantiate___tempuri__GetDocCode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDocCode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDocCode_ *p;
	size_t k = sizeof(struct __tempuri__GetDocCode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetDocCode_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetDocCode_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetDocCode_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDocCode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDocCode_(struct soap *soap, const struct __tempuri__GetDocCode_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDocCode_(soap, tag ? tag : "-tempuri:GetDocCode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDocCode_ * SOAP_FMAC4 soap_get___tempuri__GetDocCode_(struct soap *soap, struct __tempuri__GetDocCode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDocCode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDate_(struct soap *soap, struct __tempuri__GetDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDate_(struct soap *soap, const struct __tempuri__GetDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDate(soap, &a->tempuri__GetDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDate_(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDate(soap, "tempuri:GetDate", -1, &a->tempuri__GetDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDate_ * SOAP_FMAC4 soap_in___tempuri__GetDate_(struct soap *soap, const char *tag, struct __tempuri__GetDate_ *a, const char *type)
{
	size_t soap_flag_tempuri__GetDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDate_, sizeof(struct __tempuri__GetDate_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDate(soap, "tempuri:GetDate", &a->tempuri__GetDate, ""))
				{	soap_flag_tempuri__GetDate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDate_ * SOAP_FMAC2 soap_dup___tempuri__GetDate_(struct soap *soap, struct __tempuri__GetDate_ *d, struct __tempuri__GetDate_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__GetDate_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__GetDate_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__GetDate_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__GetDate(soap, &d->tempuri__GetDate, &a->tempuri__GetDate);
	return d;
}

SOAP_FMAC1 struct __tempuri__GetDate_ * SOAP_FMAC2 soap_instantiate___tempuri__GetDate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDate_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDate_ *p;
	size_t k = sizeof(struct __tempuri__GetDate_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetDate_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetDate_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetDate_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDate_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDate_(struct soap *soap, const struct __tempuri__GetDate_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDate_(soap, tag ? tag : "-tempuri:GetDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDate_ * SOAP_FMAC4 soap_get___tempuri__GetDate_(struct soap *soap, struct __tempuri__GetDate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDanSLTypeAdd(struct soap *soap, struct __tempuri__AnDanSLTypeAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDanSLTypeAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDanSLTypeAdd(struct soap *soap, const struct __tempuri__AnDanSLTypeAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDanSLTypeAdd(soap, &a->tempuri__AnDanSLTypeAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDanSLTypeAdd(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDanSLTypeAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDanSLTypeAdd(soap, "tempuri:AnDanSLTypeAdd", -1, &a->tempuri__AnDanSLTypeAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDanSLTypeAdd * SOAP_FMAC4 soap_in___tempuri__AnDanSLTypeAdd(struct soap *soap, const char *tag, struct __tempuri__AnDanSLTypeAdd *a, const char *type)
{
	size_t soap_flag_tempuri__AnDanSLTypeAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDanSLTypeAdd *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDanSLTypeAdd, sizeof(struct __tempuri__AnDanSLTypeAdd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDanSLTypeAdd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDanSLTypeAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDanSLTypeAdd(soap, "tempuri:AnDanSLTypeAdd", &a->tempuri__AnDanSLTypeAdd, ""))
				{	soap_flag_tempuri__AnDanSLTypeAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDanSLTypeAdd * SOAP_FMAC2 soap_dup___tempuri__AnDanSLTypeAdd(struct soap *soap, struct __tempuri__AnDanSLTypeAdd *d, struct __tempuri__AnDanSLTypeAdd const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDanSLTypeAdd*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDanSLTypeAdd, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDanSLTypeAdd(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDanSLTypeAdd(soap, &d->tempuri__AnDanSLTypeAdd, &a->tempuri__AnDanSLTypeAdd);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDanSLTypeAdd * SOAP_FMAC2 soap_instantiate___tempuri__AnDanSLTypeAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDanSLTypeAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDanSLTypeAdd *p;
	size_t k = sizeof(struct __tempuri__AnDanSLTypeAdd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDanSLTypeAdd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDanSLTypeAdd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDanSLTypeAdd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDanSLTypeAdd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDanSLTypeAdd(struct soap *soap, const struct __tempuri__AnDanSLTypeAdd *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDanSLTypeAdd(soap, tag ? tag : "-tempuri:AnDanSLTypeAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDanSLTypeAdd * SOAP_FMAC4 soap_get___tempuri__AnDanSLTypeAdd(struct soap *soap, struct __tempuri__AnDanSLTypeAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDanSLTypeAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDanSLTypeGet(struct soap *soap, struct __tempuri__AnDanSLTypeGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDanSLTypeGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDanSLTypeGet(struct soap *soap, const struct __tempuri__AnDanSLTypeGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDanSLTypeGet(soap, &a->tempuri__AnDanSLTypeGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDanSLTypeGet(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDanSLTypeGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDanSLTypeGet(soap, "tempuri:AnDanSLTypeGet", -1, &a->tempuri__AnDanSLTypeGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDanSLTypeGet * SOAP_FMAC4 soap_in___tempuri__AnDanSLTypeGet(struct soap *soap, const char *tag, struct __tempuri__AnDanSLTypeGet *a, const char *type)
{
	size_t soap_flag_tempuri__AnDanSLTypeGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDanSLTypeGet *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDanSLTypeGet, sizeof(struct __tempuri__AnDanSLTypeGet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDanSLTypeGet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDanSLTypeGet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDanSLTypeGet(soap, "tempuri:AnDanSLTypeGet", &a->tempuri__AnDanSLTypeGet, ""))
				{	soap_flag_tempuri__AnDanSLTypeGet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDanSLTypeGet * SOAP_FMAC2 soap_dup___tempuri__AnDanSLTypeGet(struct soap *soap, struct __tempuri__AnDanSLTypeGet *d, struct __tempuri__AnDanSLTypeGet const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDanSLTypeGet*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDanSLTypeGet, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDanSLTypeGet(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDanSLTypeGet(soap, &d->tempuri__AnDanSLTypeGet, &a->tempuri__AnDanSLTypeGet);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDanSLTypeGet * SOAP_FMAC2 soap_instantiate___tempuri__AnDanSLTypeGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDanSLTypeGet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDanSLTypeGet *p;
	size_t k = sizeof(struct __tempuri__AnDanSLTypeGet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDanSLTypeGet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDanSLTypeGet);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDanSLTypeGet, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDanSLTypeGet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDanSLTypeGet(struct soap *soap, const struct __tempuri__AnDanSLTypeGet *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDanSLTypeGet(soap, tag ? tag : "-tempuri:AnDanSLTypeGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDanSLTypeGet * SOAP_FMAC4 soap_get___tempuri__AnDanSLTypeGet(struct soap *soap, struct __tempuri__AnDanSLTypeGet *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDanSLTypeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDan2PeoplePresent(struct soap *soap, struct __tempuri__AnDan2PeoplePresent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDan2PeoplePresent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDan2PeoplePresent(struct soap *soap, const struct __tempuri__AnDan2PeoplePresent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDan2PeoplePresent(soap, &a->tempuri__AnDan2PeoplePresent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDan2PeoplePresent(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDan2PeoplePresent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDan2PeoplePresent(soap, "tempuri:AnDan2PeoplePresent", -1, &a->tempuri__AnDan2PeoplePresent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan2PeoplePresent * SOAP_FMAC4 soap_in___tempuri__AnDan2PeoplePresent(struct soap *soap, const char *tag, struct __tempuri__AnDan2PeoplePresent *a, const char *type)
{
	size_t soap_flag_tempuri__AnDan2PeoplePresent = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDan2PeoplePresent *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDan2PeoplePresent, sizeof(struct __tempuri__AnDan2PeoplePresent), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDan2PeoplePresent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDan2PeoplePresent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDan2PeoplePresent(soap, "tempuri:AnDan2PeoplePresent", &a->tempuri__AnDan2PeoplePresent, ""))
				{	soap_flag_tempuri__AnDan2PeoplePresent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDan2PeoplePresent * SOAP_FMAC2 soap_dup___tempuri__AnDan2PeoplePresent(struct soap *soap, struct __tempuri__AnDan2PeoplePresent *d, struct __tempuri__AnDan2PeoplePresent const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDan2PeoplePresent*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDan2PeoplePresent, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDan2PeoplePresent(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDan2PeoplePresent(soap, &d->tempuri__AnDan2PeoplePresent, &a->tempuri__AnDan2PeoplePresent);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDan2PeoplePresent * SOAP_FMAC2 soap_instantiate___tempuri__AnDan2PeoplePresent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDan2PeoplePresent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDan2PeoplePresent *p;
	size_t k = sizeof(struct __tempuri__AnDan2PeoplePresent);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDan2PeoplePresent, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDan2PeoplePresent);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDan2PeoplePresent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDan2PeoplePresent location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDan2PeoplePresent(struct soap *soap, const struct __tempuri__AnDan2PeoplePresent *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDan2PeoplePresent(soap, tag ? tag : "-tempuri:AnDan2PeoplePresent", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan2PeoplePresent * SOAP_FMAC4 soap_get___tempuri__AnDan2PeoplePresent(struct soap *soap, struct __tempuri__AnDan2PeoplePresent *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDan2PeoplePresent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDan3AddUsers(struct soap *soap, struct __tempuri__AnDan3AddUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDan3AddUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDan3AddUsers(struct soap *soap, const struct __tempuri__AnDan3AddUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDan3AddUsers(soap, &a->tempuri__AnDan3AddUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDan3AddUsers(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDan3AddUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDan3AddUsers(soap, "tempuri:AnDan3AddUsers", -1, &a->tempuri__AnDan3AddUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan3AddUsers * SOAP_FMAC4 soap_in___tempuri__AnDan3AddUsers(struct soap *soap, const char *tag, struct __tempuri__AnDan3AddUsers *a, const char *type)
{
	size_t soap_flag_tempuri__AnDan3AddUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDan3AddUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDan3AddUsers, sizeof(struct __tempuri__AnDan3AddUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDan3AddUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDan3AddUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDan3AddUsers(soap, "tempuri:AnDan3AddUsers", &a->tempuri__AnDan3AddUsers, ""))
				{	soap_flag_tempuri__AnDan3AddUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDan3AddUsers * SOAP_FMAC2 soap_dup___tempuri__AnDan3AddUsers(struct soap *soap, struct __tempuri__AnDan3AddUsers *d, struct __tempuri__AnDan3AddUsers const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDan3AddUsers*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDan3AddUsers, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDan3AddUsers(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDan3AddUsers(soap, &d->tempuri__AnDan3AddUsers, &a->tempuri__AnDan3AddUsers);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDan3AddUsers * SOAP_FMAC2 soap_instantiate___tempuri__AnDan3AddUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDan3AddUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDan3AddUsers *p;
	size_t k = sizeof(struct __tempuri__AnDan3AddUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDan3AddUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDan3AddUsers);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDan3AddUsers, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDan3AddUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDan3AddUsers(struct soap *soap, const struct __tempuri__AnDan3AddUsers *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDan3AddUsers(soap, tag ? tag : "-tempuri:AnDan3AddUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan3AddUsers * SOAP_FMAC4 soap_get___tempuri__AnDan3AddUsers(struct soap *soap, struct __tempuri__AnDan3AddUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDan3AddUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDan4UpdPeoplePresent(struct soap *soap, struct __tempuri__AnDan4UpdPeoplePresent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDan4UpdPeoplePresent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDan4UpdPeoplePresent(struct soap *soap, const struct __tempuri__AnDan4UpdPeoplePresent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, &a->tempuri__AnDan4UpdPeoplePresent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDan4UpdPeoplePresent(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDan4UpdPeoplePresent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, "tempuri:AnDan4UpdPeoplePresent", -1, &a->tempuri__AnDan4UpdPeoplePresent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan4UpdPeoplePresent * SOAP_FMAC4 soap_in___tempuri__AnDan4UpdPeoplePresent(struct soap *soap, const char *tag, struct __tempuri__AnDan4UpdPeoplePresent *a, const char *type)
{
	size_t soap_flag_tempuri__AnDan4UpdPeoplePresent = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDan4UpdPeoplePresent *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent, sizeof(struct __tempuri__AnDan4UpdPeoplePresent), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDan4UpdPeoplePresent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDan4UpdPeoplePresent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, "tempuri:AnDan4UpdPeoplePresent", &a->tempuri__AnDan4UpdPeoplePresent, ""))
				{	soap_flag_tempuri__AnDan4UpdPeoplePresent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDan4UpdPeoplePresent * SOAP_FMAC2 soap_dup___tempuri__AnDan4UpdPeoplePresent(struct soap *soap, struct __tempuri__AnDan4UpdPeoplePresent *d, struct __tempuri__AnDan4UpdPeoplePresent const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDan4UpdPeoplePresent*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDan4UpdPeoplePresent(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, &d->tempuri__AnDan4UpdPeoplePresent, &a->tempuri__AnDan4UpdPeoplePresent);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDan4UpdPeoplePresent * SOAP_FMAC2 soap_instantiate___tempuri__AnDan4UpdPeoplePresent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDan4UpdPeoplePresent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDan4UpdPeoplePresent *p;
	size_t k = sizeof(struct __tempuri__AnDan4UpdPeoplePresent);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDan4UpdPeoplePresent, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDan4UpdPeoplePresent);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDan4UpdPeoplePresent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDan4UpdPeoplePresent location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDan4UpdPeoplePresent(struct soap *soap, const struct __tempuri__AnDan4UpdPeoplePresent *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDan4UpdPeoplePresent(soap, tag ? tag : "-tempuri:AnDan4UpdPeoplePresent", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan4UpdPeoplePresent * SOAP_FMAC4 soap_get___tempuri__AnDan4UpdPeoplePresent(struct soap *soap, struct __tempuri__AnDan4UpdPeoplePresent *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDan4UpdPeoplePresent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDan1Send(struct soap *soap, struct __tempuri__AnDan1Send *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDan1Send = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDan1Send(struct soap *soap, const struct __tempuri__AnDan1Send *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDan1Send(soap, &a->tempuri__AnDan1Send);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDan1Send(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDan1Send *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDan1Send(soap, "tempuri:AnDan1Send", -1, &a->tempuri__AnDan1Send, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan1Send * SOAP_FMAC4 soap_in___tempuri__AnDan1Send(struct soap *soap, const char *tag, struct __tempuri__AnDan1Send *a, const char *type)
{
	size_t soap_flag_tempuri__AnDan1Send = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDan1Send *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDan1Send, sizeof(struct __tempuri__AnDan1Send), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDan1Send(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDan1Send && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDan1Send(soap, "tempuri:AnDan1Send", &a->tempuri__AnDan1Send, ""))
				{	soap_flag_tempuri__AnDan1Send--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDan1Send * SOAP_FMAC2 soap_dup___tempuri__AnDan1Send(struct soap *soap, struct __tempuri__AnDan1Send *d, struct __tempuri__AnDan1Send const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__AnDan1Send*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__AnDan1Send, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__AnDan1Send(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__AnDan1Send(soap, &d->tempuri__AnDan1Send, &a->tempuri__AnDan1Send);
	return d;
}

SOAP_FMAC1 struct __tempuri__AnDan1Send * SOAP_FMAC2 soap_instantiate___tempuri__AnDan1Send(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDan1Send(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDan1Send *p;
	size_t k = sizeof(struct __tempuri__AnDan1Send);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AnDan1Send, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AnDan1Send);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AnDan1Send, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDan1Send location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDan1Send(struct soap *soap, const struct __tempuri__AnDan1Send *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDan1Send(soap, tag ? tag : "-tempuri:AnDan1Send", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDan1Send * SOAP_FMAC4 soap_get___tempuri__AnDan1Send(struct soap *soap, struct __tempuri__AnDan1Send *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDan1Send(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__Login(struct soap *soap, struct __tempuri__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__Login(struct soap *soap, const struct __tempuri__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__Login(soap, &a->tempuri__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__Login(struct soap *soap, const char *tag, int id, const struct __tempuri__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__Login(soap, "tempuri:Login", -1, &a->tempuri__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__Login * SOAP_FMAC4 soap_in___tempuri__Login(struct soap *soap, const char *tag, struct __tempuri__Login *a, const char *type)
{
	size_t soap_flag_tempuri__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__Login *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__Login, sizeof(struct __tempuri__Login), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__Login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__Login && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__Login(soap, "tempuri:Login", &a->tempuri__Login, ""))
				{	soap_flag_tempuri__Login--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__Login * SOAP_FMAC2 soap_dup___tempuri__Login(struct soap *soap, struct __tempuri__Login *d, struct __tempuri__Login const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__Login*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__Login, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__Login(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__Login(soap, &d->tempuri__Login, &a->tempuri__Login);
	return d;
}

SOAP_FMAC1 struct __tempuri__Login * SOAP_FMAC2 soap_instantiate___tempuri__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__Login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__Login *p;
	size_t k = sizeof(struct __tempuri__Login);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__Login, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__Login);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__Login, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__Login location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__Login(struct soap *soap, const struct __tempuri__Login *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__Login(soap, tag ? tag : "-tempuri:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__Login * SOAP_FMAC4 soap_get___tempuri__Login(struct soap *soap, struct __tempuri__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetPower(struct soap *soap, struct __tempuri__GetPower *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetPower = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetPower(struct soap *soap, const struct __tempuri__GetPower *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetPower(soap, &a->tempuri__GetPower);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetPower(struct soap *soap, const char *tag, int id, const struct __tempuri__GetPower *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetPower(soap, "tempuri:GetPower", -1, &a->tempuri__GetPower, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetPower * SOAP_FMAC4 soap_in___tempuri__GetPower(struct soap *soap, const char *tag, struct __tempuri__GetPower *a, const char *type)
{
	size_t soap_flag_tempuri__GetPower = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetPower *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetPower, sizeof(struct __tempuri__GetPower), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetPower(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetPower && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetPower(soap, "tempuri:GetPower", &a->tempuri__GetPower, ""))
				{	soap_flag_tempuri__GetPower--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetPower * SOAP_FMAC2 soap_dup___tempuri__GetPower(struct soap *soap, struct __tempuri__GetPower *d, struct __tempuri__GetPower const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__GetPower*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__GetPower, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__GetPower(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__GetPower(soap, &d->tempuri__GetPower, &a->tempuri__GetPower);
	return d;
}

SOAP_FMAC1 struct __tempuri__GetPower * SOAP_FMAC2 soap_instantiate___tempuri__GetPower(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetPower(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetPower *p;
	size_t k = sizeof(struct __tempuri__GetPower);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetPower, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetPower);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetPower, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetPower location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetPower(struct soap *soap, const struct __tempuri__GetPower *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetPower(soap, tag ? tag : "-tempuri:GetPower", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetPower * SOAP_FMAC4 soap_get___tempuri__GetPower(struct soap *soap, struct __tempuri__GetPower *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetPower(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDept(struct soap *soap, struct __tempuri__GetDept *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDept = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDept(struct soap *soap, const struct __tempuri__GetDept *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDept(soap, &a->tempuri__GetDept);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDept(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDept *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDept(soap, "tempuri:GetDept", -1, &a->tempuri__GetDept, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDept * SOAP_FMAC4 soap_in___tempuri__GetDept(struct soap *soap, const char *tag, struct __tempuri__GetDept *a, const char *type)
{
	size_t soap_flag_tempuri__GetDept = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDept *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDept, sizeof(struct __tempuri__GetDept), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDept(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDept && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDept(soap, "tempuri:GetDept", &a->tempuri__GetDept, ""))
				{	soap_flag_tempuri__GetDept--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDept * SOAP_FMAC2 soap_dup___tempuri__GetDept(struct soap *soap, struct __tempuri__GetDept *d, struct __tempuri__GetDept const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__GetDept*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__GetDept, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__GetDept(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__GetDept(soap, &d->tempuri__GetDept, &a->tempuri__GetDept);
	return d;
}

SOAP_FMAC1 struct __tempuri__GetDept * SOAP_FMAC2 soap_instantiate___tempuri__GetDept(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDept(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDept *p;
	size_t k = sizeof(struct __tempuri__GetDept);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetDept, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetDept);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetDept, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDept location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDept(struct soap *soap, const struct __tempuri__GetDept *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDept(soap, tag ? tag : "-tempuri:GetDept", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDept * SOAP_FMAC4 soap_get___tempuri__GetDept(struct soap *soap, struct __tempuri__GetDept *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDept(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__DocAdd(struct soap *soap, struct __tempuri__DocAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__DocAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__DocAdd(struct soap *soap, const struct __tempuri__DocAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__DocAdd(soap, &a->tempuri__DocAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__DocAdd(struct soap *soap, const char *tag, int id, const struct __tempuri__DocAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", -1, &a->tempuri__DocAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd * SOAP_FMAC4 soap_in___tempuri__DocAdd(struct soap *soap, const char *tag, struct __tempuri__DocAdd *a, const char *type)
{
	size_t soap_flag_tempuri__DocAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__DocAdd *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__DocAdd, sizeof(struct __tempuri__DocAdd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__DocAdd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__DocAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", &a->tempuri__DocAdd, ""))
				{	soap_flag_tempuri__DocAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__DocAdd * SOAP_FMAC2 soap_dup___tempuri__DocAdd(struct soap *soap, struct __tempuri__DocAdd *d, struct __tempuri__DocAdd const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__DocAdd*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__DocAdd, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__DocAdd(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__DocAdd(soap, &d->tempuri__DocAdd, &a->tempuri__DocAdd);
	return d;
}

SOAP_FMAC1 struct __tempuri__DocAdd * SOAP_FMAC2 soap_instantiate___tempuri__DocAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__DocAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__DocAdd *p;
	size_t k = sizeof(struct __tempuri__DocAdd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__DocAdd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__DocAdd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__DocAdd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__DocAdd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__DocAdd(struct soap *soap, const struct __tempuri__DocAdd *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__DocAdd(soap, tag ? tag : "-tempuri:DocAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd * SOAP_FMAC4 soap_get___tempuri__DocAdd(struct soap *soap, struct __tempuri__DocAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__DocAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__ItemsAdd(struct soap *soap, struct __tempuri__ItemsAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ItemsAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__ItemsAdd(struct soap *soap, const struct __tempuri__ItemsAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ItemsAdd(soap, &a->tempuri__ItemsAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__ItemsAdd(struct soap *soap, const char *tag, int id, const struct __tempuri__ItemsAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ItemsAdd(soap, "tempuri:ItemsAdd", -1, &a->tempuri__ItemsAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ItemsAdd * SOAP_FMAC4 soap_in___tempuri__ItemsAdd(struct soap *soap, const char *tag, struct __tempuri__ItemsAdd *a, const char *type)
{
	size_t soap_flag_tempuri__ItemsAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__ItemsAdd *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__ItemsAdd, sizeof(struct __tempuri__ItemsAdd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__ItemsAdd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ItemsAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ItemsAdd(soap, "tempuri:ItemsAdd", &a->tempuri__ItemsAdd, ""))
				{	soap_flag_tempuri__ItemsAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__ItemsAdd * SOAP_FMAC2 soap_dup___tempuri__ItemsAdd(struct soap *soap, struct __tempuri__ItemsAdd *d, struct __tempuri__ItemsAdd const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__ItemsAdd*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__ItemsAdd, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__ItemsAdd(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__ItemsAdd(soap, &d->tempuri__ItemsAdd, &a->tempuri__ItemsAdd);
	return d;
}

SOAP_FMAC1 struct __tempuri__ItemsAdd * SOAP_FMAC2 soap_instantiate___tempuri__ItemsAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__ItemsAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__ItemsAdd *p;
	size_t k = sizeof(struct __tempuri__ItemsAdd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__ItemsAdd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__ItemsAdd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__ItemsAdd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__ItemsAdd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__ItemsAdd(struct soap *soap, const struct __tempuri__ItemsAdd *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__ItemsAdd(soap, tag ? tag : "-tempuri:ItemsAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ItemsAdd * SOAP_FMAC4 soap_get___tempuri__ItemsAdd(struct soap *soap, struct __tempuri__ItemsAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__ItemsAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventoryReturn(struct soap *soap, struct __tempuri__LineInventoryReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventoryReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventoryReturn(struct soap *soap, const struct __tempuri__LineInventoryReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventoryReturn(soap, &a->tempuri__LineInventoryReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventoryReturn(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventoryReturn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventoryReturn(soap, "tempuri:LineInventoryReturn", -1, &a->tempuri__LineInventoryReturn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryReturn * SOAP_FMAC4 soap_in___tempuri__LineInventoryReturn(struct soap *soap, const char *tag, struct __tempuri__LineInventoryReturn *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventoryReturn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventoryReturn *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventoryReturn, sizeof(struct __tempuri__LineInventoryReturn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventoryReturn(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventoryReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventoryReturn(soap, "tempuri:LineInventoryReturn", &a->tempuri__LineInventoryReturn, ""))
				{	soap_flag_tempuri__LineInventoryReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventoryReturn * SOAP_FMAC2 soap_dup___tempuri__LineInventoryReturn(struct soap *soap, struct __tempuri__LineInventoryReturn *d, struct __tempuri__LineInventoryReturn const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__LineInventoryReturn*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__LineInventoryReturn, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__LineInventoryReturn(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__LineInventoryReturn(soap, &d->tempuri__LineInventoryReturn, &a->tempuri__LineInventoryReturn);
	return d;
}

SOAP_FMAC1 struct __tempuri__LineInventoryReturn * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryReturn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventoryReturn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventoryReturn *p;
	size_t k = sizeof(struct __tempuri__LineInventoryReturn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__LineInventoryReturn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__LineInventoryReturn);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__LineInventoryReturn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventoryReturn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventoryReturn(struct soap *soap, const struct __tempuri__LineInventoryReturn *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventoryReturn(soap, tag ? tag : "-tempuri:LineInventoryReturn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryReturn * SOAP_FMAC4 soap_get___tempuri__LineInventoryReturn(struct soap *soap, struct __tempuri__LineInventoryReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventoryReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventoryUpdate(struct soap *soap, struct __tempuri__LineInventoryUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventoryUpdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventoryUpdate(struct soap *soap, const struct __tempuri__LineInventoryUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventoryUpdate(soap, &a->tempuri__LineInventoryUpdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventoryUpdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventoryUpdate(soap, "tempuri:LineInventoryUpdate", -1, &a->tempuri__LineInventoryUpdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryUpdate * SOAP_FMAC4 soap_in___tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, struct __tempuri__LineInventoryUpdate *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventoryUpdate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventoryUpdate *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventoryUpdate, sizeof(struct __tempuri__LineInventoryUpdate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventoryUpdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventoryUpdate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventoryUpdate(soap, "tempuri:LineInventoryUpdate", &a->tempuri__LineInventoryUpdate, ""))
				{	soap_flag_tempuri__LineInventoryUpdate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventoryUpdate * SOAP_FMAC2 soap_dup___tempuri__LineInventoryUpdate(struct soap *soap, struct __tempuri__LineInventoryUpdate *d, struct __tempuri__LineInventoryUpdate const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__LineInventoryUpdate*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__LineInventoryUpdate, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__LineInventoryUpdate(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__LineInventoryUpdate(soap, &d->tempuri__LineInventoryUpdate, &a->tempuri__LineInventoryUpdate);
	return d;
}

SOAP_FMAC1 struct __tempuri__LineInventoryUpdate * SOAP_FMAC2 soap_instantiate___tempuri__LineInventoryUpdate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventoryUpdate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventoryUpdate *p;
	size_t k = sizeof(struct __tempuri__LineInventoryUpdate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__LineInventoryUpdate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__LineInventoryUpdate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__LineInventoryUpdate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventoryUpdate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventoryUpdate(struct soap *soap, const struct __tempuri__LineInventoryUpdate *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventoryUpdate(soap, tag ? tag : "-tempuri:LineInventoryUpdate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventoryUpdate * SOAP_FMAC4 soap_get___tempuri__LineInventoryUpdate(struct soap *soap, struct __tempuri__LineInventoryUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventoryUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventory(struct soap *soap, struct __tempuri__LineInventory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventory(struct soap *soap, const struct __tempuri__LineInventory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventory(soap, &a->tempuri__LineInventory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventory(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", -1, &a->tempuri__LineInventory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory * SOAP_FMAC4 soap_in___tempuri__LineInventory(struct soap *soap, const char *tag, struct __tempuri__LineInventory *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventory = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventory *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventory, sizeof(struct __tempuri__LineInventory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventory && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", &a->tempuri__LineInventory, ""))
				{	soap_flag_tempuri__LineInventory--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventory * SOAP_FMAC2 soap_dup___tempuri__LineInventory(struct soap *soap, struct __tempuri__LineInventory *d, struct __tempuri__LineInventory const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__LineInventory*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__LineInventory, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__LineInventory(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__LineInventory(soap, &d->tempuri__LineInventory, &a->tempuri__LineInventory);
	return d;
}

SOAP_FMAC1 struct __tempuri__LineInventory * SOAP_FMAC2 soap_instantiate___tempuri__LineInventory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventory *p;
	size_t k = sizeof(struct __tempuri__LineInventory);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__LineInventory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__LineInventory);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__LineInventory, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventory location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventory(struct soap *soap, const struct __tempuri__LineInventory *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventory(soap, tag ? tag : "-tempuri:LineInventory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory * SOAP_FMAC4 soap_get___tempuri__LineInventory(struct soap *soap, struct __tempuri__LineInventory *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__WorkOrder(struct soap *soap, struct __tempuri__WorkOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__WorkOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__WorkOrder(struct soap *soap, const struct __tempuri__WorkOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__WorkOrder(soap, &a->tempuri__WorkOrder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__WorkOrder(struct soap *soap, const char *tag, int id, const struct __tempuri__WorkOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__WorkOrder(soap, "tempuri:WorkOrder", -1, &a->tempuri__WorkOrder, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__WorkOrder * SOAP_FMAC4 soap_in___tempuri__WorkOrder(struct soap *soap, const char *tag, struct __tempuri__WorkOrder *a, const char *type)
{
	size_t soap_flag_tempuri__WorkOrder = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__WorkOrder *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__WorkOrder, sizeof(struct __tempuri__WorkOrder), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__WorkOrder(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__WorkOrder && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__WorkOrder(soap, "tempuri:WorkOrder", &a->tempuri__WorkOrder, ""))
				{	soap_flag_tempuri__WorkOrder--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__WorkOrder * SOAP_FMAC2 soap_dup___tempuri__WorkOrder(struct soap *soap, struct __tempuri__WorkOrder *d, struct __tempuri__WorkOrder const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__WorkOrder*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__WorkOrder, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__WorkOrder(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__WorkOrder(soap, &d->tempuri__WorkOrder, &a->tempuri__WorkOrder);
	return d;
}

SOAP_FMAC1 struct __tempuri__WorkOrder * SOAP_FMAC2 soap_instantiate___tempuri__WorkOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__WorkOrder(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__WorkOrder *p;
	size_t k = sizeof(struct __tempuri__WorkOrder);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__WorkOrder, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__WorkOrder);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__WorkOrder, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__WorkOrder location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__WorkOrder(struct soap *soap, const struct __tempuri__WorkOrder *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__WorkOrder(soap, tag ? tag : "-tempuri:WorkOrder", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__WorkOrder * SOAP_FMAC4 soap_get___tempuri__WorkOrder(struct soap *soap, struct __tempuri__WorkOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__WorkOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__ToolingTimes(struct soap *soap, struct __tempuri__ToolingTimes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ToolingTimes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__ToolingTimes(struct soap *soap, const struct __tempuri__ToolingTimes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ToolingTimes(soap, &a->tempuri__ToolingTimes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__ToolingTimes(struct soap *soap, const char *tag, int id, const struct __tempuri__ToolingTimes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", -1, &a->tempuri__ToolingTimes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes * SOAP_FMAC4 soap_in___tempuri__ToolingTimes(struct soap *soap, const char *tag, struct __tempuri__ToolingTimes *a, const char *type)
{
	size_t soap_flag_tempuri__ToolingTimes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__ToolingTimes *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__ToolingTimes, sizeof(struct __tempuri__ToolingTimes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__ToolingTimes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ToolingTimes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", &a->tempuri__ToolingTimes, ""))
				{	soap_flag_tempuri__ToolingTimes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__ToolingTimes * SOAP_FMAC2 soap_dup___tempuri__ToolingTimes(struct soap *soap, struct __tempuri__ToolingTimes *d, struct __tempuri__ToolingTimes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__ToolingTimes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__ToolingTimes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__ToolingTimes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__ToolingTimes(soap, &d->tempuri__ToolingTimes, &a->tempuri__ToolingTimes);
	return d;
}

SOAP_FMAC1 struct __tempuri__ToolingTimes * SOAP_FMAC2 soap_instantiate___tempuri__ToolingTimes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__ToolingTimes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__ToolingTimes *p;
	size_t k = sizeof(struct __tempuri__ToolingTimes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__ToolingTimes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__ToolingTimes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__ToolingTimes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__ToolingTimes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__ToolingTimes(struct soap *soap, const struct __tempuri__ToolingTimes *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__ToolingTimes(soap, tag ? tag : "-tempuri:ToolingTimes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes * SOAP_FMAC4 soap_get___tempuri__ToolingTimes(struct soap *soap, struct __tempuri__ToolingTimes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__ToolingTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDocCode(struct soap *soap, struct __tempuri__GetDocCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDocCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDocCode(struct soap *soap, const struct __tempuri__GetDocCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDocCode(soap, &a->tempuri__GetDocCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDocCode(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDocCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDocCode(soap, "tempuri:GetDocCode", -1, &a->tempuri__GetDocCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDocCode * SOAP_FMAC4 soap_in___tempuri__GetDocCode(struct soap *soap, const char *tag, struct __tempuri__GetDocCode *a, const char *type)
{
	size_t soap_flag_tempuri__GetDocCode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDocCode *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDocCode, sizeof(struct __tempuri__GetDocCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDocCode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDocCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDocCode(soap, "tempuri:GetDocCode", &a->tempuri__GetDocCode, ""))
				{	soap_flag_tempuri__GetDocCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDocCode * SOAP_FMAC2 soap_dup___tempuri__GetDocCode(struct soap *soap, struct __tempuri__GetDocCode *d, struct __tempuri__GetDocCode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__GetDocCode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__GetDocCode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__GetDocCode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__GetDocCode(soap, &d->tempuri__GetDocCode, &a->tempuri__GetDocCode);
	return d;
}

SOAP_FMAC1 struct __tempuri__GetDocCode * SOAP_FMAC2 soap_instantiate___tempuri__GetDocCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDocCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDocCode *p;
	size_t k = sizeof(struct __tempuri__GetDocCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetDocCode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetDocCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetDocCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDocCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDocCode(struct soap *soap, const struct __tempuri__GetDocCode *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDocCode(soap, tag ? tag : "-tempuri:GetDocCode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDocCode * SOAP_FMAC4 soap_get___tempuri__GetDocCode(struct soap *soap, struct __tempuri__GetDocCode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDocCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetDate(struct soap *soap, struct __tempuri__GetDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__GetDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetDate(struct soap *soap, const struct __tempuri__GetDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__GetDate(soap, &a->tempuri__GetDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetDate(struct soap *soap, const char *tag, int id, const struct __tempuri__GetDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__GetDate(soap, "tempuri:GetDate", -1, &a->tempuri__GetDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDate * SOAP_FMAC4 soap_in___tempuri__GetDate(struct soap *soap, const char *tag, struct __tempuri__GetDate *a, const char *type)
{
	size_t soap_flag_tempuri__GetDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetDate *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetDate, sizeof(struct __tempuri__GetDate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetDate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__GetDate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__GetDate(soap, "tempuri:GetDate", &a->tempuri__GetDate, ""))
				{	soap_flag_tempuri__GetDate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetDate * SOAP_FMAC2 soap_dup___tempuri__GetDate(struct soap *soap, struct __tempuri__GetDate *d, struct __tempuri__GetDate const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tempuri__GetDate*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tempuri__GetDate, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tempuri__GetDate(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tempuri__GetDate(soap, &d->tempuri__GetDate, &a->tempuri__GetDate);
	return d;
}

SOAP_FMAC1 struct __tempuri__GetDate * SOAP_FMAC2 soap_instantiate___tempuri__GetDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetDate *p;
	size_t k = sizeof(struct __tempuri__GetDate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetDate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetDate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetDate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetDate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetDate(struct soap *soap, const struct __tempuri__GetDate *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetDate(soap, tag ? tag : "-tempuri:GetDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetDate * SOAP_FMAC4 soap_get___tempuri__GetDate(struct soap *soap, struct __tempuri__GetDate *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * * SOAP_FMAC2 soap_dup_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason * *d, struct SOAP_ENV__Reason *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_SOAP_ENV__Reason(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * * SOAP_FMAC2 soap_dup_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail * *d, struct SOAP_ENV__Detail *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_SOAP_ENV__Detail(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * * SOAP_FMAC2 soap_dup_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code * *d, struct SOAP_ENV__Code *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_SOAP_ENV__Code(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDanSLTypeAdd(struct soap *soap, _tempuri__AnDanSLTypeAdd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDanSLTypeAdd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDanSLTypeAdd(struct soap *soap, const char *tag, int id, _tempuri__AnDanSLTypeAdd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDanSLTypeAdd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDanSLTypeAdd ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeAdd ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDanSLTypeAdd(struct soap *soap, const char *tag, _tempuri__AnDanSLTypeAdd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDanSLTypeAdd **)soap_malloc(soap, sizeof(_tempuri__AnDanSLTypeAdd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDanSLTypeAdd *)soap_instantiate__tempuri__AnDanSLTypeAdd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDanSLTypeAdd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDanSLTypeAdd, sizeof(_tempuri__AnDanSLTypeAdd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDanSLTypeAdd * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__AnDanSLTypeAdd(struct soap *soap, _tempuri__AnDanSLTypeAdd * *d, _tempuri__AnDanSLTypeAdd *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__AnDanSLTypeAdd **)soap_malloc(soap, sizeof(_tempuri__AnDanSLTypeAdd *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDanSLTypeAdd(struct soap *soap, _tempuri__AnDanSLTypeAdd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDanSLTypeAdd(soap, tag ? tag : "tempuri:AnDanSLTypeAdd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeAdd ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDanSLTypeAdd(struct soap *soap, _tempuri__AnDanSLTypeAdd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDanSLTypeAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDanSLTypeGet(struct soap *soap, _tempuri__AnDanSLTypeGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDanSLTypeGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDanSLTypeGet(struct soap *soap, const char *tag, int id, _tempuri__AnDanSLTypeGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDanSLTypeGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDanSLTypeGet ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeGet ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDanSLTypeGet(struct soap *soap, const char *tag, _tempuri__AnDanSLTypeGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDanSLTypeGet **)soap_malloc(soap, sizeof(_tempuri__AnDanSLTypeGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDanSLTypeGet *)soap_instantiate__tempuri__AnDanSLTypeGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDanSLTypeGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDanSLTypeGet, sizeof(_tempuri__AnDanSLTypeGet), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDanSLTypeGet * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__AnDanSLTypeGet(struct soap *soap, _tempuri__AnDanSLTypeGet * *d, _tempuri__AnDanSLTypeGet *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__AnDanSLTypeGet **)soap_malloc(soap, sizeof(_tempuri__AnDanSLTypeGet *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDanSLTypeGet(struct soap *soap, _tempuri__AnDanSLTypeGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDanSLTypeGet(soap, tag ? tag : "tempuri:AnDanSLTypeGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDanSLTypeGet ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDanSLTypeGet(struct soap *soap, _tempuri__AnDanSLTypeGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDanSLTypeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDan2PeoplePresent(struct soap *soap, _tempuri__AnDan2PeoplePresent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDan2PeoplePresent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDan2PeoplePresent(struct soap *soap, const char *tag, int id, _tempuri__AnDan2PeoplePresent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDan2PeoplePresent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDan2PeoplePresent ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDan2PeoplePresent ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDan2PeoplePresent(struct soap *soap, const char *tag, _tempuri__AnDan2PeoplePresent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDan2PeoplePresent **)soap_malloc(soap, sizeof(_tempuri__AnDan2PeoplePresent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDan2PeoplePresent *)soap_instantiate__tempuri__AnDan2PeoplePresent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDan2PeoplePresent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDan2PeoplePresent, sizeof(_tempuri__AnDan2PeoplePresent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan2PeoplePresent * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__AnDan2PeoplePresent(struct soap *soap, _tempuri__AnDan2PeoplePresent * *d, _tempuri__AnDan2PeoplePresent *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__AnDan2PeoplePresent **)soap_malloc(soap, sizeof(_tempuri__AnDan2PeoplePresent *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDan2PeoplePresent(struct soap *soap, _tempuri__AnDan2PeoplePresent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDan2PeoplePresent(soap, tag ? tag : "tempuri:AnDan2PeoplePresent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDan2PeoplePresent ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDan2PeoplePresent(struct soap *soap, _tempuri__AnDan2PeoplePresent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDan2PeoplePresent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDan3AddUsers(struct soap *soap, _tempuri__AnDan3AddUsers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDan3AddUsers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDan3AddUsers(struct soap *soap, const char *tag, int id, _tempuri__AnDan3AddUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDan3AddUsers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDan3AddUsers ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDan3AddUsers ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDan3AddUsers(struct soap *soap, const char *tag, _tempuri__AnDan3AddUsers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDan3AddUsers **)soap_malloc(soap, sizeof(_tempuri__AnDan3AddUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDan3AddUsers *)soap_instantiate__tempuri__AnDan3AddUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDan3AddUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDan3AddUsers, sizeof(_tempuri__AnDan3AddUsers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan3AddUsers * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__AnDan3AddUsers(struct soap *soap, _tempuri__AnDan3AddUsers * *d, _tempuri__AnDan3AddUsers *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__AnDan3AddUsers **)soap_malloc(soap, sizeof(_tempuri__AnDan3AddUsers *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDan3AddUsers(struct soap *soap, _tempuri__AnDan3AddUsers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDan3AddUsers(soap, tag ? tag : "tempuri:AnDan3AddUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDan3AddUsers ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDan3AddUsers(struct soap *soap, _tempuri__AnDan3AddUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDan3AddUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDan4UpdPeoplePresent(struct soap *soap, _tempuri__AnDan4UpdPeoplePresent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDan4UpdPeoplePresent(struct soap *soap, const char *tag, int id, _tempuri__AnDan4UpdPeoplePresent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDan4UpdPeoplePresent ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDan4UpdPeoplePresent(struct soap *soap, const char *tag, _tempuri__AnDan4UpdPeoplePresent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDan4UpdPeoplePresent **)soap_malloc(soap, sizeof(_tempuri__AnDan4UpdPeoplePresent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDan4UpdPeoplePresent *)soap_instantiate__tempuri__AnDan4UpdPeoplePresent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDan4UpdPeoplePresent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDan4UpdPeoplePresent, sizeof(_tempuri__AnDan4UpdPeoplePresent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan4UpdPeoplePresent * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__AnDan4UpdPeoplePresent(struct soap *soap, _tempuri__AnDan4UpdPeoplePresent * *d, _tempuri__AnDan4UpdPeoplePresent *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__AnDan4UpdPeoplePresent **)soap_malloc(soap, sizeof(_tempuri__AnDan4UpdPeoplePresent *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDan4UpdPeoplePresent(struct soap *soap, _tempuri__AnDan4UpdPeoplePresent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, tag ? tag : "tempuri:AnDan4UpdPeoplePresent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDan4UpdPeoplePresent ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDan4UpdPeoplePresent(struct soap *soap, _tempuri__AnDan4UpdPeoplePresent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDan4UpdPeoplePresent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDan1Send(struct soap *soap, _tempuri__AnDan1Send *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDan1Send))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDan1Send(struct soap *soap, const char *tag, int id, _tempuri__AnDan1Send *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDan1Send, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDan1Send ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDan1Send ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDan1Send(struct soap *soap, const char *tag, _tempuri__AnDan1Send **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDan1Send **)soap_malloc(soap, sizeof(_tempuri__AnDan1Send *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDan1Send *)soap_instantiate__tempuri__AnDan1Send(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDan1Send **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDan1Send, sizeof(_tempuri__AnDan1Send), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDan1Send * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__AnDan1Send(struct soap *soap, _tempuri__AnDan1Send * *d, _tempuri__AnDan1Send *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__AnDan1Send **)soap_malloc(soap, sizeof(_tempuri__AnDan1Send *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDan1Send(struct soap *soap, _tempuri__AnDan1Send *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDan1Send(soap, tag ? tag : "tempuri:AnDan1Send", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDan1Send ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDan1Send(struct soap *soap, _tempuri__AnDan1Send **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDan1Send(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__Login(struct soap *soap, _tempuri__Login *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__Login))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__Login(struct soap *soap, const char *tag, int id, _tempuri__Login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__Login, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__Login ? type : NULL);
}

SOAP_FMAC3 _tempuri__Login ** SOAP_FMAC4 soap_in_PointerTo_tempuri__Login(struct soap *soap, const char *tag, _tempuri__Login **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__Login **)soap_malloc(soap, sizeof(_tempuri__Login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__Login *)soap_instantiate__tempuri__Login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__Login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__Login, sizeof(_tempuri__Login), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__Login * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__Login(struct soap *soap, _tempuri__Login * *d, _tempuri__Login *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__Login **)soap_malloc(soap, sizeof(_tempuri__Login *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__Login(struct soap *soap, _tempuri__Login *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__Login(soap, tag ? tag : "tempuri:Login", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__Login ** SOAP_FMAC4 soap_get_PointerTo_tempuri__Login(struct soap *soap, _tempuri__Login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetPower(struct soap *soap, _tempuri__GetPower *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetPower))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetPower(struct soap *soap, const char *tag, int id, _tempuri__GetPower *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetPower, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetPower ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetPower ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetPower(struct soap *soap, const char *tag, _tempuri__GetPower **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetPower **)soap_malloc(soap, sizeof(_tempuri__GetPower *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetPower *)soap_instantiate__tempuri__GetPower(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetPower **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetPower, sizeof(_tempuri__GetPower), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetPower * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__GetPower(struct soap *soap, _tempuri__GetPower * *d, _tempuri__GetPower *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__GetPower **)soap_malloc(soap, sizeof(_tempuri__GetPower *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetPower(struct soap *soap, _tempuri__GetPower *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetPower(soap, tag ? tag : "tempuri:GetPower", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetPower ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetPower(struct soap *soap, _tempuri__GetPower **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetPower(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetDept(struct soap *soap, _tempuri__GetDept *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetDept))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetDept(struct soap *soap, const char *tag, int id, _tempuri__GetDept *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetDept, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetDept ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetDept ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetDept(struct soap *soap, const char *tag, _tempuri__GetDept **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetDept **)soap_malloc(soap, sizeof(_tempuri__GetDept *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetDept *)soap_instantiate__tempuri__GetDept(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetDept **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetDept, sizeof(_tempuri__GetDept), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDept * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__GetDept(struct soap *soap, _tempuri__GetDept * *d, _tempuri__GetDept *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__GetDept **)soap_malloc(soap, sizeof(_tempuri__GetDept *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetDept(struct soap *soap, _tempuri__GetDept *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetDept(soap, tag ? tag : "tempuri:GetDept", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetDept ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetDept(struct soap *soap, _tempuri__GetDept **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetDept(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__DocAdd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__DocAdd(struct soap *soap, const char *tag, int id, _tempuri__DocAdd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__DocAdd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__DocAdd ? type : NULL);
}

SOAP_FMAC3 _tempuri__DocAdd ** SOAP_FMAC4 soap_in_PointerTo_tempuri__DocAdd(struct soap *soap, const char *tag, _tempuri__DocAdd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__DocAdd **)soap_malloc(soap, sizeof(_tempuri__DocAdd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__DocAdd *)soap_instantiate__tempuri__DocAdd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__DocAdd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__DocAdd, sizeof(_tempuri__DocAdd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__DocAdd * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd * *d, _tempuri__DocAdd *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__DocAdd **)soap_malloc(soap, sizeof(_tempuri__DocAdd *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__DocAdd(soap, tag ? tag : "tempuri:DocAdd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__DocAdd ** SOAP_FMAC4 soap_get_PointerTo_tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__DocAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__ItemsAdd(struct soap *soap, _tempuri__ItemsAdd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__ItemsAdd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__ItemsAdd(struct soap *soap, const char *tag, int id, _tempuri__ItemsAdd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__ItemsAdd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__ItemsAdd ? type : NULL);
}

SOAP_FMAC3 _tempuri__ItemsAdd ** SOAP_FMAC4 soap_in_PointerTo_tempuri__ItemsAdd(struct soap *soap, const char *tag, _tempuri__ItemsAdd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__ItemsAdd **)soap_malloc(soap, sizeof(_tempuri__ItemsAdd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__ItemsAdd *)soap_instantiate__tempuri__ItemsAdd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__ItemsAdd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__ItemsAdd, sizeof(_tempuri__ItemsAdd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ItemsAdd * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__ItemsAdd(struct soap *soap, _tempuri__ItemsAdd * *d, _tempuri__ItemsAdd *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__ItemsAdd **)soap_malloc(soap, sizeof(_tempuri__ItemsAdd *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__ItemsAdd(struct soap *soap, _tempuri__ItemsAdd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__ItemsAdd(soap, tag ? tag : "tempuri:ItemsAdd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__ItemsAdd ** SOAP_FMAC4 soap_get_PointerTo_tempuri__ItemsAdd(struct soap *soap, _tempuri__ItemsAdd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__ItemsAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, _tempuri__LineInventoryReturn *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__LineInventoryReturn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, const char *tag, int id, _tempuri__LineInventoryReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__LineInventoryReturn, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__LineInventoryReturn ? type : NULL);
}

SOAP_FMAC3 _tempuri__LineInventoryReturn ** SOAP_FMAC4 soap_in_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, const char *tag, _tempuri__LineInventoryReturn **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__LineInventoryReturn **)soap_malloc(soap, sizeof(_tempuri__LineInventoryReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__LineInventoryReturn *)soap_instantiate__tempuri__LineInventoryReturn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__LineInventoryReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__LineInventoryReturn, sizeof(_tempuri__LineInventoryReturn), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryReturn * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, _tempuri__LineInventoryReturn * *d, _tempuri__LineInventoryReturn *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__LineInventoryReturn **)soap_malloc(soap, sizeof(_tempuri__LineInventoryReturn *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, _tempuri__LineInventoryReturn *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__LineInventoryReturn(soap, tag ? tag : "tempuri:LineInventoryReturn", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__LineInventoryReturn ** SOAP_FMAC4 soap_get_PointerTo_tempuri__LineInventoryReturn(struct soap *soap, _tempuri__LineInventoryReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__LineInventoryReturn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, _tempuri__LineInventoryUpdate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__LineInventoryUpdate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, int id, _tempuri__LineInventoryUpdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__LineInventoryUpdate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__LineInventoryUpdate ? type : NULL);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdate ** SOAP_FMAC4 soap_in_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, const char *tag, _tempuri__LineInventoryUpdate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__LineInventoryUpdate **)soap_malloc(soap, sizeof(_tempuri__LineInventoryUpdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__LineInventoryUpdate *)soap_instantiate__tempuri__LineInventoryUpdate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__LineInventoryUpdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__LineInventoryUpdate, sizeof(_tempuri__LineInventoryUpdate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryUpdate * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, _tempuri__LineInventoryUpdate * *d, _tempuri__LineInventoryUpdate *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__LineInventoryUpdate **)soap_malloc(soap, sizeof(_tempuri__LineInventoryUpdate *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, _tempuri__LineInventoryUpdate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__LineInventoryUpdate(soap, tag ? tag : "tempuri:LineInventoryUpdate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__LineInventoryUpdate ** SOAP_FMAC4 soap_get_PointerTo_tempuri__LineInventoryUpdate(struct soap *soap, _tempuri__LineInventoryUpdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__LineInventoryUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__LineInventory))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__LineInventory(struct soap *soap, const char *tag, int id, _tempuri__LineInventory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__LineInventory, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__LineInventory ? type : NULL);
}

SOAP_FMAC3 _tempuri__LineInventory ** SOAP_FMAC4 soap_in_PointerTo_tempuri__LineInventory(struct soap *soap, const char *tag, _tempuri__LineInventory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__LineInventory **)soap_malloc(soap, sizeof(_tempuri__LineInventory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__LineInventory *)soap_instantiate__tempuri__LineInventory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__LineInventory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__LineInventory, sizeof(_tempuri__LineInventory), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventory * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory * *d, _tempuri__LineInventory *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__LineInventory **)soap_malloc(soap, sizeof(_tempuri__LineInventory *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__LineInventory(soap, tag ? tag : "tempuri:LineInventory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__LineInventory ** SOAP_FMAC4 soap_get_PointerTo_tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__LineInventory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__WorkOrder(struct soap *soap, _tempuri__WorkOrder *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__WorkOrder))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__WorkOrder(struct soap *soap, const char *tag, int id, _tempuri__WorkOrder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__WorkOrder, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__WorkOrder ? type : NULL);
}

SOAP_FMAC3 _tempuri__WorkOrder ** SOAP_FMAC4 soap_in_PointerTo_tempuri__WorkOrder(struct soap *soap, const char *tag, _tempuri__WorkOrder **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__WorkOrder **)soap_malloc(soap, sizeof(_tempuri__WorkOrder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__WorkOrder *)soap_instantiate__tempuri__WorkOrder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__WorkOrder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__WorkOrder, sizeof(_tempuri__WorkOrder), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__WorkOrder * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__WorkOrder(struct soap *soap, _tempuri__WorkOrder * *d, _tempuri__WorkOrder *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__WorkOrder **)soap_malloc(soap, sizeof(_tempuri__WorkOrder *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__WorkOrder(struct soap *soap, _tempuri__WorkOrder *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__WorkOrder(soap, tag ? tag : "tempuri:WorkOrder", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__WorkOrder ** SOAP_FMAC4 soap_get_PointerTo_tempuri__WorkOrder(struct soap *soap, _tempuri__WorkOrder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__WorkOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__ToolingTimes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__ToolingTimes(struct soap *soap, const char *tag, int id, _tempuri__ToolingTimes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__ToolingTimes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__ToolingTimes ? type : NULL);
}

SOAP_FMAC3 _tempuri__ToolingTimes ** SOAP_FMAC4 soap_in_PointerTo_tempuri__ToolingTimes(struct soap *soap, const char *tag, _tempuri__ToolingTimes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__ToolingTimes **)soap_malloc(soap, sizeof(_tempuri__ToolingTimes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__ToolingTimes *)soap_instantiate__tempuri__ToolingTimes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__ToolingTimes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__ToolingTimes, sizeof(_tempuri__ToolingTimes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ToolingTimes * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes * *d, _tempuri__ToolingTimes *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__ToolingTimes **)soap_malloc(soap, sizeof(_tempuri__ToolingTimes *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__ToolingTimes(soap, tag ? tag : "tempuri:ToolingTimes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__ToolingTimes ** SOAP_FMAC4 soap_get_PointerTo_tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__ToolingTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetDocCode(struct soap *soap, _tempuri__GetDocCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetDocCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetDocCode(struct soap *soap, const char *tag, int id, _tempuri__GetDocCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetDocCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetDocCode ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetDocCode ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetDocCode(struct soap *soap, const char *tag, _tempuri__GetDocCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetDocCode **)soap_malloc(soap, sizeof(_tempuri__GetDocCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetDocCode *)soap_instantiate__tempuri__GetDocCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetDocCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetDocCode, sizeof(_tempuri__GetDocCode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDocCode * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__GetDocCode(struct soap *soap, _tempuri__GetDocCode * *d, _tempuri__GetDocCode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__GetDocCode **)soap_malloc(soap, sizeof(_tempuri__GetDocCode *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetDocCode(struct soap *soap, _tempuri__GetDocCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetDocCode(soap, tag ? tag : "tempuri:GetDocCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetDocCode ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetDocCode(struct soap *soap, _tempuri__GetDocCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetDocCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__GetDate(struct soap *soap, _tempuri__GetDate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__GetDate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__GetDate(struct soap *soap, const char *tag, int id, _tempuri__GetDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__GetDate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__GetDate ? type : NULL);
}

SOAP_FMAC3 _tempuri__GetDate ** SOAP_FMAC4 soap_in_PointerTo_tempuri__GetDate(struct soap *soap, const char *tag, _tempuri__GetDate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__GetDate **)soap_malloc(soap, sizeof(_tempuri__GetDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__GetDate *)soap_instantiate__tempuri__GetDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__GetDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__GetDate, sizeof(_tempuri__GetDate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__GetDate * * SOAP_FMAC2 soap_dup_PointerTo_tempuri__GetDate(struct soap *soap, _tempuri__GetDate * *d, _tempuri__GetDate *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tempuri__GetDate **)soap_malloc(soap, sizeof(_tempuri__GetDate *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__GetDate(struct soap *soap, _tempuri__GetDate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__GetDate(soap, tag ? tag : "tempuri:GetDate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__GetDate ** SOAP_FMAC4 soap_get_PointerTo_tempuri__GetDate(struct soap *soap, _tempuri__GetDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__GetDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTostd__string(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_std__string(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_dup_string(struct soap *soap, char * *d, char *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (char **)soap_malloc(soap, sizeof(char *))))
		return NULL; /* ERROR */
	*d = NULL;
	if (*a)
	{	struct soap_plist *pp = NULL;
		if (!(*d = (char *)soap_mark_lookup(soap, (const void*)*a, SOAP_TYPE_string, &pp, NULL)))
			soap_mark_dup(soap, *d = soap_strdup(soap, *a), pp);
	}
	else
		*d = NULL;
	return d;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
